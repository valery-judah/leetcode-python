{
  "category": "",
  "id": "202",
  "name": "Happy Number",
  "difficulty": "Easy",
  "leetcode_url": "https://leetcode.com/problems/happy-number/",
  "slug": "happy-number",
  "isPaidOnly": false,
  "tags": [
    "Hash Table",
    "Math",
    "Two Pointers"
  ],
  "similar_questions": [
    {
      "title": "Linked List Cycle",
      "difficulty": "Easy",
      "slug": "linked-list-cycle"
    },
    {
      "title": "Add Digits",
      "difficulty": "Easy",
      "slug": "add-digits"
    },
    {
      "title": "Ugly Number",
      "difficulty": "Easy",
      "slug": "ugly-number"
    },
    {
      "title": "Sum of Digits of String After Convert",
      "difficulty": "Easy",
      "slug": "sum-of-digits-of-string-after-convert"
    },
    {
      "title": "Minimum Addition to Make Integer Beautiful",
      "difficulty": "Medium",
      "slug": "minimum-addition-to-make-integer-beautiful"
    },
    {
      "title": "Smallest Value After Replacing With Sum of Prime Factors",
      "difficulty": "Medium",
      "slug": "smallest-value-after-replacing-with-sum-of-prime-factors"
    },
    {
      "title": "Count the Digits That Divide a Number",
      "difficulty": "Easy",
      "slug": "count-the-digits-that-divide-a-number"
    }
  ],
  "questionId": "202",
  "questionFrontendId": "202",
  "title": "Happy Number",
  "titleSlug": "happy-number",
  "content": "<p>Write an algorithm to determine if a number <code>n</code> is happy.</p>\n\n<p>A <strong>happy number</strong> is a number defined by the following process:</p>\n\n<ul>\n\t<li>Starting with any positive integer, replace the number by the sum of the squares of its digits.</li>\n\t<li>Repeat the process until the number equals 1 (where it will stay), or it <strong>loops endlessly in a cycle</strong> which does not include 1.</li>\n\t<li>Those numbers for which this process <strong>ends in 1</strong> are happy.</li>\n</ul>\n\n<p>Return <code>true</code> <em>if</em> <code>n</code> <em>is a happy number, and</em> <code>false</code> <em>if not</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 19\n<strong>Output:</strong> true\n<strong>Explanation:</strong>\n1<sup>2</sup> + 9<sup>2</sup> = 82\n8<sup>2</sup> + 2<sup>2</sup> = 68\n6<sup>2</sup> + 8<sup>2</sup> = 100\n1<sup>2</sup> + 0<sup>2</sup> + 0<sup>2</sup> = 1\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
  "likes": 11403,
  "dislikes": 1590,
  "stats": {
    "totalAccepted": "2M",
    "totalSubmission": "3.4M",
    "totalAcceptedRaw": 1989309,
    "totalSubmissionRaw": 3401542,
    "acRate": "58.5%"
  },
  "topicTags": [
    {
      "name": "Hash Table",
      "slug": "hash-table"
    },
    {
      "name": "Math",
      "slug": "math"
    },
    {
      "name": "Two Pointers",
      "slug": "two-pointers"
    }
  ],
  "metaData": {
    "name": "isHappy",
    "params": [
      {
        "name": "n",
        "type": "integer"
      }
    ],
    "return": {
      "type": "boolean"
    }
  },
  "company_tag_stats": {
    "1": [
      {
        "taggedByAdmin": false,
        "name": "BlackRock",
        "slug": "blackrock",
        "timesEncountered": 15
      },
      {
        "taggedByAdmin": false,
        "name": "Google",
        "slug": "google",
        "timesEncountered": 14
      }
    ]
  },
  "discussion_posts": [
    {
      "name": "Sultan_Ul_Arfin",
      "year": 2023,
      "content": "This Happy Number problem made me Unhappy!!!\\nIt should be tagged hard or medium level problem.",
      "voteCount": 630
    },
    {
      "name": "jasonpike",
      "year": 2020,
      "content": "# Why the input number cannot go to infinity (an explanation/proof that fits the context of a technical interview)\\n# \\n**NOTE**: I am not a mathematician and this is not a valid mathematical proof. What it is, however, is pretty good justification to your interviewer *in the context of a technical interview* for why the input number can never go towards infinity and, therefore, why you do not have to handle such a case in your algorithm.\\n\\nAssuming that you\\u2019ve already found the cycle pattern that will present itself with non-happy numbers AND the problem setter (interviewer) has not allowed you to assume that the input number can only go to 1 or get stuck in a cycle (and *not* go towards infinity), we would expect continuously reassigning the input number to the sum of the squares of its digits to eventually end in one of three ways:\\n1. It eventually gets to\\xA01.\\n2. It eventually gets stuck in a cycle.\\n3. It keeps going higher and higher, up towards infinity.\\n\\nAt this point in the algorithm design problem, we have an incentive to prove that the input number n, after continuously reassigning it to the sum of the squares of its digits, will *not* reach infinity (in other words, that it will eventually go to 1 or get stuck in a cycle). The reason for this is because this case seems like it would really be annoying to detect and handle in our algorithm. So, if we could prove that the input n cannot keep increasing towards infinity, then this proof/explanation can serve as the justification to the problem setter as to why we don\\u2019t have to handle such a case.\\n\\nIt\\u2019s not immediately obvious *why* the input number n can never go to infinity. The following serves to answer this \\u201Cwhy\\u201D question. I start with some first principles that we\\u2019re given and reason from there.\\n\\n* We\\u2019re working/dealing with base 10 numbers, which means that a digit can be maximally (or, at most) 9.\\n* The order of the digits does not matter, because after we square each digit we then sum all of the transformed digits (the digits after we square them)\\u2014and because addition is commutative, it doesn\\u2019t matter what the order of the digits are in the number n. Now, what *does* matter is the frequency of relatively larger number as digits (the largest possible number of a digit being 9, obv) in an m-digit number n.\\n* Because of this, we then know that the largest number that can result from the computation (summing all of the squares of each digit) of an m-digit number n (i.e., a number with m digits!), whatever it is, only arises if the m-digit number is [stacked] full of 9\\u2019s.\\n    * In other words, for any number with m digits, the largest/greatest number you get as a result from running the computation on the m-digit number, ***for a number n that has m digits***, comes from having a number n with every digit being 9.\\n    * We know this, because we already know that what matters in getting a higher/larger/greater number from a number n with m digits (after running the computation on it) is having more frequently larger numbers as digits in the number n (e.g., the number 1999 will result in a larger number after the computation than the number 9000 will\\u2026 this is because even though 9000 is greater than 1999, the number 1999 has a higher frequency of relatively larger numbers). And so if we want to reach the upper limit of the highest resulting number from a number n with m digits, we have to reach the limit of the largest number a digit can be, which is 9, and have the highest frequency of 9 throughout the number which means having all of the digits of the number be 9. This will give us the largest resulting number (after the computation) from a number n ***with a specific number of digits m***.\\n* Now, if the input number n can approach infinity (after continuously summing the square of its digits), then the result of the computation must *eventually* increase, and if it continuously increases [to infinity], then the result must also *eventually* break into the next digit bracket, which means as n eventually goes to infinity so must m (the number of digits of n). This should be pretty common sense, but it\\u2019s worth mentioning. If the number n eventually increases to infinity, the number of digits of number n (which we denote as m) ***must*** also eventually increase to infinity!\\n* If we take a look at the best possible case/scenario for a number n to break into the next digit bracket after running the computation on it (and become an m + 1 or more digit number), the best case for a number n with m digits to do this is when the result after running the computation on number n is the highest possible it can be for a number with m digits. Well, we already know that for a number with m digits, the largest result we can get after running the computation on n is when the m-digit number n has the highest frequency (all) of the largest digits (9) possible\\u2014which means when n is a number full of 9\\u2019s! So, does an m-digit number n, full of 9\\u2019s, break into the next digit bracket and become an m + 1 or more digit number?\\n* This is where I think a really useful conceptual framework to look at and draw conclusions from is a 3 x m matrix where m is the number of digits/rows and the 3 cols are \\u201CDigits, m\\u201D, \\u201CNumber n with m digits full of 9\\u2019s\\u201D, and \\u201CLargest result possible for a number n that\\'s m digits long (which will become the next number n)\\u201D.\\n\\n![image](https://assets.leetcode.com/users/jasonnastovski/image_1585974000.png)\\n\\n\\n* This is where you must be able to detect/identify the second most important pattern from this overall algorithm design problem (second to the one where you had to detect that non-happy numbers can eventually result in cycles as continuous computations show repeated numbers).\\n* As you can see, 1-digit numbers can potentially and at most break the digit barrier and go to 2-digit numbers. The same digit-barrier breaking feature is true for 2-digit numbers: 2-digit numbers can potentially and at most break the digit barrier and become 3-digit numbers. This doesn\\u2019t look good for trying to prove that the input n does not go to infinity (in fact, up until this point, it looks like it does the opposite). However, something interesting happens when the number n is 3 digits long\\u2014for any number that is 3 digits long, it is impossible for the number to break the digit barrier as a 3-digit number full of 9\\u2019s (which results in the highest possible number from running the computation on it) results in a number that is 3 digits long. This means that for any number that is 3 digits long, the result that you get from running the computation on it can only ever be, at most, 3 digits long and it will never break the digit barrier.\\n* And, as you can also see, it doesn\\u2019t matter that 1-digit numbers and 2-digit numbers can break the digit barrier, because a 1-digit number can at most break only into 2-digit numbers\\u2026 and a 2-digit number can at most break only into 3-digit numbers\\u2014and once the number is 3 digits long, we know that it can never break into the next digit bracket! This means that we also now know that a number that\\u2019s 1 to 3 digits long (or, any number from 0 - 999) will, after continuously running the computation on the number, eventually either hit a number it has already hit (and we know a cycle has been detected) or it will eventually become 1 (and we know the original input n was a happy number). That\\u2019s great for numbers that have less than or equal to 3 digits, but what about numbers that have greater than or equal to 4 digits? If you, once more, consult the 3 x m table we\\u2019ve constructed, you will see a pattern that presents itself starting at and after when a number has 4 digits\\u2026\\n* By observation, you can see that the number of digits of a number AFTER the computation *never* recovers to break the digit bracket that the number was in BEFORE the computation. I\\u2019ve went ahead and and added a \\u201CDigits AFTER computation\\u201D and changed the original title of \\u201CDigits, m\\u201D to \\u201CDigits BEFORE computation\\u201D (the values are completely the same)\\u2014as well as added a couple more columns\\u2014to really show this feature.\\n\\n![image](https://assets.leetcode.com/users/jasonnastovski/image_1585974290.png)\\n\\n\\n* You should see that as the number of digits m of an ideal number n to break the digit bracket (a number full of 9\\u2019s) increases, the number of digits of the number AFTER the computation will *always* be less than what is was BEFORE the computation. I\\u2019ve made a graph from the table to really drive this point. The y-axis is the number of digits and the x-axis is each case that we\\u2019ve shown in the table (e.g., case 1 where number n is 9, case 2 where number n is 99, case 3 where number n is 999, etc.). The blue line is the number of digits BEFORE the computation for a given case and the green line is the number of digits AFTER the computation for a given case. The graph should be read by looking up vertically from the case number.\\n\\n![image](https://assets.leetcode.com/users/jasonnastovski/image_1585974363.png)\\n\\n\\n* It\\u2019s graphically obvious that the number of digits of a number AFTER a computation (in the case where m >= 4) will *never* \\u201Ccatch up\\u201D or recover to or supersede what the number of digits were BEFORE the computation.\\n* It\\u2019s a little inconvenient and borderline deceptive that for numbers that have a number of digits that are less than or equal to 3 that the number of digits increase AFTER the computation\\u2026 which gives the false impression or illusion that the input number n could approach infinity by continuously running the computation on it (this feature of the problem may be intentional as the interviewer may catch interviewees that get trapped by this first rise in the digit number after the computation)\\u2014this is why you *must* write out at least 4 or 5 example cases to ensure that you pick up the correct overall pattern. Think how you tested for finding the cycle pattern of a non-happy number\\u2014you probably had to run through many iterations of the input number n after running the computation on it each time before you finally found the start of a cycle and detected the cycle pattern. This same rigor should be applied to your exploring of whether or not numbers with m digits are breaking the digit barrier.\\n\\nThe key takeaway is: (already knowing that if number n has an m that is <= 3 then the number n, after continuously running the computation on it, must either go to 1 or get stuck in a cycle) if m is >= 4, then the result that comes from running the computation on the number n will NEVER break the digit barrier -> which means that it can NEVER reach infinity -> which means that you can rule this case out (and focus on the only 2 other cases (when the input number n goes to 1 or gets stuck in a cycle)).\\n\\nHopefully my intuitive, tabular, and graphical explanation of why the input number cannot go to infinity has served you well.",
      "voteCount": 478
    },
    {
      "name": "ElementNotFoundException",
      "year": 2015,
      "content": "Earlier posts gave the algorithm but did not explain why it is valid mathematically, and this is what this post is about: present a \"short\" mathematical proof.\\n\\nFirst of all, it is easy to argue that starting from a number `I`, if some value - say `a` - appears again during the process after `k` steps, the initial number `I` cannot be a happy number. Because `a` will continuously become `a` after every `k` steps.\\n\\nTherefore, as long as we can show that there is a loop after running the process continuously, the number is not a happy number.\\n\\nThere is another detail not clarified yet: For any non-happy number, will it definitely end up with a loop during the process? This is important, because it is possible for a non-happy number to follow the process endlessly while having no loop.\\n\\nTo show that a non-happy number will definitely generate a loop, we only need to show that `for any non-happy number, all outcomes during the process are bounded by some large but finite integer N`. If all outcomes can only be in a finite set `(2,N]`, and since there are infinitely many outcomes for a non-happy number, there has to be at least one duplicate, meaning a loop!\\n\\nSuppose after a couple of processes, we end up with a large outcome `O1` with `D` digits where `D` is kind of large, say `D>=4`, i.e., `O1 > 999` (If we cannot even reach such a large outcome, it means all outcomes are bounded by `999` ==> loop exists). We can easily see that after processing `O1`, the new outcome `O2` can be at most `9^2*D < 100D`, meaning that `O2` can have at most `2+d(D)` digits, where `d(D)` is the number of digits `D` have. It is obvious that `2+d(D) < D`. We can further argue that `O1` is the maximum (or boundary) of all outcomes afterwards. This can be shown by contradictory: Suppose after some steps, we reach another large number `O3 > O1`. This means we process on some number `W <= 999` that yields `O3`. However, this cannot happen because the outcome of `W` can be at most `9^2*3 < 300 < O1`.\\n\\nDone.\\n\\nPlease leave your comment if any question or suggestion.",
      "voteCount": 307
    },
    {
      "name": "easy_problems_hunter",
      "year": 2023,
      "content": "this should be a hard problem :)",
      "voteCount": 214
    },
    {
      "name": "Bulbasaur2000",
      "year": 2021,
      "content": "Logic behing my code:\\n1. Single digit numbers apart from 1 and 7, are not happy numbers.\\n2. So if n==1 or n==7 then directly return true.\\n3. Otherwise, run the loop until n>9, i.e. when the number of digits are greater than 1.\\n4. Inside this main loop, access individual digits of the number(n) and perform the square operation followed by sum.\\n5. This sum if equals to either 1 or 7, then we can return true. Else continue the loop, untill the sum becomes a single digit number.\\n6. Lastly, if 1 or 7 doesnot appear, then return false.\\n\\nTry to code it. Cheers!!!",
      "voteCount": 129
    },
    {
      "name": "anuron_das",
      "year": 2023,
      "content": "This is NOT an easy problem!!!!",
      "voteCount": 111
    },
    {
      "name": "taoqeer",
      "year": 2024,
      "content": "Stop OVER-THINKING the sh#t out of every question!!\\n- if N == 1: return True [Happy Number]\\n- if N repeats itself (that means there\\'s a cycle not ending in 1): return False [Not Happy Number]\\n- keep a record of N (in a seen set)\\n- update N to sum of square of digits\\n- Submit\\n- Congratulations on your offer from Google!! ",
      "voteCount": 106
    },
    {
      "name": "ahmedshihab7",
      "year": 2016,
      "content": "Can anyone explain how '1111111' is a happy number?\\nSo far i understood if the number ends in 1 then it will be a happy number but here\\n1^2+1^2+1^2+1^2+1^2+1^2+1^2 = 7 which ends in 7.Then how it could be a happy number?",
      "voteCount": 70
    },
    {
      "name": "clmikechan",
      "year": 2020,
      "content": "It can be proved that if n is not a happy number,\\nIt will finally goto a \\n4\\u219216\\u219237\\u219258\\u219289\\u2192145\\u219242\\u219220\\u21924 loop.\\nso just consider if go to one of these number, it will be not happy number, otherwise, it will finally stop at 1\\nThe Hint is that for n > 100, the next number will less than n",
      "voteCount": 58
    },
    {
      "name": "s18692001",
      "year": 2018,
      "content": "Hi there,\\n\\nHow do we calculate the time complexity of Happy number problem? Do we know any information that how many rounds at most it takes to finish?\\n\\n",
      "voteCount": 35
    }
  ]
}
