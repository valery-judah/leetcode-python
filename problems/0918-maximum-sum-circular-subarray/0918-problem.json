{
  "category": "",
  "id": "918",
  "name": "Maximum Sum Circular Subarray",
  "difficulty": "Medium",
  "leetcode_url": "https://leetcode.com/problems/maximum-sum-circular-subarray/",
  "slug": "maximum-sum-circular-subarray",
  "isPaidOnly": false,
  "tags": [
    "Array",
    "Divide and Conquer",
    "Dynamic Programming",
    "Queue",
    "Monotonic Queue"
  ],
  "similar_questions": [],
  "questionId": "954",
  "questionFrontendId": "918",
  "title": "Maximum Sum Circular Subarray",
  "titleSlug": "maximum-sum-circular-subarray",
  "content": "<p>Given a <strong>circular integer array</strong> <code>nums</code> of length <code>n</code>, return <em>the maximum possible sum of a non-empty <strong>subarray</strong> of </em><code>nums</code>.</p>\n\n<p>A <strong>circular array</strong> means the end of the array connects to the beginning of the array. Formally, the next element of <code>nums[i]</code> is <code>nums[(i + 1) % n]</code> and the previous element of <code>nums[i]</code> is <code>nums[(i - 1 + n) % n]</code>.</p>\n\n<p>A <strong>subarray</strong> may only include each element of the fixed buffer <code>nums</code> at most once. Formally, for a subarray <code>nums[i], nums[i + 1], ..., nums[j]</code>, there does not exist <code>i &lt;= k1</code>, <code>k2 &lt;= j</code> with <code>k1 % n == k2 % n</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,-2,3,-2]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> Subarray [3] has maximum sum 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [5,-3,5]\n<strong>Output:</strong> 10\n<strong>Explanation:</strong> Subarray [5,5] has maximum sum 5 + 5 = 10.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-3,-2,-3]\n<strong>Output:</strong> -2\n<strong>Explanation:</strong> Subarray [-2] has maximum sum -2.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>-3 * 10<sup>4</sup> &lt;= nums[i] &lt;= 3 * 10<sup>4</sup></code></li>\n</ul>\n",
  "likes": 7100,
  "dislikes": 332,
  "stats": {
    "totalAccepted": "362.9K",
    "totalSubmission": "751.2K",
    "totalAcceptedRaw": 362920,
    "totalSubmissionRaw": 751188,
    "acRate": "48.3%"
  },
  "topicTags": [
    {
      "name": "Array",
      "slug": "array"
    },
    {
      "name": "Divide and Conquer",
      "slug": "divide-and-conquer"
    },
    {
      "name": "Dynamic Programming",
      "slug": "dynamic-programming"
    },
    {
      "name": "Queue",
      "slug": "queue"
    },
    {
      "name": "Monotonic Queue",
      "slug": "monotonic-queue"
    }
  ],
  "metaData": {
    "name": "maxSubarraySumCircular",
    "params": [
      {
        "name": "nums",
        "type": "integer[]"
      }
    ],
    "return": {
      "type": "integer"
    }
  },
  "discussion_posts": [
    {
      "name": "deleted_user",
      "year": 2023,
      "content": "Anybody felt like a snake saying the title for this problem?\\n\\nmaxSSSSImum SSSSum Csssircular Sssssubarray",
      "voteCount": 204
    },
    {
      "name": "mbansalmrt",
      "year": 2023,
      "content": "3 approaches discussed!\\n\\n1) Kadane\\'s Algo and Two pointer\\n At each iteration, we will always chose a starting index and ending index and will apply KA to found max sum int, initially starting will be at the zeroth index and ending will be at the last index, then we will increment both the pointers n times following the wrap around property.\\nBONUS: You can follow the wrap around property using %operator\\nTime: O(n) for KA and O(n) for two pointers==>> O(n^2)\\n\\n2) Duplicate the array\\n Another o(n) T.C. method will be to duplicate the array and simply perform the task\\nBONUS: In this method, u will have to take care of boundary cases\\n\\n3) Finding min sum subarray.Most common method\\nFind the minimum subarray sum using KA. \\nCalculate the normal sum of the linear array\\nSubtract both of them to get the answer\\nBONUS: This will contain a boundary case when all the elements are negative, in this case just return the the minimum negative element\\n\\nPlease upvote if found helpful.\\nCheers.\\nMore optimizations and suggestions are invited.",
      "voteCount": 130
    },
    {
      "name": "user2324E",
      "year": 2023,
      "content": "This should be hard imo.",
      "voteCount": 128
    },
    {
      "name": "mandy1339",
      "year": 2022,
      "content": "I have been practicing mediums for a while and can solve the great majority in a reasonable amount of time. However I had real trouble finding a non O(N^2) Solution for this. I\\'m happy I found an O(N^2) solution and won\\'t beat myself up about not coming up with the O(N) Solution on my own. I didn\\'t think about the fact that the min subArray would be the complement of the max subarray. Like wth!! Did anyone else also have trouble with this problem?",
      "voteCount": 104
    },
    {
      "name": "Achilles_107",
      "year": 2023,
      "content": "Use Kaden\\'s algorithm:\\n1. find max_sum\\n2. find min_sum\\n3. find max of max_sum and total_sum - (-min_sum)",
      "voteCount": 48
    },
    {
      "name": "nishant7372",
      "year": 2023,
      "content": "Some good testcases: \\n[-5,4,-6]  --> 4\\n[5,-3,5]   --> 10 \\n[-2,4,-5,4,-5,9,4]  --> 15",
      "voteCount": 25
    },
    {
      "name": "SoonWooKwon",
      "year": 2018,
      "content": "..................................",
      "voteCount": 19
    },
    {
      "name": "nishant7372",
      "year": 2023,
      "content": "### Approach: \n\nStep 1. Calculate maximum Subarray sum using kadane's algo in linear array.\nStep 2. Concurrently, calculate total sum of elements of nums (to calculate right sum in O(1) time).\nStep 3: For each index i, update max if(`right sum + nums[i] + left max sum > max`).\nStep 4: return max;\n\n#####  Note: \n`For index i , right sum = sum of elements in right part of array (a[i+1]...a[n-1]).`\n`For index i , left max sum = maximum prefix sum/running sum of elements in left part of array (a[0]...a[i-1]).`\n\n#### Complexity : O(n) time & O(1) space",
      "voteCount": 15
    },
    {
      "name": "spravinkumar9952",
      "year": 2022,
      "content": "Can anyone explain me why this approach is not working ?\n1.  flat the circular array\n2. use kadane's algorithm to find maxSubSum with length of maxSubSum\n3. if len > N then remove the left element and left negative elements\n4. compare the sum with ans.\n```\nclass Solution {\npublic:\n    int maxSubarraySumCircular(vector<int>& nums) {\n        int N = nums.size(), sum = 0, ans = INT_MIN;\n        for(int i=0; i<N; i++){\n            nums.push_back(nums[i]);\n        }\n        int j = 0;\n        for(int i=0; i<2*N; i++){\n        \n            sum += nums[i];\n            ans = max(ans, nums[i]);\n            if(sum <= 0){\n                sum = 0;\n                j = i+1;\n                continue;\n            }\n\n            int len = i-j+1;\n\n            if(len>N){\n                sum -= nums[j];\n                j++;\n            }\n            while(j <= i && nums[j] <= 0){\n                sum -= nums[j++];\n            }\n\n            if(sum) ans = max(ans, sum);\n        }\n        return ans;\n    }\n}; \n```\n\n106/111 Passed \nFailed At\n[52,183,124,154,-170,-191,-240,107,-178,171,75,186,-125,61,-298,284,21,-73,-294,253,146,248,-248,127,26,289,118,-22,-300,26,-116,-113,-44,29,252,-278,47,254,-106,246,-275,42,257,15,96,-298,-69,-104,-239,-95,-4,76,-202,156,-14,-178,188,-84,78,-195,-125,28,109,125,-25,-53,58,287,55,-296,198,281,53,-160,146,298,25,-41,-3,27,-242,169,287,-281,19,91,213,115,211,-218,124,-25,-272,278,296,-177,-166,-192,97,-49,-25,168,-81,6,-94,267,293,146,-1,-258,256,283,-156,197,28,78,267,-151,-230,-66,100,-94,-66,-123,121,-214,-182,187,65,-186,215,273,243,-99,-76,178,59,190,279,300,217,67,-117,170,163,153,-37,-147,-251,296,-176,117,68,258,-159,-300,-36,-91,-60,195,-293,-116,208,175,-100,-97,188,79,-270,80,100,211,112,264,-217,-142,5,105,171,-264,-247,138,275,227,-86,30,-219,153,10,-66,267,22,-56,-70,-234,-66,89,182,110,-146,162,-48,-201,-240,-225,-15,-275,129,-117,28,150,84,-264,249,-85,70,-140,-259,26,162,5,-203,143,184,101,140,207,131,177,274,-178,-79,14,-36,104,52,31,257,273,-52,74,276,104,-133,-255,188,-252,229,200,-74,-39,-250,142,-201,-196,-43,-40,255,-149,-299,-197,-175,-96,-155,-196,-24,12,79,71,-144,-59,-120,227,-256,-163,-297,116,286,-283,-31,-221,-41,121,-170,160,205,8,88,25,-272,-107,292,-180,299,94,-97,-81,-134,37,238]\n\nOutput : 5519\nExpected : 5803",
      "voteCount": 14
    },
    {
      "name": "santanusen",
      "year": 2023,
      "content": "1. Calculate the max and min subarray sums of the linear array using Kadane\\'s algo.\\n2. If max subarray sum < 0 then all the numbers in the array are negative. Return the max subarray sum.\\n3. Else, return maximum of (a) max_subarray_sum and (b) sum - min_subarray_sum.\\n(a) is the case where max subarray is within the linear array boundary.\\n(b) is the case where max subarray wraps around the linear array boundary. [5, -1, -2, 5, 6]",
      "voteCount": 11
    }
  ]
}
