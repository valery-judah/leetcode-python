{
  "category": "",
  "id": "1004",
  "name": "Max Consecutive Ones III",
  "difficulty": "Medium",
  "leetcode_url": "https://leetcode.com/problems/max-consecutive-ones-iii/",
  "slug": "max-consecutive-ones-iii",
  "isPaidOnly": false,
  "tags": [
    "Array",
    "Binary Search",
    "Sliding Window",
    "Prefix Sum"
  ],
  "similar_questions": [
    {
      "title": "Longest Substring with At Most K Distinct Characters",
      "difficulty": "Medium",
      "slug": "longest-substring-with-at-most-k-distinct-characters"
    },
    {
      "title": "Longest Repeating Character Replacement",
      "difficulty": "Medium",
      "slug": "longest-repeating-character-replacement"
    },
    {
      "title": "Max Consecutive Ones",
      "difficulty": "Easy",
      "slug": "max-consecutive-ones"
    },
    {
      "title": "Max Consecutive Ones II",
      "difficulty": "Medium",
      "slug": "max-consecutive-ones-ii"
    },
    {
      "title": "Longest Subarray of 1's After Deleting One Element",
      "difficulty": "Medium",
      "slug": "longest-subarray-of-1s-after-deleting-one-element"
    },
    {
      "title": "Maximize the Confusion of an Exam",
      "difficulty": "Medium",
      "slug": "maximize-the-confusion-of-an-exam"
    },
    {
      "title": "Minimum Recolors to Get K Consecutive Black Blocks",
      "difficulty": "Easy",
      "slug": "minimum-recolors-to-get-k-consecutive-black-blocks"
    },
    {
      "title": "Longest Nice Subarray",
      "difficulty": "Medium",
      "slug": "longest-nice-subarray"
    },
    {
      "title": "Maximum Sum of Distinct Subarrays With Length K",
      "difficulty": "Medium",
      "slug": "maximum-sum-of-distinct-subarrays-with-length-k"
    },
    {
      "title": "Maximum Enemy Forts That Can Be Captured",
      "difficulty": "Easy",
      "slug": "maximum-enemy-forts-that-can-be-captured"
    }
  ],
  "questionId": "1046",
  "questionFrontendId": "1004",
  "title": "Max Consecutive Ones III",
  "titleSlug": "max-consecutive-ones-iii",
  "content": "<p>Given a binary array <code>nums</code> and an integer <code>k</code>, return <em>the maximum number of consecutive </em><code>1</code><em>&#39;s in the array if you can flip at most</em> <code>k</code> <code>0</code>&#39;s.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> [1,1,1,0,0,<u><strong>1</strong>,1,1,1,1,<strong>1</strong></u>]\nBolded numbers were flipped from 0 to 1. The longest subarray is underlined.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], k = 3\n<strong>Output:</strong> 10\n<strong>Explanation:</strong> [0,0,<u>1,1,<strong>1</strong>,<strong>1</strong>,1,1,1,<strong>1</strong>,1,1</u>,0,0,0,1,1,1,1]\nBolded numbers were flipped from 0 to 1. The longest subarray is underlined.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums[i]</code> is either <code>0</code> or <code>1</code>.</li>\n\t<li><code>0 &lt;= k &lt;= nums.length</code></li>\n</ul>\n",
  "likes": 9852,
  "dislikes": 172,
  "stats": {
    "totalAccepted": "1.1M",
    "totalSubmission": "1.7M",
    "totalAcceptedRaw": 1133524,
    "totalSubmissionRaw": 1702220,
    "acRate": "66.6%"
  },
  "topicTags": [
    {
      "name": "Array",
      "slug": "array"
    },
    {
      "name": "Binary Search",
      "slug": "binary-search"
    },
    {
      "name": "Sliding Window",
      "slug": "sliding-window"
    },
    {
      "name": "Prefix Sum",
      "slug": "prefix-sum"
    }
  ],
  "metaData": {
    "name": "longestOnes",
    "params": [
      {
        "name": "nums",
        "type": "integer[]"
      },
      {
        "name": "k",
        "type": "integer"
      }
    ],
    "return": {
      "type": "integer"
    }
  },
  "company_tag_stats": {
    "1": [
      {
        "taggedByAdmin": true,
        "name": "Meta",
        "slug": "facebook",
        "timesEncountered": 45
      },
      {
        "taggedByAdmin": false,
        "name": "LinkedIn",
        "slug": "linkedin",
        "timesEncountered": 17
      },
      {
        "taggedByAdmin": false,
        "name": "Amazon",
        "slug": "amazon",
        "timesEncountered": 13
      }
    ]
  },
  "discussion_posts": [
    {
      "name": "BristolJ",
      "year": 2023,
      "content": "Wow, I actually solved this my first try with no errors. \\nI was trying to avoid answering this one cause I felt pretty overwhelmed.\\nI am proud of myself",
      "voteCount": 413
    },
    {
      "name": "ankitk742",
      "year": 2023,
      "content": "Approach : Dynamic Sliding window \\n\\n1. Define the window with two pointers ( start and end pointers ) which are intially pointing to zero index of the array.\\n\\n2. If you encounter 1 while traversing the list increase the size of window by increasing the end_pointer by 1.\\n\\n3. If you encounter 0 and your k > 0 then keep on increasing the size of window by increasing end_pointer by 1.  Decrease the k by 1 to account for that you encountered 0 \\n\\n\\n4. If your k becomes 0 in this process then remove the earliest zero in the window and move the start pointer to index of earliest zero +1 \\n\\n5. Don\\'t forget to keep track of the length of the sequence in this process.\\n\\nHope it helps and don\\'t get disheartened ( it will take time )",
      "voteCount": 165
    },
    {
      "name": "psionl0",
      "year": 2023,
      "content": "This is how a problem should be. Not too easy but not too challenging and giving you an opportunity to practice an algorithm (in this case, sliding windows).",
      "voteCount": 141
    },
    {
      "name": "nylime",
      "year": 2022,
      "content": "The sliding window algorithm can be used to solve this problem, in which two pointers are used to indicate a window of the array. For each 1 found, the end of the window can be expanded by one to include the next array element, and the length of consecutive 1\\'s can be increased. When reaching a 0, as long as the number of zeroes in the list do not exceed the maximum specified by k, the end of the window can continue expanding by one. If the number of zeroes (\"flipped\") within the list reaches its maximum (specified by k), then the start of the window can be moved to the second zero in the window.",
      "voteCount": 88
    },
    {
      "name": "himan5hu_123",
      "year": 2022,
      "content": "main observation is --> atmost k zeros are allowed in window",
      "voteCount": 75
    },
    {
      "name": "chimpers",
      "year": 2024,
      "content": "Why is this question tagged in \"Binary search\" ?",
      "voteCount": 26
    },
    {
      "name": "rajeevrakoos",
      "year": 2024,
      "content": "i did my first medium question by my own and this was it...",
      "voteCount": 24
    },
    {
      "name": "adi_202new",
      "year": 2024,
      "content": "Got the same question in my interview. Instead of 0 1, it was W and H (working day and holidays) and I had to tell longest consecutive holidays that I can take if I can take at most 2 leaves. \\nThe follow question was, what if the same calendar was being followed for the next year as well, how would tell the longest consecutive holidays now.",
      "voteCount": 19
    },
    {
      "name": "useNavigate",
      "year": 2023,
      "content": "this is very similar to https://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element/description/ \\nonly big difference is that we are not deleting the element we are flipping the element so we need to do +1 ",
      "voteCount": 15
    },
    {
      "name": "mochiball",
      "year": 2023,
      "content": "Key hint : This question is basically asking maximum number of 0\\'s we can have in our window such that this number is less than or equal to k",
      "voteCount": 11
    }
  ]
}
