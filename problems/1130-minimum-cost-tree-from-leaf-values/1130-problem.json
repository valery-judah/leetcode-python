{
  "category": "",
  "id": "1130",
  "name": "Minimum Cost Tree From Leaf Values",
  "difficulty": "Medium",
  "leetcode_url": "https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/",
  "slug": "minimum-cost-tree-from-leaf-values",
  "isPaidOnly": false,
  "tags": [
    "Array",
    "Dynamic Programming",
    "Stack",
    "Greedy",
    "Monotonic Stack"
  ],
  "similar_questions": [],
  "questionId": "1228",
  "questionFrontendId": "1130",
  "title": "Minimum Cost Tree From Leaf Values",
  "titleSlug": "minimum-cost-tree-from-leaf-values",
  "content": "<p>Given an array <code>arr</code> of positive integers, consider all binary trees such that:</p>\n\n<ul>\n\t<li>Each node has either <code>0</code> or <code>2</code> children;</li>\n\t<li>The values of <code>arr</code> correspond to the values of each <strong>leaf</strong> in an in-order traversal of the tree.</li>\n\t<li>The value of each non-leaf node is equal to the product of the largest leaf value in its left and right subtree, respectively.</li>\n</ul>\n\n<p>Among all possible binary trees considered, return <em>the smallest possible sum of the values of each non-leaf node</em>. It is guaranteed this sum fits into a <strong>32-bit</strong> integer.</p>\n\n<p>A node is a <strong>leaf</strong> if and only if it has zero children.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/08/10/tree1.jpg\" style=\"width: 500px; height: 169px;\" />\n<pre>\n<strong>Input:</strong> arr = [6,2,4]\n<strong>Output:</strong> 32\n<strong>Explanation:</strong> There are two possible trees shown.\nThe first has a non-leaf node sum 36, and the second has non-leaf node sum 32.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/08/10/tree2.jpg\" style=\"width: 224px; height: 145px;\" />\n<pre>\n<strong>Input:</strong> arr = [4,11]\n<strong>Output:</strong> 44\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= arr.length &lt;= 40</code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 15</code></li>\n\t<li>It is guaranteed that the answer fits into a <strong>32-bit</strong> signed integer (i.e., it is less than 2<sup>31</sup>).</li>\n</ul>\n",
  "likes": 4391,
  "dislikes": 278,
  "stats": {
    "totalAccepted": "115.1K",
    "totalSubmission": "170K",
    "totalAcceptedRaw": 115094,
    "totalSubmissionRaw": 170017,
    "acRate": "67.7%"
  },
  "topicTags": [
    {
      "name": "Array",
      "slug": "array"
    },
    {
      "name": "Dynamic Programming",
      "slug": "dynamic-programming"
    },
    {
      "name": "Stack",
      "slug": "stack"
    },
    {
      "name": "Greedy",
      "slug": "greedy"
    },
    {
      "name": "Monotonic Stack",
      "slug": "monotonic-stack"
    }
  ],
  "metaData": {
    "name": "mctFromLeafValues",
    "params": [
      {
        "name": "arr",
        "type": "integer[]"
      }
    ],
    "return": {
      "type": "integer"
    }
  },
  "discussion_posts": [
    {
      "name": "pthread",
      "year": 2019,
      "content": "DP in all possible BTs from leaf nodes array in order to produce the optimal solution?!?!?\\nYou have got to be kidding me, if this is a medium level problem.",
      "voteCount": 124
    },
    {
      "name": "ry1209",
      "year": 2022,
      "content": "This question should be hard",
      "voteCount": 80
    },
    {
      "name": "ans121097",
      "year": 2020,
      "content": "Since given array is the inorder traversal of tree leaves. Their order won\\'t change. You can only decide which 2 consecutive nodes you wanna combine to make a new node by their product.\\n\\nSuppose array is [8,4,1,2,5] \\nYou can multiply two consecutive digits and their product will be added to resultant sum. And those 2 digits will be replaced my max of them.\\nEx-\\narr=8,4,1,2,5\\nsum-0;\\ni-) multiply 1,2 \\narr = 8,4,2,5 ( because 2>1)\\nand sum=2;\\nii-) multiply 4,2\\narr= 8,4,5 (because 4>2)\\nand sum=2+8=10;\\niii-) multiply 4,5\\narr= 8,5 (because 5>4)\\nand sum= 10+ 20 = 30;\\niv-) multiply 8,5\\nsum=30+40\\n\\nAnswer is 70.\\n\\nNow think how can you solve this :)\\n\\n*Feel free to ask question in comments, do upvote if you understood the intuition*",
      "voteCount": 75
    },
    {
      "name": "james127",
      "year": 2020,
      "content": "weed weed weed",
      "voteCount": 30
    },
    {
      "name": "treat",
      "year": 2023,
      "content": "If anyone is having trouble in understanding DP solution, please google matrix chain multiplication and try to go through it. For beginners, please note this is an advanced topic and can take multiple iterations to understand. So don\\'t get demotivated if it doesn\\'t make sense at first. ",
      "voteCount": 15
    },
    {
      "name": "jimlinntu",
      "year": 2021,
      "content": "These illustrations explain the correctness of the most upvoted greedy approach here.\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space\\n\\n![image](https://assets.leetcode.com/users/images/92c68163-6bde-46fb-ab67-862c7f67b499_1619141168.3640873.png)\\n![image](https://assets.leetcode.com/users/images/458e751e-14cd-4dee-806d-cb36556ea0b8_1619141168.2951288.png)\\n![image](https://assets.leetcode.com/users/images/2b173ab6-054d-4ba4-96ec-988cf8bac681_1619141168.5808558.png)\\n![image](https://assets.leetcode.com/users/images/f1995944-3c2a-4a02-a1d3-f4f92c11d6b8_1619141168.2315059.png)\\n![image](https://assets.leetcode.com/users/images/08847a5e-d9fe-4283-a7a2-917afe069fd1_1619356585.7288036.png)\\n![image](https://assets.leetcode.com/users/images/675e13ab-f6e0-4905-a7a6-3c4999eef6c9_1619356585.4605606.png)\\n\\n",
      "voteCount": 15
    },
    {
      "name": "kawabunga",
      "year": 2019,
      "content": "My algorithm tends to find solutions which are better than what the verification finds. Because of this, my submission is not accepted. Could someone tell me what it is I\\'m getting wrong here?\\n\\nExample input: [ 8,7,10,12]\\nMy output: 256\\nExpected output: 284\\n\\nThis is the tree that I\\'ve built:\\n\\n  \\t\\t  \\t\\t 120\\n\\t     \\t\\t/    \\\\\\n  \\t\\t\\t  80     12\\n\\t  \\t\\t/    \\\\\\n    \\t   56     10\\n   \\t  \\t  / \\\\\\n  \\t\\t 8   7      \\n\\nAs you can see, the non-leaf nodes are: 56+80+120 = 256\\n\\nSo why is the expected output 284? Is the tree above somehow wrong?\\n\\nI have another example with [2,4,7,6,8] ...",
      "voteCount": 10
    },
    {
      "name": "etanila",
      "year": 2024,
      "content": "Don't drop it right after you solved it with DP and got proud of yourself. Check out O(n) greedy solutions and learn something! I sure did.",
      "voteCount": 5
    },
    {
      "name": "random142857",
      "year": 2023,
      "content": "A very simple explanation of why the greedy method works:\n\nEach time we merge two neighbouring numbers, the length of the original array reduces by $1$. Therefore, we need a total of $n - 1$ merge operations, whatever the order is.\n\nThere will always be some numbers that are reused to compute the products.\n\nHence, we just need to find a way to merge the numbers, so that we are never \"wasting\" the small numbers, and never introduce unnecessary reuses of large numbers.\n\nIn what cases can we argue that we are \"wasting\"?\n\nSuppose we are merging some number $a$ by its neighbour. However, if this number $a$ could have been used to merge some other number $b$, where $b < a$, then, merging $a$ in advance will be a waste, and we will be introducing the reuse of some other number that is larger than $a$.\n\nNote that it is possible that $b$ being merged by some number $c$, where $a > c > b$. However, in this case, we can argue that if we merge $a$ in advance, we are wasting because we could have been using $a$ to merge $c$, instead of merging $c$ with some other number that is larger than $a$. We can make assumptions on other possible numbers between $a$ and $c$ here, but by the end of the day, there will exist a number that is smaller than $a$, which could have been merged by $a$ but lost the opportunity because we merged $a$ in advance.\n\nOn the other hand, if such numbers do not exist, then either\n1. merging $a$ first or merging the smallest number first does not matter, as they are both not wasting.\n2. we cannot find the numbers that make merging $a$ be wasting because $a$ is already the smallest number.\n\nHence, there is one way to completely avoid any wasting. If we always greedily merge the smallest number $s$ in the current array, then we know that the smallest number $s$ can never be used to merge any other numbers. Merging $s$ is always a safe move that never causes wastes.",
      "voteCount": 3
    },
    {
      "name": "harsh700ca",
      "year": 2019,
      "content": "I don\\'t find the stack solution intuitive. I think a proof would be helpful. None of the explanations provide a proof.",
      "voteCount": 2
    }
  ]
}
