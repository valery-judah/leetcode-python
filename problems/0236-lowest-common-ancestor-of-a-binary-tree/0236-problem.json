{
  "category": "",
  "id": "236",
  "name": "Lowest Common Ancestor of a Binary Tree",
  "difficulty": "Medium",
  "leetcode_url": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/",
  "slug": "lowest-common-ancestor-of-a-binary-tree",
  "isPaidOnly": false,
  "tags": [
    "Tree",
    "Depth-First Search",
    "Binary Tree"
  ],
  "similar_questions": [
    {
      "title": "Lowest Common Ancestor of a Binary Search Tree",
      "difficulty": "Medium",
      "slug": "lowest-common-ancestor-of-a-binary-search-tree"
    },
    {
      "title": "Smallest Common Region",
      "difficulty": "Medium",
      "slug": "smallest-common-region"
    },
    {
      "title": "Find Players With Zero or One Losses",
      "difficulty": "Medium",
      "slug": "find-players-with-zero-or-one-losses"
    },
    {
      "title": "Lowest Common Ancestor of a Binary Tree II",
      "difficulty": "Medium",
      "slug": "lowest-common-ancestor-of-a-binary-tree-ii"
    },
    {
      "title": "Lowest Common Ancestor of a Binary Tree III",
      "difficulty": "Medium",
      "slug": "lowest-common-ancestor-of-a-binary-tree-iii"
    },
    {
      "title": "Lowest Common Ancestor of a Binary Tree IV",
      "difficulty": "Medium",
      "slug": "lowest-common-ancestor-of-a-binary-tree-iv"
    },
    {
      "title": "Step-By-Step Directions From a Binary Tree Node to Another",
      "difficulty": "Medium",
      "slug": "step-by-step-directions-from-a-binary-tree-node-to-another"
    },
    {
      "title": "Cycle Length Queries in a Tree",
      "difficulty": "Hard",
      "slug": "cycle-length-queries-in-a-tree"
    }
  ],
  "questionId": "236",
  "questionFrontendId": "236",
  "title": "Lowest Common Ancestor of a Binary Tree",
  "titleSlug": "lowest-common-ancestor-of-a-binary-tree",
  "content": "<p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p>\n\n<p>According to the <a href=\"https://en.wikipedia.org/wiki/Lowest_common_ancestor\" target=\"_blank\">definition of LCA on Wikipedia</a>: &ldquo;The lowest common ancestor is defined between two nodes <code>p</code> and <code>q</code> as the lowest node in <code>T</code> that has both <code>p</code> and <code>q</code> as descendants (where we allow <b>a node to be a descendant of itself</b>).&rdquo;</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/14/binarytree.png\" style=\"width: 200px; height: 190px;\" />\n<pre>\n<strong>Input:</strong> root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The LCA of nodes 5 and 1 is 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/14/binarytree.png\" style=\"width: 200px; height: 190px;\" />\n<pre>\n<strong>Input:</strong> root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1,2], p = 1, q = 2\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[2, 10<sup>5</sup>]</code>.</li>\n\t<li><code>-10<sup>9</sup> &lt;= Node.val &lt;= 10<sup>9</sup></code></li>\n\t<li>All <code>Node.val</code> are <strong>unique</strong>.</li>\n\t<li><code>p != q</code></li>\n\t<li><code>p</code> and <code>q</code> will exist in the tree.</li>\n</ul>\n",
  "likes": 18033,
  "dislikes": 481,
  "stats": {
    "totalAccepted": "2.3M",
    "totalSubmission": "3.4M",
    "totalAcceptedRaw": 2300809,
    "totalSubmissionRaw": 3404864,
    "acRate": "67.6%"
  },
  "topicTags": [
    {
      "name": "Tree",
      "slug": "tree"
    },
    {
      "name": "Depth-First Search",
      "slug": "depth-first-search"
    },
    {
      "name": "Binary Tree",
      "slug": "binary-tree"
    }
  ],
  "metaData": {
    "name": "lowestCommonAncestor",
    "params": [
      {
        "name": "root",
        "type": "TreeNode"
      },
      {
        "name": "p",
        "type": "integer"
      },
      {
        "name": "q",
        "type": "integer"
      }
    ],
    "return": {
      "type": "TreeNode"
    },
    "manual": true
  },
  "company_tag_stats": {
    "1": [
      {
        "taggedByAdmin": true,
        "name": "Meta",
        "slug": "facebook",
        "timesEncountered": 114
      },
      {
        "taggedByAdmin": true,
        "name": "Amazon",
        "slug": "amazon",
        "timesEncountered": 33
      }
    ]
  },
  "discussion_posts": [
    {
      "name": "jack76",
      "year": 2016,
      "content": "Note that the problem description said that \" two given nodes in the tree.\" So the parameters `p` and `q` are node references in the tree. \\n\\nUse \\n\\n`if (root == p)` instead of  `if(root.val == p.val)`",
      "voteCount": 293
    },
    {
      "name": "indrasen_007",
      "year": 2024,
      "content": "This question was asked in my Amazon interview",
      "voteCount": 210
    },
    {
      "name": "hiidino",
      "year": 2025,
      "content": "\"Wikipediiaaaa?? You use Wikipedia as your source of information !? tsk tsk tsk tsk tsk\"",
      "voteCount": 60
    },
    {
      "name": "tangwentlw",
      "year": 2023,
      "content": "Test case 31 is broken, even the answer given in the Edirotial won't be able to pass. Please fix it. I am using Python3.",
      "voteCount": 60
    },
    {
      "name": "a_n_i_k_e_t",
      "year": 2025,
      "content": "This is my 300th question!  \\uD83C\\uDF89 ",
      "voteCount": 31
    },
    {
      "name": "LesterX",
      "year": 2023,
      "content": "In interview I was asked what if the nodes might not exist in the tree and my brain was down. I hate myself :(",
      "voteCount": 26
    },
    {
      "name": "kapildalal46",
      "year": 2023,
      "content": "TestCase 31 is broken, getting following error \\n\\njava.lang.NumberFormatException: Cannot parse null string\\n  at line 630, java.base/java.lang.Integer.parseInt\\n  at line 786, java.base/java.lang.Integer.parseInt\\n\\tat __Deserializer__.toInteger(Unknown Source)\\n  at line 97, __Driver__.main\\n\\nTestcase input:\\n4\\n[3,5,1,6,2,0,8,null,null,7,4]\\n",
      "voteCount": 24
    },
    {
      "name": "MaxGu",
      "year": 2023,
      "content": "As of 11/17/2023, test case 31 is broken. It only provides root without p and q.",
      "voteCount": 24
    },
    {
      "name": "sai_manoj_kumar",
      "year": 2019,
      "content": "Input for the testcase is not being parsed correctly. Where do I report this?",
      "voteCount": 14
    },
    {
      "name": "Ankit_rawat_99",
      "year": 2025,
      "content": "\\n\\u2705 Approach (Recursive DFS):\\n\\uD83D\\uDCA1 Idea:\\nTraverse the tree from the root, and for each node, check:\\n\\nIf the current node is one of the target nodes (n1 or n2), return the current node.\\n\\nRecursively search in the left and right subtrees.\\n\\nIf both left and right recursive calls return non-null, the current node is the LCA.\\n\\nIf only one side is non-null, propagate that result upward.",
      "voteCount": 11
    }
  ]
}
