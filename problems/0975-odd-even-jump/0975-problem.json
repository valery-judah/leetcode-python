{
  "category": "",
  "id": "975",
  "name": "Odd Even Jump",
  "difficulty": "Hard",
  "leetcode_url": "https://leetcode.com/problems/odd-even-jump/",
  "slug": "odd-even-jump",
  "isPaidOnly": false,
  "tags": [
    "Array",
    "Dynamic Programming",
    "Stack",
    "Sorting",
    "Monotonic Stack",
    "Ordered Set"
  ],
  "similar_questions": [],
  "questionId": "1017",
  "questionFrontendId": "975",
  "title": "Odd Even Jump",
  "titleSlug": "odd-even-jump",
  "content": "<p>You are given an integer array <code>arr</code>. From some starting index, you can make a series of jumps. The (1<sup>st</sup>, 3<sup>rd</sup>, 5<sup>th</sup>, ...) jumps in the series are called <strong>odd-numbered jumps</strong>, and the (2<sup>nd</sup>, 4<sup>th</sup>, 6<sup>th</sup>, ...) jumps in the series are called <strong>even-numbered jumps</strong>. Note that the <strong>jumps</strong> are numbered, not the indices.</p>\n\n<p>You may jump forward from index <code>i</code> to index <code>j</code> (with <code>i &lt; j</code>) in the following way:</p>\n\n<ul>\n\t<li>During <strong>odd-numbered jumps</strong> (i.e., jumps 1, 3, 5, ...), you jump to the index <code>j</code> such that <code>arr[i] &lt;= arr[j]</code> and <code>arr[j]</code> is the smallest possible value. If there are multiple such indices <code>j</code>, you can only jump to the <strong>smallest</strong> such index <code>j</code>.</li>\n\t<li>During <strong>even-numbered jumps</strong> (i.e., jumps 2, 4, 6, ...), you jump to the index <code>j</code> such that <code>arr[i] &gt;= arr[j]</code> and <code>arr[j]</code> is the largest possible value. If there are multiple such indices <code>j</code>, you can only jump to the <strong>smallest</strong> such index <code>j</code>.</li>\n\t<li>It may be the case that for some index <code>i</code>, there are no legal jumps.</li>\n</ul>\n\n<p>A starting index is <strong>good</strong> if, starting from that index, you can reach the end of the array (index <code>arr.length - 1</code>) by jumping some number of times (possibly 0 or more than once).</p>\n\n<p>Return <em>the number of <strong>good</strong> starting indices</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [10,13,12,14,15]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> \nFrom starting index i = 0, we can make our 1st jump to i = 2 (since arr[2] is the smallest among arr[1], arr[2], arr[3], arr[4] that is greater or equal to arr[0]), then we cannot jump any more.\nFrom starting index i = 1 and i = 2, we can make our 1st jump to i = 3, then we cannot jump any more.\nFrom starting index i = 3, we can make our 1st jump to i = 4, so we have reached the end.\nFrom starting index i = 4, we have reached the end already.\nIn total, there are 2 different starting indices i = 3 and i = 4, where we can reach the end with some number of\njumps.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [2,3,1,1,4]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> \nFrom starting index i = 0, we make jumps to i = 1, i = 2, i = 3:\nDuring our 1st jump (odd-numbered), we first jump to i = 1 because arr[1] is the smallest value in [arr[1], arr[2], arr[3], arr[4]] that is greater than or equal to arr[0].\nDuring our 2nd jump (even-numbered), we jump from i = 1 to i = 2 because arr[2] is the largest value in [arr[2], arr[3], arr[4]] that is less than or equal to arr[1]. arr[3] is also the largest value, but 2 is a smaller index, so we can only jump to i = 2 and not i = 3\nDuring our 3rd jump (odd-numbered), we jump from i = 2 to i = 3 because arr[3] is the smallest value in [arr[3], arr[4]] that is greater than or equal to arr[2].\nWe can&#39;t jump from i = 3 to i = 4, so the starting index i = 0 is not good.\nIn a similar manner, we can deduce that:\nFrom starting index i = 1, we jump to i = 4, so we reach the end.\nFrom starting index i = 2, we jump to i = 3, and then we can&#39;t jump anymore.\nFrom starting index i = 3, we jump to i = 4, so we reach the end.\nFrom starting index i = 4, we are already at the end.\nIn total, there are 3 different starting indices i = 1, i = 3, and i = 4, where we can reach the end with some\nnumber of jumps.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [5,1,3,4,2]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> We can reach the end from starting indices 1, 2, and 4.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= arr[i] &lt; 10<sup>5</sup></code></li>\n</ul>\n",
  "likes": 2090,
  "dislikes": 529,
  "stats": {
    "totalAccepted": "99.1K",
    "totalSubmission": "242.9K",
    "totalAcceptedRaw": 99108,
    "totalSubmissionRaw": 242855,
    "acRate": "40.8%"
  },
  "topicTags": [
    {
      "name": "Array",
      "slug": "array"
    },
    {
      "name": "Dynamic Programming",
      "slug": "dynamic-programming"
    },
    {
      "name": "Stack",
      "slug": "stack"
    },
    {
      "name": "Sorting",
      "slug": "sorting"
    },
    {
      "name": "Monotonic Stack",
      "slug": "monotonic-stack"
    },
    {
      "name": "Ordered Set",
      "slug": "ordered-set"
    }
  ],
  "metaData": {
    "name": "oddEvenJumps",
    "params": [
      {
        "name": "arr",
        "type": "integer[]"
      }
    ],
    "return": {
      "type": "integer"
    }
  },
  "discussion_posts": [
    {
      "name": "pparisot",
      "year": 2021,
      "content": "The question is terribly explained, I can\\'t believe I paid premium for content like this, truly disappointing.",
      "voteCount": 177
    },
    {
      "name": "Nayanexx",
      "year": 2020,
      "content": "Do you have any tips on how to read the problems faster, so that we use the time in the most efficient possible way?",
      "voteCount": 48
    },
    {
      "name": "SigmaCoder106",
      "year": 2023,
      "content": "It might take 45 mins just for clarification of this question in an interview. :)",
      "voteCount": 36
    },
    {
      "name": "ned1m",
      "year": 2020,
      "content": "The key to solving this problem is in understanding the requirements. For anybody struggling like I did to understand this problem, my explanation below may help.\\n\\nYou need to take a jump from each index and if you are able to get to the end of the line (array) from an index, that jump is a good jump.\\nA jump starts with an odd jump and alternates with an even jump until you get to the end of the line or you can no longer take a step.\\n\\nAn odd jump is when you are able to jump to an index ahead of your starting point, such that the value at the index jumped to is greater than or equal to the value of your current position. It also needs to be the minimum of all possible values available.\\ne.g: 3, 1, 2, 7,15,4,9; taking an odd jump at index 0 will land you at index 4. Notice also you can\\'t take any odd jump at index 3.\\n\\nAn even jump is when you are able to jump to a position ahead such that the value at the position you jumped to is less than or equal to the current value. Where there are multiple values, you have to land at the value that is the maximum of all possible values. \\nFor example: 3, 1, 2, 7,15,4,9; If you do an even jump at index 0, you will land at index 2. Notice that you cannot do an even jump from index 1.\\n\\nThe brute force approach is to try jumping from every possible point. To determine the position to jump to, we will have to scan the remaining elements to determine the best position to land. One jump with this approach will cost O(N^2) time complexity. The cost of N jumps will be O(N^3).\\n\\nApproach 2: DP\\nTo improve on this, we need to cache the final results of every jump we take. \\nFor every index we need to cache the outcome of taking both an even jump and odd jump. We will only use the outcome of the odd jump to determine whether we it is a good starting index or not. It will be best and a lot easier if we start from the tail of the array, this way, for every other jump, we will only take one step and check the cache to determine the outcome of taking the next jump from the position we landed.\\nSo the steps are as follows:\\n\\tBase case: both even and odd jumps are possible for the last index; cache these values\\n\\t1. Take an odd jump from an index\\n\\t2. Check the outcome of taking an even jump from where you landed in step 1\\n\\t3. Count this index as a good index if the jump in 1 was possible and even jump from step 2 is also possible.\\nThis algorithm will take O(N^2) time and O(N) space.\\n\\nWe can improve on this by using a tree.\\n",
      "voteCount": 26
    },
    {
      "name": "AlwaysReady",
      "year": 2021,
      "content": "When starting index is  i = 0, we make jumps to i = 1, i = 2, i = 3:\\n**During our 1st jump (odd-numbered), we first jump to i = 1 because arr[1] is the smallest value in [arr[1], arr[2], arr[3], arr[4]] that is greater than or equal to arr[0].**\\n\\narr[1] = 3 and how will it be smallest among [3,1,1,4] ??\\n\\nHow can we jump from i =0 to i=1 ?? As 3 is not the smallest number",
      "voteCount": 21
    },
    {
      "name": "zurendra9",
      "year": 2021,
      "content": "The correct answer should be 7 but the given answer is 6. Let me explain a little further in this one.\\nSo these are the possible jump paths here:\\n1. 5\\n2. 4 -> 5\\n3. 1 -> 4 -> 4 -> 5\\n4. 2 -> 4 -> 4 -> 5\\n5. 3 -> 4 -> 4 -> 5\\n6. 2 -> 3 -> 2 -> 4 -> 4 -> 5\\n7. 1 -> 2 -> 2-> 4 -> 4 -> 5",
      "voteCount": 16
    },
    {
      "name": "droid1",
      "year": 2019,
      "content": "Need a bit of clarification on how the value for [1,2,3,2,1,4,4,5] is 6 and not 4. I found that for this example good starting points are at index 1,4,6 and 7 hence making the count 4 and not 6.",
      "voteCount": 12
    },
    {
      "name": "divjotsr",
      "year": 2022,
      "content": "[1,2,3,2,1,4, 4,5] - \\n 0 1 2 3 4 5 6 7\\nreachable paths(indices are written) - 7, 6->7, 4->5->6->7, 3->5->6->7, 2->5->6->7, 1->2->3->5->6->7, 0->1->3->5->6->7",
      "voteCount": 9
    },
    {
      "name": "eggandlog",
      "year": 2022,
      "content": "Please help me understand this testcase: [1,2,3,2,1,4,4,5] answer: 6\\n\\nWhy would the answer be six and not 7?\\n\\ni = 0, jump to i =1, jump to i = 3, jump to i = 5, i = 6, i = 7\\ni = 1, jump to i =2, jump to i = 3, jump to i = 5, i = 6, i = 7\\ni = 2, i = 5, i = 6, i = 7\\ni = 3, i = 5, i = 6, i = 7\\ni = 4, i = 5, i = 6, i = 7\\nDOES NOT WORK: i = 5, i = 6, i = 7\\ni = 6, i = 7\\ni = 7\\n\\nthat is 7 total indecies that work, wouldn\\'t 7 be the answer? Am I missing something?",
      "voteCount": 8
    },
    {
      "name": "cja",
      "year": 2019,
      "content": "Why doesn\\'t Python collections have a TreeMap like implementation?  I\\'ve always wanted that and looked into various libraries like bintrees, but that is not standard (and not available in leetcode).",
      "voteCount": 6
    }
  ]
}
