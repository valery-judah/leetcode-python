{
  "category": "",
  "id": "207",
  "name": "Course Schedule",
  "difficulty": "Medium",
  "leetcode_url": "https://leetcode.com/problems/course-schedule/",
  "slug": "course-schedule",
  "isPaidOnly": false,
  "tags": [
    "Depth-First Search",
    "Breadth-First Search",
    "Graph",
    "Topological Sort"
  ],
  "similar_questions": [
    {
      "title": "Course Schedule II",
      "difficulty": "Medium",
      "slug": "course-schedule-ii"
    },
    {
      "title": "Graph Valid Tree",
      "difficulty": "Medium",
      "slug": "graph-valid-tree"
    },
    {
      "title": "Minimum Height Trees",
      "difficulty": "Medium",
      "slug": "minimum-height-trees"
    },
    {
      "title": "Course Schedule III",
      "difficulty": "Hard",
      "slug": "course-schedule-iii"
    },
    {
      "title": "Build a Matrix With Conditions",
      "difficulty": "Hard",
      "slug": "build-a-matrix-with-conditions"
    }
  ],
  "questionId": "207",
  "questionFrontendId": "207",
  "title": "Course Schedule",
  "titleSlug": "course-schedule",
  "content": "<p>There are a total of <code>numCourses</code> courses you have to take, labeled from <code>0</code> to <code>numCourses - 1</code>. You are given an array <code>prerequisites</code> where <code>prerequisites[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that you <strong>must</strong> take course <code>b<sub>i</sub></code> first if you want to take course <code>a<sub>i</sub></code>.</p>\n\n<ul>\n\t<li>For example, the pair <code>[0, 1]</code>, indicates that to take course <code>0</code> you have to first take course <code>1</code>.</li>\n</ul>\n\n<p>Return <code>true</code> if you can finish all courses. Otherwise, return <code>false</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> numCourses = 2, prerequisites = [[1,0]]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0. So it is possible.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> numCourses = 2, prerequisites = [[1,0],[0,1]]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= numCourses &lt;= 2000</code></li>\n\t<li><code>0 &lt;= prerequisites.length &lt;= 5000</code></li>\n\t<li><code>prerequisites[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; numCourses</code></li>\n\t<li>All the pairs prerequisites[i] are <strong>unique</strong>.</li>\n</ul>\n",
  "likes": 17416,
  "dislikes": 831,
  "stats": {
    "totalAccepted": "2.2M",
    "totalSubmission": "4.5M",
    "totalAcceptedRaw": 2243559,
    "totalSubmissionRaw": 4499042,
    "acRate": "49.9%"
  },
  "topicTags": [
    {
      "name": "Depth-First Search",
      "slug": "depth-first-search"
    },
    {
      "name": "Breadth-First Search",
      "slug": "breadth-first-search"
    },
    {
      "name": "Graph",
      "slug": "graph"
    },
    {
      "name": "Topological Sort",
      "slug": "topological-sort"
    }
  ],
  "metaData": {
    "name": "canFinish",
    "params": [
      {
        "name": "numCourses",
        "type": "integer"
      },
      {
        "name": "prerequisites",
        "type": "integer[][]"
      }
    ],
    "return": {
      "type": "boolean"
    }
  },
  "company_tag_stats": {
    "1": [
      {
        "taggedByAdmin": false,
        "name": "Amazon",
        "slug": "amazon",
        "timesEncountered": 47
      },
      {
        "taggedByAdmin": false,
        "name": "Meta",
        "slug": "facebook",
        "timesEncountered": 35
      },
      {
        "taggedByAdmin": false,
        "name": "Google",
        "slug": "google",
        "timesEncountered": 11
      }
    ]
  },
  "discussion_posts": [
    {
      "name": "GekkouHayate",
      "year": 2018,
      "content": "It does not make sense. A student can not take so many courses. ",
      "voteCount": 848
    },
    {
      "name": "barnik_b",
      "year": 2023,
      "content": "Please give some more better examples so that we can try to draw the graphs and trace the working. Both the examples provided here are too trivial.",
      "voteCount": 417
    },
    {
      "name": "banty",
      "year": 2022,
      "content": "I had a requirement where I need to execute some actions one after another in an orchestration system. I created a DAG of the actions and used topological sorting to find out which action need to execute next (after an action is completed). This algorithm sits at the core of a very important microservice.",
      "voteCount": 152
    },
    {
      "name": "coding_88",
      "year": 2024,
      "content": "`Some Test Cases That May Help You`\n```\n2 \n[[1,0]]\n2\n[[1,0],[0,1]]\n5\n[[1,4],[2,4],[3,1],[3,2]]\n6\n[[1,0],[1,2],[3,1],[2,3],[2,4],[4,5],[2,5]]\n6\n[[1,0],[1,2],[3,1],[3,2],[2,4],[4,5],[2,5]]\n```",
      "voteCount": 83
    },
    {
      "name": "will5",
      "year": 2015,
      "content": "Using vector of vector should imply a adjacency list/matrix representation of the prereq graph.  If you want to represent the graph simply as a collection of edges, you should use vector<pair<int, int> > instead.  Such ill-formatted input with insufficient specification is time-wasting and should be discouraged in industry, and in interviews.",
      "voteCount": 80
    },
    {
      "name": "rosemelon",
      "year": 2019,
      "content": "I\\'ve read a lot of solutions and did a bunch of Googling but I cannot figure out why it would be better to use topological sort versus simply detecting the cycle. \\n\\nI understand if we detect a cycle, we cannot take all courses because if there is a cycle, we can never take the courses in the cycle and therefore can\\'t take all courses. This solution makes sense to me. \\n\\nI slightly understand how topological sort does this but not really. Is it because the topological sort will not return an ordering of the same length as the nodes in the graph that we are able to figure out this graph has cycles? Is that a use case of topological sort -- to figure out if we have cycles or not? \\n\\nAlso, both algorithms are O(V + E) runtime and O(V) space right?",
      "voteCount": 56
    },
    {
      "name": "IrisLi0205",
      "year": 2021,
      "content": "I returned false for the following test case:\\n5\\n[[1,4],[2,4],[3,1],[3,2]]\\n\\nand the result shows it should be true. Can someboly explain why there are only four courses (1,2,3 and 5) but we need to take 5?",
      "voteCount": 45
    },
    {
      "name": "KyleFu",
      "year": 2019,
      "content": "I think the description does not explicitly explain the situation where a course has multiple prerequisites. It may be interpreted differently.\\n\\tThe course can be taken if:\\n\\t1. ALL the prerequisite courses should be taken;\\n\\t2. EITHER one of the prerequisite course should be taken;\\nThe solution here implicitly take the first assumption, so if there is a circle in the graph, then there is no solution that all course can be taken.\\nBut if the second assumption is required, this problem cannot be solved by checking if there is a circle in the graph. \\nFor example:\\n\\n![image](https://assets.leetcode.com/users/kylefu/image_1554435419.png)\\nCourse 4 has two prerequisites(1 and 3). \\nIf either of them taken counts, then the solution can be: 3->4->2->1.\\nIf both of them should be taken before 4 is taken, there is no solution.\\nIn this case, there is still a circle in the graph, but all courses can be taken.\\n",
      "voteCount": 33
    },
    {
      "name": "AlgoEngine",
      "year": 2023,
      "content": "Visualization of Kahn's Algorithm (Topological Sorting)\n\nhttps://youtu.be/EUDwWbvtB_Q?si=MJEW9OsxIMyWixVd",
      "voteCount": 31
    },
    {
      "name": "anwendeng",
      "year": 2023,
      "content": "Solving the class scheduling problem is exactly the same as solving yesterday\\'s \"802. Find the final safe state\" problem. cheers\\n",
      "voteCount": 20
    }
  ]
}
