{
  "category": "",
  "id": "108",
  "name": "Convert Sorted Array to Binary Search Tree",
  "difficulty": "Easy",
  "leetcode_url": "https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/",
  "slug": "convert-sorted-array-to-binary-search-tree",
  "isPaidOnly": false,
  "tags": [
    "Array",
    "Divide and Conquer",
    "Tree",
    "Binary Search Tree",
    "Binary Tree"
  ],
  "similar_questions": [
    {
      "title": "Convert Sorted List to Binary Search Tree",
      "difficulty": "Medium",
      "slug": "convert-sorted-list-to-binary-search-tree"
    }
  ],
  "questionId": "108",
  "questionFrontendId": "108",
  "title": "Convert Sorted Array to Binary Search Tree",
  "titleSlug": "convert-sorted-array-to-binary-search-tree",
  "content": "<p>Given an integer array <code>nums</code> where the elements are sorted in <strong>ascending order</strong>, convert <em>it to a </em><span data-keyword=\"height-balanced\"><strong><em>height-balanced</em></strong></span> <em>binary search tree</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg\" style=\"width: 302px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> nums = [-10,-3,0,5,9]\n<strong>Output:</strong> [0,-3,9,-10,null,5]\n<strong>Explanation:</strong> [0,-10,5,null,-3,null,9] is also accepted:\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/18/btree2.jpg\" style=\"width: 302px; height: 222px;\" />\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/18/btree.jpg\" style=\"width: 342px; height: 142px;\" />\n<pre>\n<strong>Input:</strong> nums = [1,3]\n<strong>Output:</strong> [3,1]\n<strong>Explanation:</strong> [1,null,3] and [3,1] are both height-balanced BSTs.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>nums</code> is sorted in a <strong>strictly increasing</strong> order.</li>\n</ul>\n",
  "likes": 11622,
  "dislikes": 621,
  "stats": {
    "totalAccepted": "1.6M",
    "totalSubmission": "2.1M",
    "totalAcceptedRaw": 1555231,
    "totalSubmissionRaw": 2087257,
    "acRate": "74.5%"
  },
  "topicTags": [
    {
      "name": "Array",
      "slug": "array"
    },
    {
      "name": "Divide and Conquer",
      "slug": "divide-and-conquer"
    },
    {
      "name": "Tree",
      "slug": "tree"
    },
    {
      "name": "Binary Search Tree",
      "slug": "binary-search-tree"
    },
    {
      "name": "Binary Tree",
      "slug": "binary-tree"
    }
  ],
  "metaData": {
    "name": "sortedArrayToBST",
    "params": [
      {
        "name": "nums",
        "type": "integer[]"
      }
    ],
    "return": {
      "type": "TreeNode",
      "dealloc": true
    }
  },
  "discussion_posts": [
    {
      "name": "namlehoangdev",
      "year": 2023,
      "content": "Hope the picture below can help everyone think of an iterative solution:\n\nHere is how an array: `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]` transform to BST\n![](https://i.imgur.com/p7i22Kx.gif)",
      "voteCount": 768
    },
    {
      "name": "barneh",
      "year": 2023,
      "content": "how is this easy\\n",
      "voteCount": 390
    },
    {
      "name": "ningaloo",
      "year": 2023,
      "content": "this is not an easy wtf",
      "voteCount": 254
    },
    {
      "name": "amitmungare27",
      "year": 2023,
      "content": "To convert a sorted array to a binary search tree, we can use the following recursive algorithm:\\n1) If the array is empty, return null.\\n2) Find the middle element of the array and create a new node with its value.\\n3) Recursively construct the left subtree using the left half of the array.\\n4) Recursively construct the right subtree using the right half of the array.\\n5) Set the left and right child of the node created in step 2 to the root of the left and right subtree respectively.\\n6) Return the root node.",
      "voteCount": 94
    },
    {
      "name": "itsFridayNight",
      "year": 2024,
      "content": "This should be a medium!",
      "voteCount": 79
    },
    {
      "name": "rohhiiiit",
      "year": 2022,
      "content": "Algorithm:\\n*  initialize `start=0` and `end=(length of  array -1)`\\n*  call recursive method : `createTree(nums,start,end)`\\n\\t\\t* if `start>end` `return NULL`\\n\\t\\t* calculate `mid=(start+end)/2`\\n\\t\\t* create `Node(Root)` with `nums[mid]` as value\\n\\t\\t* `node.left = createTree(nums,0,mid-1)`\\n\\t\\t* `node.right = createTree(nums,mid+1,end)`\\n\\t\\t* `return node`   ",
      "voteCount": 63
    },
    {
      "name": "schen175",
      "year": 2024,
      "content": "the examples suck",
      "voteCount": 31
    },
    {
      "name": "sinomiko",
      "year": 2018,
      "content": "Given the sorted array: [-10,-3,0,5,9],\\nOne possible answer is: [0,-3,9,-10,null,5], \\n \\n Run Code Status: Finished\\nRun Code Result:\\nYour input\\n[-10,-3,0,5,9]\\nYour answer\\n[0,-3,9,-10,null,5]\\nExpected answer\\n[0,-10,5,null,-3,null,9]",
      "voteCount": 31
    },
    {
      "name": "stellari",
      "year": 2014,
      "content": "I understand that this problem can be most naturally solved with recursion. However, I wonder if there is an iterative solution that only uses constant space (aside from the space occupied by the input array and the output tree nodes). For now, the only thing I can think of is Morris Traversal, but I wonder if a simpler solution exists for this particular problem. Any suggestion would be appreciated!",
      "voteCount": 20
    },
    {
      "name": "catherinerae",
      "year": 2019,
      "content": "Article explaining how to solve this BST problem with Javascript, drawn with diagrams:\\nhttps://medium.com/confessions-of-a-bootcamp-grad/how-to-solve-leetcodes-convert-sorted-array-to-binary-search-tree-problem-with-javascript-a61e6d6d6c36",
      "voteCount": 16
    }
  ]
}
