{
  "category": "",
  "id": "162",
  "name": "Find Peak Element",
  "difficulty": "Medium",
  "leetcode_url": "https://leetcode.com/problems/find-peak-element/",
  "slug": "find-peak-element",
  "isPaidOnly": false,
  "tags": [
    "Array",
    "Binary Search"
  ],
  "similar_questions": [
    {
      "title": "Peak Index in a Mountain Array",
      "difficulty": "Medium",
      "slug": "peak-index-in-a-mountain-array"
    },
    {
      "title": "Find a Peak Element II",
      "difficulty": "Medium",
      "slug": "find-a-peak-element-ii"
    },
    {
      "title": "Pour Water Between Buckets to Make Water Levels Equal",
      "difficulty": "Medium",
      "slug": "pour-water-between-buckets-to-make-water-levels-equal"
    },
    {
      "title": "Count Hills and Valleys in an Array",
      "difficulty": "Easy",
      "slug": "count-hills-and-valleys-in-an-array"
    },
    {
      "title": "Find the Peaks",
      "difficulty": "Easy",
      "slug": "find-the-peaks"
    }
  ],
  "questionId": "162",
  "questionFrontendId": "162",
  "title": "Find Peak Element",
  "titleSlug": "find-peak-element",
  "content": "<p>A peak element is an element that is strictly greater than its neighbors.</p>\n\n<p>Given a <strong>0-indexed</strong> integer array <code>nums</code>, find a peak element, and return its index. If the array contains multiple peaks, return the index to <strong>any of the peaks</strong>.</p>\n\n<p>You may imagine that <code>nums[-1] = nums[n] = -&infin;</code>. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.</p>\n\n<p>You must write an algorithm that runs in <code>O(log n)</code> time.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,1]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> 3 is a peak element and your function should return the index number 2.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,1,3,5,6,4]\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>nums[i] != nums[i + 1]</code> for all valid <code>i</code>.</li>\n</ul>\n",
  "likes": 13824,
  "dislikes": 4893,
  "stats": {
    "totalAccepted": "2.1M",
    "totalSubmission": "4.5M",
    "totalAcceptedRaw": 2093751,
    "totalSubmissionRaw": 4495471,
    "acRate": "46.6%"
  },
  "topicTags": [
    {
      "name": "Array",
      "slug": "array"
    },
    {
      "name": "Binary Search",
      "slug": "binary-search"
    }
  ],
  "metaData": {
    "name": "findPeakElement",
    "params": [
      {
        "name": "nums",
        "type": "integer[]"
      }
    ],
    "return": {
      "type": "integer"
    }
  },
  "company_tag_stats": {
    "1": [
      {
        "taggedByAdmin": false,
        "name": "Meta",
        "slug": "facebook",
        "timesEncountered": 83
      },
      {
        "taggedByAdmin": false,
        "name": "Amazon",
        "slug": "amazon",
        "timesEncountered": 16
      },
      {
        "taggedByAdmin": false,
        "name": "Bloomberg",
        "slug": "bloomberg",
        "timesEncountered": 12
      },
      {
        "taggedByAdmin": true,
        "name": "Google",
        "slug": "google",
        "timesEncountered": 11
      }
    ]
  },
  "discussion_posts": [
    {
      "name": "amoicity",
      "year": 2018,
      "content": "When people see ths question, I think most people will immediately come up with the linear search solution, which is to examine each num and compare it with its two neighbours. No braniner, right? Then people are thinking why this kind of question would  appear in the question pool and why it\\'s even rated as Medium. Then they might go to the Solution tab and see someone writing up a big article explaining a better solution and probably think, why bother? That\\'s an overkill. \\n\\nThese types of questions are so undervalued by people. And these are the questions we should pay more attention to. I\\'m sure in a real question, the interviewer will not be satisfied by the linear solution. Why? Because the straightforward linear scan solution isn\\'t using all of the clues given in the question. These clues, including\\n1. No adjacent two numbers are the same\\n2. the two end of the arrays are -\\u221E\\n3. You can return any peak.\\n\\nare all the clues that we can base upon to get to the final BS solution. When you are reading a question, pay great attention to these clues. If your solution does not involve all of the clue provided, you might not get the optimal solution. This is not any random question, it\\'s asked by Facebook, Google, etc., for multiple times. There is a reason why it exist and please don\\'t downvote it without even attempting to understand it.",
      "voteCount": 1947
    },
    {
      "name": "VaishnaviSrivastava",
      "year": 2023,
      "content": "What a beautiful problem! <3\\nAnybody\\'s first instinct would be to simply iterate through the array and compare the element with the ones before and after it. log(n). Easy Peasy!\\n\\nOr, you could simply find the global maximum. That would be the local maximum as well. O(n) again. \\n\\nNow, here comes the stepping up part. This problem asks us to think about an O(log(n)) solution. What is the first thing that comes to mind then ? Binary Search! But this isn\\'t a sorted array. Then how can binary search be used here ? \\n\\nSee, binary search has two important aspects. \\n1. A sorted array.\\n2. Splitting an array into two halves.\\n\\nWe do not have the first one here. Let us think about the second point.\\n\\nThis requires a little brainstroming. \\n\\nIf the mid element is the local maximum. Cool! Return.\\n\\nBut if it isn\\'t, and no two adjacent elements are equal, then either of the elements (or maybe both of them) will be greater than our mid element.\\n\\nNow whichever side has the greater element, we can go to that side and continue the same process.\\n\\nWhy, you ask ?\\n\\nLet us say, the element at [mid+1] is greater.\\n\\nIf you are convinced that any array with the given properties will definitely have a local maximum, then the right array will behave exactly like the initial array. Both extremes have numbers smaller than the edge numbers - the right end is already given in the question, and the left end has just been checked by you. That means we can certainly find a local maximum in the right array. \\n\\nCan we find it in the left array as well ? Of course! There are chances. But we do not need to find each local maximum. So we can safely continue with the right side.\\n\\nLook at this picture :\\n![397107eb-88ce-4c4a-8ed9-14157285e690.jpg](https://assets.leetcode.com/users/images/06e0f515-941a-4661-a39a-7aa60e4e74ef_1701721839.4614658.jpeg)\\n\\nA is the current mid, and the right element is greater. Then the right array can have the 4 possibilities. In any case, you will always find a local maximum! Voila!\\n\\n*PS.:A similar thing can be done in the left array as well, if the left element is greater. Even if both sides are greater, you can safely pick any one - it will surely have a local maximum.*",
      "voteCount": 586
    },
    {
      "name": "sridharchaildn",
      "year": 2021,
      "content": "The question doesn\\'t say the array is sorted, how do we know to use binary search ?",
      "voteCount": 207
    },
    {
      "name": "lavishmalik",
      "year": 2022,
      "content": "In both the questions you have to find peak elements but the catch is:\\n\\n-In leetcode 852 the array is increasingly and decreasingly sorted i.e its a bitonic array so you can apply modified binary search and find the global peak easily.\\n\\n-In this question(162), the given array is not sorted so they have given that there will be many peak elements and you can find any peak using binary search and return it .\\nBut you can\\'t find global peak in this question  just by applying binary search like previous question(852) because array is unsorted therefore after finding mid you can\\'t decide which side to go  for finding global peak.\\n\\n//Pls upvote if you like my solution\\n",
      "voteCount": 109
    },
    {
      "name": "heejincs",
      "year": 2018,
      "content": "We can do simple binary search that check [mid] point and [mid+1] point and take half which has higher value, i.e. take left half if nums[mid]>nums[mid+1].\\nIt is not easy to show or proof why this works. \\nThe simple proof is that we take part of numbers that boundary condition holds true.\\nThat is, we only take search range (l, r) if nums[l-1]<nums[l] and num[r]>num[r+1]. Note that initial search range (l,r) where l=0 and r=len(nums)-1 holds true. Then, each step we reduce the search range half making sure the boundary condition holds true. Note that the other half the condition does not hold true.\\nTherefore, when it finally is reduced to a single number, it is the local maximum since the boundary condition for a single number is same as the condition for local maximum.\\n\\n",
      "voteCount": 62
    },
    {
      "name": "juciy_eggplant",
      "year": 2020,
      "content": "We know that for all i, nums[i] != nums[i+1] and nums[-1] == nums[n] == -INF. From these conditions, we can prove that there must exist such an i that is peak, nums[i] > nums[i-1] and nums[i] > nums[i+1]:\\nSuppose there is no  i such that nums[i] > nums[i-1] and nums[i] > nums[i+1], then there are two cases:\\n1. if nums[i] > nums[i-1], it implies nums[i] < nums[i+1] for all i. however, this contradicts nums[n] == -INF\\n2. if nums[i] > nums[i+1], it implies nums[i] < nums[i-1] for all i which contradicts nums[-1] == -INF\\nQED\\n\\nNow we know that there must exist a peak i, we can derive the algorithm\\n1. if nums[m] < nums[m+1], then we know the right half is also an array where for all i, nums[i] != nums[i+1] and nums[-1] == nums[n] == -INF (or to be more precise any x such that x < nums[i_0] && x < nums[i_n-1] and we know there must exist a peak\\n2. if nums[m] > nums[m+1], same logic applies for the left half",
      "voteCount": 58
    },
    {
      "name": "brianSalk",
      "year": 2022,
      "content": "In the comments section I see a lot of people saying that they do not know how they could come up with the binary search solution on their own in a short amount of time like the time that is allowed during an interview.\\n\\nFirst of all, you should be familiar with binary search, for it is a very common algorithm that can be modified to solve many problems that involve searching.\\nSecond, the question says that your algorithm must run in O(logN), which means that linear scan is out of the question.\\nIf you ever have a problem that involves searching for some element in a list in O(logN) time, you are probably limited to some variation of binary search as your only choice.  \\n\\n",
      "voteCount": 29
    },
    {
      "name": "tourist44",
      "year": 2020,
      "content": "It should say that peak element is an elemet which is greater than or equals to its neighbours and not strictly greater than its neighbours.\\nThats when this outcome would be correct.\\n![image](https://assets.leetcode.com/users/images/3e017fa3-9f28-4ac9-87b7-e3b0da7817f1_1600229691.3791375.png)\\n",
      "voteCount": 23
    },
    {
      "name": "liyiou",
      "year": 2014,
      "content": "\\nThe problem should state that there is only one peak in the sequence. Otherwise logarithmic complexity is not possible.\\n\\nFor example:\\n[1,2,1,3,4,5,0] has two peaks: 2 and 5. In such case, the search is O(n).",
      "voteCount": 17
    },
    {
      "name": "zeddysoft",
      "year": 2018,
      "content": "Hello folks,\\n\\nCan anyone here enlighten me on the significance of a question that has more downvote than upvotes. more specifically, should this type of question be avoided?\\n",
      "voteCount": 15
    }
  ]
}
