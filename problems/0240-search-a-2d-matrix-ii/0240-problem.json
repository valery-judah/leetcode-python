{
  "category": "",
  "id": "240",
  "name": "Search a 2D Matrix II",
  "difficulty": "Medium",
  "leetcode_url": "https://leetcode.com/problems/search-a-2d-matrix-ii/",
  "slug": "search-a-2d-matrix-ii",
  "isPaidOnly": false,
  "tags": [
    "Array",
    "Binary Search",
    "Divide and Conquer",
    "Matrix"
  ],
  "similar_questions": [
    {
      "title": "Search a 2D Matrix",
      "difficulty": "Medium",
      "slug": "search-a-2d-matrix"
    }
  ],
  "questionId": "240",
  "questionFrontendId": "240",
  "title": "Search a 2D Matrix II",
  "titleSlug": "search-a-2d-matrix-ii",
  "content": "<p>Write an efficient algorithm that searches for a value <code>target</code> in an <code>m x n</code> integer matrix <code>matrix</code>. This matrix has the following properties:</p>\n\n<ul>\n\t<li>Integers in each row are sorted in ascending from left to right.</li>\n\t<li>Integers in each column are sorted in ascending from top to bottom.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/24/searchgrid2.jpg\" style=\"width: 300px; height: 300px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/24/searchgrid.jpg\" style=\"width: 300px; height: 300px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 &lt;= n, m &lt;= 300</code></li>\n\t<li><code>-10<sup>9</sup> &lt;= matrix[i][j] &lt;= 10<sup>9</sup></code></li>\n\t<li>All the integers in each row are <strong>sorted</strong> in ascending order.</li>\n\t<li>All the integers in each column are <strong>sorted</strong> in ascending order.</li>\n\t<li><code>-10<sup>9</sup> &lt;= target &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
  "likes": 12739,
  "dislikes": 223,
  "stats": {
    "totalAccepted": "1.2M",
    "totalSubmission": "2.2M",
    "totalAcceptedRaw": 1224651,
    "totalSubmissionRaw": 2191034,
    "acRate": "55.9%"
  },
  "topicTags": [
    {
      "name": "Array",
      "slug": "array"
    },
    {
      "name": "Binary Search",
      "slug": "binary-search"
    },
    {
      "name": "Divide and Conquer",
      "slug": "divide-and-conquer"
    },
    {
      "name": "Matrix",
      "slug": "matrix"
    }
  ],
  "metaData": {
    "name": "searchMatrix",
    "params": [
      {
        "name": "matrix",
        "type": "integer[][]"
      },
      {
        "name": "target",
        "type": "integer"
      }
    ],
    "return": {
      "type": "boolean"
    },
    "manual": true
  },
  "discussion_posts": [
    {
      "name": "Batraaaaaa",
      "year": 2023,
      "content": "O(m+n) Approach:\n\n1. Start at the top-right corner of the matrix (i.e., the element in the first row and last column). We will call this element current.\n2. Compare current with the target value target. If current is equal to target, return true since we have found the target in the matrix.\n3. If current is greater than target, we can eliminate the entire last column (i.e., all elements in the last column are greater than current and therefore greater than target). Move one column to the left to consider the next element in that row. We will call this new element current.\n4. If current is less than target, we can eliminate the entire first row (i.e., all elements in the first row are less than current and therefore less than target). Move one row down to consider the next element in that column. We will call this new element current.\n5. Repeat steps 2-4 until current is equal to target or we reach the end of the matrix.\n6. If we reach the end of the matrix without finding the target, return false.\n\nThe idea behind this algorithm is to take advantage of the sorted property of the matrix to eliminate entire rows or columns at once, and narrow down the search space for the target value. Since we start at the top-right corner, we can eliminate rows or columns as we move left or down, respectively.\n\nThe time complexity of this algorithm is O(m + n) since we move at most m + n steps in the matrix. This is much more efficient than a naive approach of iterating over every element in the matrix, which would take O(m x n) time.\n\nKindly Upvote \u2764\ufe0f",
      "voteCount": 287
    },
    {
      "name": "autekwing",
      "year": 2015,
      "content": "Is there's a O(log(m)+log(n)) solution?",
      "voteCount": 61
    },
    {
      "name": "Bodhisattva",
      "year": 2021,
      "content": "Intuition behind the problem:\\n1. It is given that rows and columns are sorted. So the optimal way should involved binary search / complexity can be optimized to logarithmic.\\n2. In any search problem, the basic motive is to reduce the decision space progressively. The more aggressively the search space is reduced, the more efficient the algorithm. \\nTo reduce decision space means to eliminate certain portion completely from search in future. Here, due to the property of rows & columns being sorted, we can verify that we can utilise the given properties to reduce search space only if we begin at bottom left corner or top right corner. This is because at only those two starting positions, we would be able to exercise decisions to reduce our decision/search space in both directions i.e.\\ni. if we start at bottom left corner => we can go right to get elements in increasing order & top to get elements in decreasing order.\\nii. if we start at top right corner => we can go left to get elements in decreasing order & bottom to get elements in increasing order.\\nWe can\\'t have both choices if we start at top left or bottom right indices.",
      "voteCount": 56
    },
    {
      "name": "sonivinayak716",
      "year": 2023,
      "content": " At first we got confidence to run both the cases,whe submitted......RUntime error ,upvote if can relate ;)\\n",
      "voteCount": 37
    },
    {
      "name": "nobugplease",
      "year": 2015,
      "content": "brute force: O(mn) \\n\\nbinary search: O(mlogn) or O(nlogm)\\n\\nsearch from upper right to lower left: O(m+n)\\n\\nSo any hints on using \"divide and conquer\" to solve this problem?\\n\\nThanks",
      "voteCount": 34
    },
    {
      "name": "Jitendrayt",
      "year": 2020,
      "content": "I just solved **Search a 2D Matrix** and then LC suggested me **Search a 2D Matrix ll** and it looked very similar to previous one so i copy pasted my solution and guess what it worked . just wondering if there\\'s even any difference between the 2 problems.\\n\\nlink for Search a 2D Matrix  is - https://leetcode.com/problems/search-a-2d-matrix/",
      "voteCount": 17
    },
    {
      "name": "Stephen4166",
      "year": 2021,
      "content": "I found this awesome explaination from StackExchange https://cs.stackexchange.com/questions/98575/proving-correctness-of-search-algorithms and wanna share with you: \\n\\nThe idea of the algorithm is to maintain the following invariant:\\n\\nIf x is in the matrix, then it is in the submatrix whose top right corner is e.\\n\\nThe invariant clearly holds in the beginning, since e is the top right corner of the original matrix.\\n\\nIf e>x then all elements below e are also larger than x, and so x cannot be contained in that column. Therefore the invariant continues to hold with e replaced with its left neighbor (if e has no left neightbor, we can deduce that x is not found in the matrix).\\n\\nIf e<x then all elements to the left of e are also smaller than x, and so x cannot be contained in that row. Therefore the invariant continues to hold with e replaced with its neighbor below (if any).\\n\\nOn an n\\xD7m matrix, this process terminates in at most n+m steps, either finding x or determining that it does not appear in the matrix.",
      "voteCount": 14
    },
    {
      "name": "Girinath03",
      "year": 2024,
      "content": "In java Normal brute Force approch runs 12ms and it runs very well \\uD83D\\uDE10 But in c++ it gives run time error and runs neraly 2567ms\\uD83D\\uDE30 Why ??",
      "voteCount": 10
    },
    {
      "name": "liuyuhong",
      "year": 2019,
      "content": "Even my code is empty....",
      "voteCount": 9
    },
    {
      "name": "ganesh227",
      "year": 2022,
      "content": "The[ article](https://medium.com/interviewnoodle/search-a-sorted-matrix-both-rows-and-columns-are-sorted-coding-interview-searching-6ba2cea8ed61) contains code, explanation and animations to simplify the approach.",
      "voteCount": 6
    }
  ]
}
