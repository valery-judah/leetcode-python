{
  "category": "",
  "id": "153",
  "name": "Find Minimum in Rotated Sorted Array",
  "difficulty": "Medium",
  "leetcode_url": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/",
  "slug": "find-minimum-in-rotated-sorted-array",
  "isPaidOnly": false,
  "tags": [
    "Array",
    "Binary Search"
  ],
  "similar_questions": [
    {
      "title": "Search in Rotated Sorted Array",
      "difficulty": "Medium",
      "slug": "search-in-rotated-sorted-array"
    },
    {
      "title": "Find Minimum in Rotated Sorted Array II",
      "difficulty": "Hard",
      "slug": "find-minimum-in-rotated-sorted-array-ii"
    }
  ],
  "questionId": "153",
  "questionFrontendId": "153",
  "title": "Find Minimum in Rotated Sorted Array",
  "titleSlug": "find-minimum-in-rotated-sorted-array",
  "content": "<p>Suppose an array of length <code>n</code> sorted in ascending order is <strong>rotated</strong> between <code>1</code> and <code>n</code> times. For example, the array <code>nums = [0,1,2,4,5,6,7]</code> might become:</p>\n\n<ul>\n\t<li><code>[4,5,6,7,0,1,2]</code> if it was rotated <code>4</code> times.</li>\n\t<li><code>[0,1,2,4,5,6,7]</code> if it was rotated <code>7</code> times.</li>\n</ul>\n\n<p>Notice that <strong>rotating</strong> an array <code>[a[0], a[1], a[2], ..., a[n-1]]</code> 1 time results in the array <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code>.</p>\n\n<p>Given the sorted rotated array <code>nums</code> of <strong>unique</strong> elements, return <em>the minimum element of this array</em>.</p>\n\n<p>You must write an algorithm that runs in&nbsp;<code>O(log n) time</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,4,5,1,2]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The original array was [1,2,3,4,5] rotated 3 times.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [4,5,6,7,0,1,2]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [11,13,15,17]\n<strong>Output:</strong> 11\n<strong>Explanation:</strong> The original array was [11,13,15,17] and it was rotated 4 times. \n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 5000</code></li>\n\t<li><code>-5000 &lt;= nums[i] &lt;= 5000</code></li>\n\t<li>All the integers of <code>nums</code> are <strong>unique</strong>.</li>\n\t<li><code>nums</code> is sorted and rotated between <code>1</code> and <code>n</code> times.</li>\n</ul>\n",
  "likes": 14587,
  "dislikes": 636,
  "stats": {
    "totalAccepted": "2.6M",
    "totalSubmission": "4.9M",
    "totalAcceptedRaw": 2617918,
    "totalSubmissionRaw": 4930523,
    "acRate": "53.1%"
  },
  "topicTags": [
    {
      "name": "Array",
      "slug": "array"
    },
    {
      "name": "Binary Search",
      "slug": "binary-search"
    }
  ],
  "metaData": {
    "name": "findMin",
    "params": [
      {
        "name": "nums",
        "type": "integer[]"
      }
    ],
    "return": {
      "type": "integer"
    }
  },
  "discussion_posts": [
    {
      "name": "georgezakharov",
      "year": 2023,
      "content": "Please, do not post answers in discussions.\\nPeople try to find tips here, not spoilers.",
      "voteCount": 299
    },
    {
      "name": "punit_gautam",
      "year": 2021,
      "content": "return min(nums)",
      "voteCount": 274
    },
    {
      "name": "prathmesh_24",
      "year": 2023,
      "content": "How many of you confuse at writing conditions for binary search? \\nwhen to take <  and when to take <= .",
      "voteCount": 207
    },
    {
      "name": "gsahu07",
      "year": 2023,
      "content": "Solved my 50th medium today. Yay!\\n#smallwins",
      "voteCount": 174
    },
    {
      "name": "inomag",
      "year": 2021,
      "content": "The main idea is, the element is said to be minimum in the rotated sorted array if the previous element to it is greater than it or there is no previous element(i.e. no rotation). We can do this using Binary search\\n1. Find the mid element i.e. mid = (low+high)/2\\n2. If the (mid+1)th element is less than mid element then return (mid+1)th element\\n3. If the mid element is less than (mid-1)th element then return the mid element\\n4. If the last element is greater than mid element then search in left half\\n5. If the last element is less than mid element then search in right half\\n\\n**Time Complexity: O(logn)**\\n**Space Complexity: O(1)**\\n\\n*Solution is in the comments.*\\n\\n",
      "voteCount": 171
    },
    {
      "name": "cagils",
      "year": 2023,
      "content": "We only need to compare mid with right one in the binary search. This will automatically handle the edge case of already sorted array.\\n\\n```\\n4 5 6 7 8 9 0 1 2 3\\nl       m         r\\nm > r => l = m + 1\\n4 5 6 7 8 9 0 1 2 3\\n          l   m   r\\nm < r => r = m\\n4 5 6 7 8 9 0 1 2 3\\n          l m r\\nm < r => r = m\\n4 5 6 7 8 9 0 1 2 3\\n          l r\\nm > r => l = m + 1\\n7 8 0 1 2 3 4 5 6\\n            lr\\nr >= l => return l\\n\\n7 8 0 1 2 3 4 5 6\\nl       m       r\\nm < r => r = m\\n7 8 0 1 2 3 4 5 6\\nl m     m\\nm > r => l = m + 1\\n7 8 0 1 2 3 4 5 6\\n    l m r\\nm < l => r = m\\n7 8 0 1 2 3 4 5 6\\n    l r\\nm < r => r = m\\n7 8 0 1 2 3 4 5 6\\n    lr\\nr >= l => return l\\n\\n8 0 1 2 3 4 5 6 7\\nl       m       r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl   m   r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl m r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl r\\nm > r => l = m + 1\\n8 0 1 2 3 4 5 6 7\\n  lr\\nr >=l => return l\\n\\n0 1 2 3 4\\nl   m   r\\nm < r => r = m\\n0 1 2 3 4\\nl m r\\nm < r => r = m\\n0 1 2 3 4\\nl r\\nm < r => r = m\\n0 1 2 3 4\\nlr\\nr >= l => return l\\n```",
      "voteCount": 80
    },
    {
      "name": "meetalik8",
      "year": 2024,
      "content": "I was able to solve this question on my own without any help!! Just celebrating!",
      "voteCount": 66
    },
    {
      "name": "PARANOID_XD",
      "year": 2024,
      "content": "TESTCASES--------->\\n\\n[3,4,5,1,2]\\n[4,5,6,7,0,1,2]\\n[11,13,15,17]\\n[4, 5, 6, 7, 8, 9, 0, 1, 2, 3]\\n[5,1,2,3,4]\\n[4,5,6,1,2,3]\\n[4,5,1,2,3]",
      "voteCount": 35
    },
    {
      "name": "adeebahmed3337",
      "year": 2023,
      "content": "Use Binary Search Instead of sorting the array and returning nums[0] as sorting takes O(nlogn) where as Binary Search takes O(logn).",
      "voteCount": 21
    },
    {
      "name": "faux_hubris",
      "year": 2022,
      "content": "Use Binary Search to find the largest element i.e. the pivot. The element in the array after the pivot i.e. nums[pivot + 1] is your answer. If mums[nums.Length] > nums[0], then you know it can be considered as a sorted array without rotation. In that case, simply return nums[0].",
      "voteCount": 21
    }
  ]
}
