{
  "category": "",
  "id": "97",
  "name": "Interleaving String",
  "difficulty": "Medium",
  "leetcode_url": "https://leetcode.com/problems/interleaving-string/",
  "slug": "interleaving-string",
  "isPaidOnly": false,
  "tags": [
    "String",
    "Dynamic Programming"
  ],
  "similar_questions": [],
  "questionId": "97",
  "questionFrontendId": "97",
  "title": "Interleaving String",
  "titleSlug": "interleaving-string",
  "content": "<p>Given strings <code>s1</code>, <code>s2</code>, and <code>s3</code>, find whether <code>s3</code> is formed by an <strong>interleaving</strong> of <code>s1</code> and <code>s2</code>.</p>\n\n<p>An <strong>interleaving</strong> of two strings <code>s</code> and <code>t</code> is a configuration where <code>s</code> and <code>t</code> are divided into <code>n</code> and <code>m</code> <span data-keyword=\"substring-nonempty\">substrings</span> respectively, such that:</p>\n\n<ul>\n\t<li><code>s = s<sub>1</sub> + s<sub>2</sub> + ... + s<sub>n</sub></code></li>\n\t<li><code>t = t<sub>1</sub> + t<sub>2</sub> + ... + t<sub>m</sub></code></li>\n\t<li><code>|n - m| &lt;= 1</code></li>\n\t<li>The <strong>interleaving</strong> is <code>s<sub>1</sub> + t<sub>1</sub> + s<sub>2</sub> + t<sub>2</sub> + s<sub>3</sub> + t<sub>3</sub> + ...</code> or <code>t<sub>1</sub> + s<sub>1</sub> + t<sub>2</sub> + s<sub>2</sub> + t<sub>3</sub> + s<sub>3</sub> + ...</code></li>\n</ul>\n\n<p><strong>Note:</strong> <code>a + b</code> is the concatenation of strings <code>a</code> and <code>b</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/02/interleave.jpg\" style=\"width: 561px; height: 203px;\" />\n<pre>\n<strong>Input:</strong> s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbcbcac&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> One way to obtain s3 is:\nSplit s1 into s1 = &quot;aa&quot; + &quot;bc&quot; + &quot;c&quot;, and s2 into s2 = &quot;dbbc&quot; + &quot;a&quot;.\nInterleaving the two splits, we get &quot;aa&quot; + &quot;dbbc&quot; + &quot;bc&quot; + &quot;a&quot; + &quot;c&quot; = &quot;aadbbcbcac&quot;.\nSince s3 can be obtained by interleaving s1 and s2, we return true.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbbaccc&quot;\n<strong>Output:</strong> false\n<strong>Explanation:</strong> Notice how it is impossible to interleave s2 with any other string to obtain s3.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s1 = &quot;&quot;, s2 = &quot;&quot;, s3 = &quot;&quot;\n<strong>Output:</strong> true\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s1.length, s2.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= s3.length &lt;= 200</code></li>\n\t<li><code>s1</code>, <code>s2</code>, and <code>s3</code> consist of lowercase English letters.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you solve it using only <code>O(s2.length)</code> additional memory space?</p>\n",
  "likes": 8643,
  "dislikes": 541,
  "stats": {
    "totalAccepted": "694.3K",
    "totalSubmission": "1.6M",
    "totalAcceptedRaw": 694337,
    "totalSubmissionRaw": 1628909,
    "acRate": "42.6%"
  },
  "topicTags": [
    {
      "name": "String",
      "slug": "string"
    },
    {
      "name": "Dynamic Programming",
      "slug": "dynamic-programming"
    }
  ],
  "metaData": {
    "name": "isInterleave",
    "params": [
      {
        "name": "s1",
        "type": "string"
      },
      {
        "name": "s2",
        "type": "string"
      },
      {
        "name": "s3",
        "type": "string"
      }
    ],
    "return": {
      "type": "boolean"
    }
  },
  "discussion_posts": [
    {
      "name": "ALS_Venky",
      "year": 2023,
      "content": "whenever i see leaving, it reminds me of her :(",
      "voteCount": 391
    },
    {
      "name": "sandeshnep",
      "year": 2022,
      "content": "I CAN\\'T BELIEVE I SOLVED THIS ONE BY MY SELF :OOOOOOOOOO",
      "voteCount": 204
    },
    {
      "name": "roshitkhare",
      "year": 2022,
      "content": "So you need to ask yourself ..why is dp used here?\\n In first look this questions looks pretty simple and can be done using 2 pointers. \\n \\n Then you implement the 2 pointer approach and upon submission your code get a wrong ans on the below testcase.\\n \\n This test case then tells you why this que is asking for a dp solution.\\n \\n s1 = \"aabc\"\\n s2 = \"abad\"\\n s3= \"aabadabc\"\\n \\n Now in this, if you start moving from the back using the 2 pointer approach, it keeps on eleminating the character from the 1st string i.e s1. But when s1 gets exhausted, your s3 does not match with s2. \\n Here you take a note that, when char at s1 and s2 are equal, we need to check if deleting the char from s1 is a correct move or deleting the char from s2 would be a correct move.\\n \\n That clearly means, we have 2 choices here, either to delete the char from s1 or s2.\\n \\n Now for a bigger testcase like this it is clearly evidant that the que is asking for a Dyanmic Programming solution!!\\n \\n s1 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s2 = \"aaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s3 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\\t\\t aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n",
      "voteCount": 194
    },
    {
      "name": "nekoshika",
      "year": 2022,
      "content": "You might be tempted to use i, j and k to keep track of s1, s2 and s3 respectively in your recursive calls but it gave me TLE. (Please note that it is not wrong)\\nThe trick here was to remove k from your changing state and reduce dp from 3D to 2D.\\nYou may reason about it by manipulating what you think of i and j at each point and it may work for you but I would like to point out how I reason it. \\nThe thing here is, at every step k is nothing but i+j, so we dont need to keep track of k because we can get it from i and j.",
      "voteCount": 59
    },
    {
      "name": "Hemant_kr03",
      "year": 2023,
      "content": "*This problem is quite challenging.*\n**Here is a tip to overcome this challenge**\nThis problem involves finding whether a target string s3 can be formed by interleaving two given strings s1 and s2. An important observation is that the relative order of characters within each string needs to be maintained in the interleaved result.\n\nHere's a high-level approach to consider:\n\n**Dynamic Programming:** Consider using a dynamic programming approach. Create a 2D DP table where dp[i][j] represents whether the first i characters of s1 and the first j characters of s2 can form the first i+j characters of s3.\n\n**Base Cases:** Initialize the DP table with base cases. For example, dp[0][0] should be true, as both empty strings can form an empty string.\n\n**Recurrence Relation:** Build the DP table bottom-up using a recurrence relation. You can consider the following cases:\n\nIf the current character in s3 matches the current character in s1, you can check if the previous characters in s1 and s3 match and update dp[i][j] accordingly.\nSimilarly, if the current character in s3 matches the current character in s2, you can check if the previous characters in s2 and s3 match and update dp[i][j] accordingly.\nFinal Result: After filling the DP table, the value of dp[s1.length()][s2.length()] will indicate whether s3 can be formed by interleaving s1 and s2.\n\nRemember to handle the edge cases and index mapping properly while implementing the DP solution.\n\nGood luck! Dynamic programming can be powerful for such sequence-related problems.  ",
      "voteCount": 51
    },
    {
      "name": "sanket54",
      "year": 2021,
      "content": "What is meaning of |n-m| <= 1 and why it is being ignored in all solutions ?",
      "voteCount": 48
    },
    {
      "name": "shiva_San",
      "year": 2023,
      "content": "be ready for this testcase if you are using two pointer method without dp..\n\ns1 =\n\"aabc\"\ns2 =\n\"abad\"\ns3 =\n\"aabadabc\"\n\noutput=true\n",
      "voteCount": 34
    },
    {
      "name": "zeeshan251",
      "year": 2023,
      "content": "Did I just solve this on my own \\uD83D\\uDE2D",
      "voteCount": 31
    },
    {
      "name": "xfffrank",
      "year": 2023,
      "content": "Did someone find this one a lot more difficult than other DP problems like \"63. Unique Paths II\\n\"...",
      "voteCount": 31
    },
    {
      "name": "xiahualiu",
      "year": 2024,
      "content": "Imagine you are a robot starting at `(0,0)` in a 2D matrix, where each row represents the current index for `s1`, and each column represents the current index for `s2`.\n\nYou can only move right and down; your mission is to find whether you can reach the corner `[m][n]`.\n\nDoes it sound familiar?",
      "voteCount": 18
    }
  ]
}
