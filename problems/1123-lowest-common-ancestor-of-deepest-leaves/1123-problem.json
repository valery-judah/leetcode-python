{
  "category": "",
  "id": "1123",
  "name": "Lowest Common Ancestor of Deepest Leaves",
  "difficulty": "Medium",
  "leetcode_url": "https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/",
  "slug": "lowest-common-ancestor-of-deepest-leaves",
  "isPaidOnly": false,
  "tags": [
    "Hash Table",
    "Tree",
    "Depth-First Search",
    "Breadth-First Search",
    "Binary Tree"
  ],
  "similar_questions": [
    {
      "title": "Lowest Common Ancestor of a Binary Tree IV",
      "difficulty": "Medium",
      "slug": "lowest-common-ancestor-of-a-binary-tree-iv"
    }
  ],
  "questionId": "1218",
  "questionFrontendId": "1123",
  "title": "Lowest Common Ancestor of Deepest Leaves",
  "titleSlug": "lowest-common-ancestor-of-deepest-leaves",
  "content": "<p>Given the <code>root</code> of a binary tree, return <em>the lowest common ancestor of its deepest leaves</em>.</p>\n\n<p>Recall that:</p>\n\n<ul>\n\t<li>The node of a binary tree is a leaf if and only if it has no children</li>\n\t<li>The depth of the root of the tree is <code>0</code>. if the depth of a node is <code>d</code>, the depth of each of its children is <code>d + 1</code>.</li>\n\t<li>The lowest common ancestor of a set <code>S</code> of nodes, is the node <code>A</code> with the largest depth such that every node in <code>S</code> is in the subtree with root <code>A</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/01/sketch1.png\" style=\"width: 600px; height: 510px;\" />\n<pre>\n<strong>Input:</strong> root = [3,5,1,6,2,0,8,null,null,7,4]\n<strong>Output:</strong> [2,7,4]\n<strong>Explanation:</strong> We return the node with value 2, colored in yellow in the diagram.\nThe nodes coloured in blue are the deepest leaf-nodes of the tree.\nNote that nodes 6, 0, and 8 are also leaf nodes, but the depth of them is 2, but the depth of nodes 7 and 4 is 3.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1]\n<strong>Output:</strong> [1]\n<strong>Explanation:</strong> The root is the deepest node in the tree, and it&#39;s the lca of itself.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [0,1,3,null,2]\n<strong>Output:</strong> [2]\n<strong>Explanation:</strong> The deepest leaf node in the tree is 2, the lca of one node is itself.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree will be in the range <code>[1, 1000]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 1000</code></li>\n\t<li>The values of the nodes in the tree are <strong>unique</strong>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Note:</strong> This question is the same as 865: <a href=\"https://leetcode.com/problems/smallest-subtree-with-all-the-deepest-nodes/\" target=\"_blank\">https://leetcode.com/problems/smallest-subtree-with-all-the-deepest-nodes/</a></p>\n",
  "likes": 2579,
  "dislikes": 942,
  "stats": {
    "totalAccepted": "233.6K",
    "totalSubmission": "295.8K",
    "totalAcceptedRaw": 233606,
    "totalSubmissionRaw": 295771,
    "acRate": "79.0%"
  },
  "topicTags": [
    {
      "name": "Hash Table",
      "slug": "hash-table"
    },
    {
      "name": "Tree",
      "slug": "tree"
    },
    {
      "name": "Depth-First Search",
      "slug": "depth-first-search"
    },
    {
      "name": "Breadth-First Search",
      "slug": "breadth-first-search"
    },
    {
      "name": "Binary Tree",
      "slug": "binary-tree"
    }
  ],
  "metaData": {
    "name": "lcaDeepestLeaves",
    "params": [
      {
        "name": "root",
        "type": "TreeNode"
      }
    ],
    "return": {
      "type": "TreeNode"
    }
  },
  "discussion_posts": [
    {
      "name": "saadkhan_king",
      "year": 2023,
      "content": "why  cant you just describe the questions clearly\\n",
      "voteCount": 387
    },
    {
      "name": "DonaldTrump",
      "year": 2019,
      "content": "Shouldn\\'t the lca of bunch of nodes just 1 tree node? Why [1,2,3] returns [1,2,3]?",
      "voteCount": 146
    },
    {
      "name": "am_pm_",
      "year": 2025,
      "content": "I was expecting Maximum Value of an Ordered Triplet III  \\uD83D\\uDE02\\uD83D\\uDE02",
      "voteCount": 79
    },
    {
      "name": "reneilpascua",
      "year": 2022,
      "content": "Input: root = [0,1,3,null,2]\\nOutput: [2]\\nExplanation: The deepest leaf node in the tree is 2, the lca of one node is itself.\\n\\n... i don\\'t understand what this tree looks like. is (2) disconnected? by reading the list it looks like (2)\\'s ancestor is (1)",
      "voteCount": 59
    },
    {
      "name": "LeadingTheAbyss",
      "year": 2025,
      "content": "# \\uD83D\\uDE07 Hints That Actually Help\\n\\n> - **Approach Hints \\u27A4** 1, 2, 3  \\n> - **Implementation Hints \\u27A4** 4, 5  \\n\\n<details>  \\n  <summary><span style=\"font-size:20px;\"><strong>Hint 1.</strong></span></summary>  \\n  <span style=\"font-size:18px;\">Think about how <strong>DFS</strong> or <strong>finding depth</strong> could solve this question?</span>  \\n</details>  \\n<br>  \\n\\n<details>  \\n  <summary><span style=\"font-size:20px;\"><strong>Hint 2.</strong></span></summary>  \\n  <span style=\"font-size:18px;\">Find the <strong>maxDepth</strong> of the binary tree. Try solving \\n  <a href=\"https://leetcode.com/problems/maximum-depth-of-binary-tree/\" target=\"_blank\">104. Maximum Depth of Binary Tree</a> first if needed.</span>  \\n</details>\\n<br>  \\n\\n<details>  \\n  <summary><span style=\"font-size:20px;\"><strong>Hint 3.</strong></span></summary>  \\n  <span style=\"font-size:18px;\">Try to use recursion until you reach <code>maxDepth - 1</code> and return that node.</span>  \\n</details>  \\n<br>  \\n\\n<details>  \\n  <summary><span style=\"font-size:20px;\"><strong>Hint 4.</strong></span></summary>  \\n  <span style=\"font-size:18px;\">\\n    Maintain a <code>currentLength</code> counter during recursion and keep using <strong>DFS</strong> until you reach <code>maxDepth - 1</code>. When you reach that level, you can return the current node:\\n    <br>\\n    <code>if (maxi - 1 == currentLength) return root;</code>\\n    <br>\\n  </span>  \\n</details>\\n<br>\\n\\n<details>  \\n  <summary><span style=\"font-size:20px;\"><strong>Hint 5.</strong></span></summary>  \\n  <span style=\"font-size:18px;\">\\n    After recursing on both sides, combine their results as follows:\\n    <br>\\n    <code>if (left && right) return root;<br>return left ? left : right;</code>\\n    <br>\\n    This means if both <strong>left</strong> and <strong>right</strong> return <strong>non-null</strong> values, the <strong>current node</strong> is the <strong>lowest common ancestor</strong>. Otherwise, return the non-null child.\\n  </span>  \\n</details>\\n<br>",
      "voteCount": 55
    },
    {
      "name": "mrjbarnett",
      "year": 2019,
      "content": "What is meant by deepest leaves?\\n\\nThe two deepest leaves?  \\n\\nWhat if there are more than two leaves at the deepest level?\\n\\nWhat if there is 1 leave at the deepest level and 2 leaves at the second deepest level?\\n",
      "voteCount": 36
    },
    {
      "name": "sumit_verma_77",
      "year": 2025,
      "content": "`Hint:` If the left and right subtree heights of a node are the same, that node is the Lowest Common Ancestor (LCA) of the deepest leaves.",
      "voteCount": 19
    },
    {
      "name": "abhinav550",
      "year": 2025,
      "content": "Had a seizure reading this",
      "voteCount": 16
    },
    {
      "name": "Preksha_1909",
      "year": 2024,
      "content": "consider this test case :\\nInput\\nroot =\\n[1,2,null,3,4,null,6,null,5]\\nOutput\\n[2,3,4,null,6,null,5]\\n\\none more tip \\n\\n1.) To solve the problem, you can first find the height of the tree. \\n2.) Then, identify the nodes at the deepest level and find their Lowest Common Ancestor (LCA). \\n3.) This approach ensures you locate the LCA of the deepest leaves effectively.\\n[solution](https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/solutions/5639638/beginner-friendly-no-use-of-hashmap-postorder-traversal-clearly-explained)",
      "voteCount": 12
    },
    {
      "name": "Laksha-Prashanth",
      "year": 2020,
      "content": "This seems to be duplicate of the following.\\nhttps://leetcode.com/problems/smallest-subtree-with-all-the-deepest-nodes/",
      "voteCount": 12
    }
  ]
}
