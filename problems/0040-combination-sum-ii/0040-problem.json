{
  "category": "",
  "id": "40",
  "name": "Combination Sum II",
  "difficulty": "Medium",
  "leetcode_url": "https://leetcode.com/problems/combination-sum-ii/",
  "slug": "combination-sum-ii",
  "isPaidOnly": false,
  "tags": [
    "Array",
    "Backtracking"
  ],
  "similar_questions": [
    {
      "title": "Combination Sum",
      "difficulty": "Medium",
      "slug": "combination-sum"
    }
  ],
  "questionId": "40",
  "questionFrontendId": "40",
  "title": "Combination Sum II",
  "titleSlug": "combination-sum-ii",
  "content": "<p>Given a collection of candidate numbers (<code>candidates</code>) and a target number (<code>target</code>), find all unique combinations in <code>candidates</code>&nbsp;where the candidate numbers sum to <code>target</code>.</p>\n\n<p>Each number in <code>candidates</code>&nbsp;may only be used <strong>once</strong> in the combination.</p>\n\n<p><strong>Note:</strong>&nbsp;The solution set must not contain duplicate combinations.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> candidates = [10,1,2,7,6,1,5], target = 8\n<strong>Output:</strong> \n[\n[1,1,6],\n[1,2,5],\n[1,7],\n[2,6]\n]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> candidates = [2,5,2,1,2], target = 5\n<strong>Output:</strong> \n[\n[1,2,2],\n[5]\n]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;=&nbsp;candidates.length &lt;= 100</code></li>\n\t<li><code>1 &lt;=&nbsp;candidates[i] &lt;= 50</code></li>\n\t<li><code>1 &lt;= target &lt;= 30</code></li>\n</ul>\n",
  "likes": 11824,
  "dislikes": 364,
  "stats": {
    "totalAccepted": "1.5M",
    "totalSubmission": "2.6M",
    "totalAcceptedRaw": 1489161,
    "totalSubmissionRaw": 2562742,
    "acRate": "58.1%"
  },
  "topicTags": [
    {
      "name": "Array",
      "slug": "array"
    },
    {
      "name": "Backtracking",
      "slug": "backtracking"
    }
  ],
  "metaData": {
    "name": "combinationSum2",
    "params": [
      {
        "name": "candidates",
        "type": "integer[]"
      },
      {
        "name": "target",
        "type": "integer"
      }
    ],
    "return": {
      "type": "list<list<integer>>",
      "dealloc": true
    }
  },
  "discussion_posts": [
    {
      "name": "ananta_srivastava",
      "year": 2023,
      "content": "where in the question is it mentioned that th ans should be in sorted order?",
      "voteCount": 293
    },
    {
      "name": "nachiketa_bhoraniya",
      "year": 2023,
      "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29",
      "voteCount": 88
    },
    {
      "name": "PurdueKumar",
      "year": 2018,
      "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution.",
      "voteCount": 86
    },
    {
      "name": "rafia_coding",
      "year": 2024,
      "content": "#TLE 172/176\\uD83D\\uDC94",
      "voteCount": 61
    },
    {
      "name": "james007_nagar",
      "year": 2024,
      "content": "When you consider just consider and move forward, but when you do not consider than do not consider any of it\\'s duplicate, how you make sure it -> just Sort the array and skip all adjacent duplicate elements when you do not consider.",
      "voteCount": 55
    },
    {
      "name": "adityakumar8068",
      "year": 2024,
      "content": "TESTCASES------------>\\n```\\n[10,1,2,7,6,1,5]\\n8\\n[2,5,2,1,2]\\n5\\n[2, 2, 2, 2, 3, 6, 7]\\n9\\n[1, 2, 2, 3, 3, 4, 5, 6, 7, 8, 9, 10]\\n 25\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\n29\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n30\\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50]\\n30\\n [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]\\n 15",
      "voteCount": 40
    },
    {
      "name": "Cocamo1337",
      "year": 2023,
      "content": "Sort the candidates array then when looping over candidates, use a \"previous\" variable that holds the most recently used number in it. At the start of your loop, if previous == candidates[i], continue to the next number. This, along with setting up your recursive function the right way, should allow you to avoid any duplicate combinations.\\n\\nA bit of code for reference:\\n ```\\n        int prev = -1;\\n        for (int i = ind; i < cand.Length; i++){\\n            if (currSum + cand[i] > targ) break;\\n            if (prev == cand[i]) continue;\\n            currComb.Add(cand[i]);\\n            findComb(cand, targ, currSum + cand[i], currComb, i + 1);\\n            currComb.RemoveAt(currComb.Count - 1);\\n            prev = cand[i];\\n        } \\n```",
      "voteCount": 34
    },
    {
      "name": "lowut02",
      "year": 2023,
      "content": "Horrible problem tbh.",
      "voteCount": 32
    },
    {
      "name": "aman_mnnit",
      "year": 2022,
      "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?",
      "voteCount": 31
    },
    {
      "name": "rakesh_joshi",
      "year": 2016,
      "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you .",
      "voteCount": 21
    }
  ]
}
