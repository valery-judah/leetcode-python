{
  "category": "",
  "id": "698",
  "name": "Partition to K Equal Sum Subsets",
  "difficulty": "Medium",
  "leetcode_url": "https://leetcode.com/problems/partition-to-k-equal-sum-subsets/",
  "slug": "partition-to-k-equal-sum-subsets",
  "isPaidOnly": false,
  "tags": [
    "Array",
    "Dynamic Programming",
    "Backtracking",
    "Bit Manipulation",
    "Memoization",
    "Bitmask"
  ],
  "similar_questions": [
    {
      "title": "Partition Equal Subset Sum",
      "difficulty": "Medium",
      "slug": "partition-equal-subset-sum"
    },
    {
      "title": "Fair Distribution of Cookies",
      "difficulty": "Medium",
      "slug": "fair-distribution-of-cookies"
    },
    {
      "title": "Maximum Number of Ways to Partition an Array",
      "difficulty": "Hard",
      "slug": "maximum-number-of-ways-to-partition-an-array"
    },
    {
      "title": "Maximum Rows Covered by Columns",
      "difficulty": "Medium",
      "slug": "maximum-rows-covered-by-columns"
    },
    {
      "title": "Maximum Product of Two Integers With No Common Bits",
      "difficulty": "Medium",
      "slug": "maximum-product-of-two-integers-with-no-common-bits"
    }
  ],
  "questionId": "698",
  "questionFrontendId": "698",
  "title": "Partition to K Equal Sum Subsets",
  "titleSlug": "partition-to-k-equal-sum-subsets",
  "content": "<p>Given an integer array <code>nums</code> and an integer <code>k</code>, return <code>true</code> if it is possible to divide this array into <code>k</code> non-empty subsets whose sums are all equal.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [4,3,2,3,5,2,1], k = 4\n<strong>Output:</strong> true\n<strong>Explanation:</strong> It is possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,4], k = 3\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= nums.length &lt;= 16</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li>The frequency of each element is in the range <code>[1, 4]</code>.</li>\n</ul>\n",
  "likes": 7414,
  "dislikes": 544,
  "stats": {
    "totalAccepted": "318.8K",
    "totalSubmission": "834.5K",
    "totalAcceptedRaw": 318763,
    "totalSubmissionRaw": 834479,
    "acRate": "38.2%"
  },
  "topicTags": [
    {
      "name": "Array",
      "slug": "array"
    },
    {
      "name": "Dynamic Programming",
      "slug": "dynamic-programming"
    },
    {
      "name": "Backtracking",
      "slug": "backtracking"
    },
    {
      "name": "Bit Manipulation",
      "slug": "bit-manipulation"
    },
    {
      "name": "Memoization",
      "slug": "memoization"
    },
    {
      "name": "Bitmask",
      "slug": "bitmask"
    }
  ],
  "metaData": {
    "name": "canPartitionKSubsets",
    "params": [
      {
        "name": "nums",
        "type": "integer[]"
      },
      {
        "name": "k",
        "type": "integer"
      }
    ],
    "return": {
      "type": "boolean"
    }
  },
  "discussion_posts": [
    {
      "name": "iamnotevensorry",
      "year": 2020,
      "content": "Am I the only one who finds it hard.",
      "voteCount": 192
    },
    {
      "name": "MC_Jin",
      "year": 2023,
      "content": "Should be a HARD problem.",
      "voteCount": 80
    },
    {
      "name": "readytobe21",
      "year": 2019,
      "content": "This problem could not be solved with dp but only with DFS/backtracking. Please change the related topcis since it confuses people.",
      "voteCount": 51
    },
    {
      "name": "SG-C",
      "year": 2023,
      "content": "This Should be Labeled Hard",
      "voteCount": 45
    },
    {
      "name": "conv2d",
      "year": 2024,
      "content": "My 2017 solution, which beat 87% other solutions, got TLE today .. the problem evolved ",
      "voteCount": 37
    },
    {
      "name": "Ninjabdul",
      "year": 2023,
      "content": "TLE hell hole",
      "voteCount": 13
    },
    {
      "name": "ChaitanyaGarg",
      "year": 2023,
      "content": "Every Solution I try is submit is giving Time Limit Exceeded. I thought maybe my solution is inefficient, but when I looked for others solutions, they had also done the same backtracking. I tried to copy paste there solution to check, but it also gave TLE. I am using C++.",
      "voteCount": 13
    },
    {
      "name": "hardWorker_99",
      "year": 2020,
      "content": "...Can this problem be solved using 0/1 knapsack ??",
      "voteCount": 12
    },
    {
      "name": "rv329707",
      "year": 2024,
      "content": "if you are using backtracking or dfs try to optimize it by some kind of early termination.\\nUse this testcase\\n[10,1,10,9,6,1,9,5,9,10,7,8,5,2,10,8]\\n11",
      "voteCount": 9
    },
    {
      "name": "user6099mf",
      "year": 2023,
      "content": "My approach is to find the sum of whole array, if its not divisible by k then return false. If is equal then count the subset with sum  = sum/k. If number of subset == k  return true else return false. But my answer is coming incorrect. Why is this so?",
      "voteCount": 6
    }
  ]
}
