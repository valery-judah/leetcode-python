{
  "category": "",
  "id": "78",
  "name": "Subsets",
  "difficulty": "Medium",
  "leetcode_url": "https://leetcode.com/problems/subsets/",
  "slug": "subsets",
  "isPaidOnly": false,
  "tags": [
    "Array",
    "Backtracking",
    "Bit Manipulation"
  ],
  "similar_questions": [
    {
      "title": "Subsets II",
      "difficulty": "Medium",
      "slug": "subsets-ii"
    },
    {
      "title": "Generalized Abbreviation",
      "difficulty": "Medium",
      "slug": "generalized-abbreviation"
    },
    {
      "title": "Letter Case Permutation",
      "difficulty": "Medium",
      "slug": "letter-case-permutation"
    },
    {
      "title": "Find Array Given Subset Sums",
      "difficulty": "Hard",
      "slug": "find-array-given-subset-sums"
    },
    {
      "title": "Count Number of Maximum Bitwise-OR Subsets",
      "difficulty": "Medium",
      "slug": "count-number-of-maximum-bitwise-or-subsets"
    }
  ],
  "questionId": "78",
  "questionFrontendId": "78",
  "title": "Subsets",
  "titleSlug": "subsets",
  "content": "<p>Given an integer array <code>nums</code> of <strong>unique</strong> elements, return <em>all possible</em> <span data-keyword=\"subset\"><em>subsets</em></span> <em>(the power set)</em>.</p>\n\n<p>The solution set <strong>must not</strong> contain duplicate subsets. Return the solution in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3]\n<strong>Output:</strong> [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0]\n<strong>Output:</strong> [[],[0]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10</code></li>\n\t<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>\n\t<li>All the numbers of&nbsp;<code>nums</code> are <strong>unique</strong>.</li>\n</ul>\n",
  "likes": 18582,
  "dislikes": 323,
  "stats": {
    "totalAccepted": "2.7M",
    "totalSubmission": "3.3M",
    "totalAcceptedRaw": 2679538,
    "totalSubmissionRaw": 3293146,
    "acRate": "81.4%"
  },
  "topicTags": [
    {
      "name": "Array",
      "slug": "array"
    },
    {
      "name": "Backtracking",
      "slug": "backtracking"
    },
    {
      "name": "Bit Manipulation",
      "slug": "bit-manipulation"
    }
  ],
  "metaData": {
    "name": "subsets",
    "params": [
      {
        "name": "nums",
        "type": "integer[]"
      }
    ],
    "return": {
      "type": "list<list<integer>>",
      "dealloc": true
    }
  },
  "company_tag_stats": {
    "1": [
      {
        "taggedByAdmin": false,
        "name": "Google",
        "slug": "google",
        "timesEncountered": 18
      },
      {
        "taggedByAdmin": true,
        "name": "Meta",
        "slug": "facebook",
        "timesEncountered": 16
      }
    ]
  },
  "discussion_posts": [
    {
      "name": "frolik",
      "year": 2024,
      "content": "So calculate all subsets and sum all their XOR results is easy, but getting all subsets alone is a medium problem\n\nEDIT: Let me clarify for people in future. Yesterday we had [this](https://leetcode.com/problems/sum-of-all-subset-xor-totals/description/?envType=daily-question&envId=2024-05-20) problem, which has the same difficulty level as this one, but it's considered as \"easy\" while this problem is \"medium\"",
      "voteCount": 358
    },
    {
      "name": "period",
      "year": 2024,
      "content": "If you're following a guide and get stuck on this problem, make sure you have done the pre-reqs.\n1. Understand recursion. Don't just skip to this, otherwise understanding the call stack will be difficult. Do basic recursion problems.\n2. Draw out the state diagram. In this problem, you have two decisions you can make. Pick the number at the current index, or skip that number. There are plenty of videos on visualization for these sorts of problems, follow along. Struggle here, and be rewarded it for it later.\n3. Come back to these sorts of problems, repeat step 2 and solve it again. Consistency is key.\n4. Don't just blindly copy down to solution involving the for loop. Begin with understanding the solution that purely involves the two function calls.\n5. Once you've truly understood this problem, move on to Combination Sum and other backtracking problems that involve pick or skip.\n6. If you've made it here, utilize DFS + For Loops. You will need to use this concept, and an immediate application from here is Letter Combinations of a Phone Number. This will be also be valuable for DFS grid questions, think No. Islands, Word Search.\n7. To start with DP, understand how to brute-force, then top-down memo, then bottom up. There's a great guide [here](https://leetcode.com/problems/house-robber/solutions/156523/from-good-to-great-how-to-approach-most-of-dp-problems/)",
      "voteCount": 194
    },
    {
      "name": "njbrown180",
      "year": 2024,
      "content": "Who else is on the \"did this yesterday\" crew? \\uD83D\\uDE01",
      "voteCount": 134
    },
    {
      "name": "Hidenori826",
      "year": 2024,
      "content": "This would have been a brilliant question to have before yesterday\\'s problem LOL",
      "voteCount": 104
    },
    {
      "name": "ritikranjan009",
      "year": 2024,
      "content": "This is a really good problem to start with the concept of recursion",
      "voteCount": 45
    },
    {
      "name": "penrosecat",
      "year": 2021,
      "content": "The subsets problem has two backtracking solutions, one in which we loop over all the elements in the rest of the array and add an element recur and remove the element and one in which we have two recursive calls for each element, one in which the present element is added and one in which the present element is skipped.\\n\\nThese can be explained as follows. \\n\\nIn the **first** way, we use the mathematical logic \"create every subset which contains this element for every element\".  Starting from a blank array, we first want to create every subset which contains nums[0]. So, we add nums[0] to a blank array. \\n\\nThinking mathematically again, all the subsets that contain nums[0] are all the subsets of the array excluding nums[0] to which nums[0] is added. Since the recursive function returns all the subsets beginning from the next index, it is time for a recursive call where the present element is included. After this call, all the subsets containing this element have been added and so it may be removed. \\n\\nThe reason for the loop to go over every element is that the subsets excluding the current element are always given by all the subsets that can be formed by including each one of the following elements as the beginning of the rest of the subset.\\n\\nIn the **second** way we use the combinatorial logic of every element can either \"be present or not be present\" in a subset. We make a recursive call where the element is not present and then one where it is present. There is no need for loops and when the present index reaches the end of the array it means another subset is completed and can be added to the result.\\n\\nThe second way is more straightforward since that is how most people view the construction of a subset, however the first way is more suited to a variety of approaches. For example in Subsets II, for both the approaches the only difference from Subsets is an if statement, however it is much easier to write this statement in the first case than in the second.\\n\\nFor Subsets II, repetitions are not allowed. So by sorting the array before performing either method, we ensure that we can easily check for the last inserted element.\\n\\nIn the first method if i > idx && A[idx-1] == A[idx] where idx is the beginning index for the iteration it suggests a duplicate element. However once we have a single copy inserted then the recursive calls will make sure that any copies are places always at i == idx and hence recursive calls will only add the duplicate values, never replace them.\\n\\nIn the second method, the recursive call to the non-appended array should be made only either the current array is empty or if the last element in the current array is not equal to the present element. Again, the appended call is always made since the subset with different number of duplicates is counted but one with replaced duplicates is not.\\n\\n",
      "voteCount": 30
    },
    {
      "name": "RedHessian",
      "year": 2023,
      "content": "Apparently the return order does matter.\n![image](https://i.imgur.com/rD0KZHZ.png)",
      "voteCount": 20
    },
    {
      "name": "sam02202001",
      "year": 2023,
      "content": "I am in a big confusion man !!\nHow these two codes are getting accepted successfully\nFirst - https://leetcode.com/problems/subsets/submissions/899975210/\nSecond - https://leetcode.com/problems/subsets/submissions/899974496/\n\nIn first i have used `if( ( i & (1 << j )) != 0 )` \nwhile in second I have used  `if( ( i & (1 << j )) == 0 )` \nHow these totally opposite conditions are leading to same answer ",
      "voteCount": 16
    },
    {
      "name": "user1484IW",
      "year": 2024,
      "content": "Let nums = [1, 2, 3], n = 3\n\nConsider the following 3-bit truth table:\n\n| 1 | 2 | 3 | Subset\n| -  | - |  - | --------\n| 0 | 0 | 0 | Null\n| 0 | 0 | 1 | 3\n| 0 | 1 | 0 | 2\n| 0 | 1 | 1 | 2, 3\n| 1 | 0 | 0 | 1\n| 1 | 0 | 1 | 1, 3\n| 1 | 1 | 0 | 1, 2\n| 1 | 1 | 1 | 1, 2, 3\n\nObserve that each row corresponds to a subset of nums. Can u take it from here?\n\n---\n\nTo get the table, u just need to iterate from 0 to 2**n, then for each row check which bits are 1 (using xor) and add corresponding element(s) to subset.\n\nFor eg, consider row 7 (110)\n110 & 001 = 0\n110 & 010 != 0 \n110 & 100 != 0\n\nThus our subset will be [1, 2]. DIY!",
      "voteCount": 13
    },
    {
      "name": "heir-of-god",
      "year": 2024,
      "content": "Wasn't this supposed to be before yesterday's problem? \n**Next: Now perform this operation on result of tomorrow's problem**",
      "voteCount": 11
    }
  ]
}
