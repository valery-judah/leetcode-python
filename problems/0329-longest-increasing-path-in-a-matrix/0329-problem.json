{
  "category": "",
  "id": "329",
  "name": "Longest Increasing Path in a Matrix",
  "difficulty": "Hard",
  "leetcode_url": "https://leetcode.com/problems/longest-increasing-path-in-a-matrix/",
  "slug": "longest-increasing-path-in-a-matrix",
  "isPaidOnly": false,
  "tags": [
    "Array",
    "Dynamic Programming",
    "Depth-First Search",
    "Breadth-First Search",
    "Graph",
    "Topological Sort",
    "Memoization",
    "Matrix"
  ],
  "similar_questions": [
    {
      "title": "Number of Increasing Paths in a Grid",
      "difficulty": "Hard",
      "slug": "number-of-increasing-paths-in-a-grid"
    }
  ],
  "questionId": "329",
  "questionFrontendId": "329",
  "title": "Longest Increasing Path in a Matrix",
  "titleSlug": "longest-increasing-path-in-a-matrix",
  "content": "<p>Given an <code>m x n</code> integers <code>matrix</code>, return <em>the length of the longest increasing path in </em><code>matrix</code>.</p>\n\n<p>From each cell, you can either move in four directions: left, right, up, or down. You <strong>may not</strong> move <strong>diagonally</strong> or move <strong>outside the boundary</strong> (i.e., wrap-around is not allowed).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/05/grid1.jpg\" style=\"width: 242px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[9,9,4],[6,6,8],[2,1,1]]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> The longest increasing path is <code>[1, 2, 6, 9]</code>.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/27/tmp-grid.jpg\" style=\"width: 253px; height: 253px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[3,4,5],[3,2,6],[2,2,1]]\n<strong>Output:</strong> 4\n<strong>Explanation: </strong>The longest increasing path is <code>[3, 4, 5, 6]</code>. Moving diagonally is not allowed.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> matrix = [[1]]\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 200</code></li>\n\t<li><code>0 &lt;= matrix[i][j] &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
  "likes": 9329,
  "dislikes": 145,
  "stats": {
    "totalAccepted": "657.3K",
    "totalSubmission": "1.2M",
    "totalAcceptedRaw": 657258,
    "totalSubmissionRaw": 1179893,
    "acRate": "55.7%"
  },
  "topicTags": [
    {
      "name": "Array",
      "slug": "array"
    },
    {
      "name": "Dynamic Programming",
      "slug": "dynamic-programming"
    },
    {
      "name": "Depth-First Search",
      "slug": "depth-first-search"
    },
    {
      "name": "Breadth-First Search",
      "slug": "breadth-first-search"
    },
    {
      "name": "Graph",
      "slug": "graph"
    },
    {
      "name": "Topological Sort",
      "slug": "topological-sort"
    },
    {
      "name": "Memoization",
      "slug": "memoization"
    },
    {
      "name": "Matrix",
      "slug": "matrix"
    }
  ],
  "metaData": {
    "name": "longestIncreasingPath",
    "params": [
      {
        "name": "matrix",
        "type": "integer[][]"
      }
    ],
    "return": {
      "type": "integer"
    }
  },
  "company_tag_stats": {
    "1": [
      {
        "taggedByAdmin": false,
        "name": "DoorDash",
        "slug": "doordash",
        "timesEncountered": 19
      }
    ]
  },
  "discussion_posts": [
    {
      "name": "rmn",
      "year": 2016,
      "content": "It's pretty straightforward Dfs + memoization. You don't even need to mark cells as seen due to the nature of the problem.\\nI think there are plenty of \"Medium\" rated questions out there that are a lot harder than this one :)",
      "voteCount": 233
    },
    {
      "name": "rjdarkknight1",
      "year": 2022,
      "content": "This should be medium while [Pacific Atlantic Water Flow](https://leetcode.com/problems/pacific-atlantic-water-flow/description/) should be hard.",
      "voteCount": 75
    },
    {
      "name": "Aditya560",
      "year": 2024,
      "content": "In 2023 I use to say I hate dp. \\nIn 2024 My favorite topic is dp.",
      "voteCount": 34
    },
    {
      "name": "hashdgwhansb",
      "year": 2021,
      "content": "For those who are having TLE in there memoized DFS, pass the matrix using call by reference rather call by value.\\nIn passing it through call by value it copies that 200 by 200 everytime which increases the time complexity. So pass it call by reference ;)",
      "voteCount": 28
    },
    {
      "name": "SrinathC09",
      "year": 2024,
      "content": "You dont need to create an array \"visited\" as you only go to a cell if its value is greater than the one you are at. So there\\'s absolutely no chance you come to the same cell again.\\n",
      "voteCount": 19
    },
    {
      "name": "ttaylor27",
      "year": 2024,
      "content": "DP method likely a medium, however taking another route and applying Kahn\\'s algorithm for Topological sorting can justify this as a hard. I would recommend others to give it a try, as it is certainly manageable and is valuable in teaching another way to approach problems such as these.",
      "voteCount": 17
    },
    {
      "name": "nick_nick_go",
      "year": 2020,
      "content": "Simple DFS with Memo works",
      "voteCount": 14
    },
    {
      "name": "hlin117",
      "year": 2020,
      "content": "In the solution, they mention that the naive DFS solution starting from each square is O(2^(n + m)). Can someone explain how they derive this?",
      "voteCount": 10
    },
    {
      "name": "Linmuadido",
      "year": 2016,
      "content": "Hello, everybody:\\n\\nI think the relax-based method, either DP or DFS (or both) , is working fine with the complexity O(mn).\\n\\nIn terms of graph model, the original problem input is a DAG(directed acrylic graph). However \"non-decreasing\" path requires bi-directional edge between neighbors with the same value. That is, the graph is not a DAG anymore.\\n\\nIf the problem changes to longest \"non-decreasing\" instead of \"increasing\" path, anyone thinks it is still doable in O(mn) time? How? Or Why not?",
      "voteCount": 10
    },
    {
      "name": "sebb86x",
      "year": 2025,
      "content": "Check this test case, fails with TLE if no proper memoization used:\n\n `[[0,1,2,3,4,5,6,7,8,9],[19,18,17,16,15,14,13,12,11,10],[20,21,22,23,24,25,26,27,28,29],[39,38,37,36,35,34,33,32,31,30],[40,41,42,43,44,45,46,47,48,49],[59,58,57,56,55,54,53,52,51,50],[60,61,62,63,64,65,66,67,68,69],[79,78,77,76,75,74,73,72,71,70],[80,81,82,83,84,85,86,87,88,89],[99,98,97,96,95,94,93,92,91,90],[100,101,102,103,104,105,106,107,108,109],[119,118,117,116,115,114,113,112,111,110],[120,121,122,123,124,125,126,127,128,129],[139,138,137,136,135,134,133,132,131,130],[0,0,0,0,0,0,0,0,0,0]]`",
      "voteCount": 5
    }
  ]
}
