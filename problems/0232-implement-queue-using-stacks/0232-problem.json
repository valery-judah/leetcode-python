{
  "category": "",
  "id": "232",
  "name": "Implement Queue using Stacks",
  "difficulty": "Easy",
  "leetcode_url": "https://leetcode.com/problems/implement-queue-using-stacks/",
  "slug": "implement-queue-using-stacks",
  "isPaidOnly": false,
  "tags": [
    "Stack",
    "Design",
    "Queue"
  ],
  "similar_questions": [
    {
      "title": "Implement Stack using Queues",
      "difficulty": "Easy",
      "slug": "implement-stack-using-queues"
    }
  ],
  "questionId": "232",
  "questionFrontendId": "232",
  "title": "Implement Queue using Stacks",
  "titleSlug": "implement-queue-using-stacks",
  "content": "<p>Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (<code>push</code>, <code>peek</code>, <code>pop</code>, and <code>empty</code>).</p>\n\n<p>Implement the <code>MyQueue</code> class:</p>\n\n<ul>\n\t<li><code>void push(int x)</code> Pushes element x to the back of the queue.</li>\n\t<li><code>int pop()</code> Removes the element from the front of the queue and returns it.</li>\n\t<li><code>int peek()</code> Returns the element at the front of the queue.</li>\n\t<li><code>boolean empty()</code> Returns <code>true</code> if the queue is empty, <code>false</code> otherwise.</li>\n</ul>\n\n<p><strong>Notes:</strong></p>\n\n<ul>\n\t<li>You must use <strong>only</strong> standard operations of a stack, which means only <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, and <code>is empty</code> operations are valid.</li>\n\t<li>Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack&#39;s standard operations.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;MyQueue&quot;, &quot;push&quot;, &quot;push&quot;, &quot;peek&quot;, &quot;pop&quot;, &quot;empty&quot;]\n[[], [1], [2], [], [], []]\n<strong>Output</strong>\n[null, null, null, 1, 1, false]\n\n<strong>Explanation</strong>\nMyQueue myQueue = new MyQueue();\nmyQueue.push(1); // queue is: [1]\nmyQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\nmyQueue.peek(); // return 1\nmyQueue.pop(); // return 1, queue is [2]\nmyQueue.empty(); // return false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= x &lt;= 9</code></li>\n\t<li>At most <code>100</code>&nbsp;calls will be made to <code>push</code>, <code>pop</code>, <code>peek</code>, and <code>empty</code>.</li>\n\t<li>All the calls to <code>pop</code> and <code>peek</code> are valid.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow-up:</strong> Can you implement the queue such that each operation is <strong><a href=\"https://en.wikipedia.org/wiki/Amortized_analysis\" target=\"_blank\">amortized</a></strong> <code>O(1)</code> time complexity? In other words, performing <code>n</code> operations will take overall <code>O(n)</code> time even if one of those operations may take longer.</p>\n",
  "likes": 8300,
  "dislikes": 467,
  "stats": {
    "totalAccepted": "1.3M",
    "totalSubmission": "1.9M",
    "totalAcceptedRaw": 1280701,
    "totalSubmissionRaw": 1869263,
    "acRate": "68.5%"
  },
  "topicTags": [
    {
      "name": "Stack",
      "slug": "stack"
    },
    {
      "name": "Design",
      "slug": "design"
    },
    {
      "name": "Queue",
      "slug": "queue"
    }
  ],
  "metaData": {
    "classname": "MyQueue",
    "constructor": {
      "params": []
    },
    "methods": [
      {
        "params": [
          {
            "type": "integer",
            "name": "x"
          }
        ],
        "return": {
          "type": "void"
        },
        "name": "push"
      },
      {
        "params": [],
        "return": {
          "type": "integer"
        },
        "name": "pop"
      },
      {
        "params": [],
        "return": {
          "type": "integer"
        },
        "name": "peek"
      },
      {
        "params": [],
        "return": {
          "type": "boolean"
        },
        "name": "empty"
      }
    ],
    "return": {
      "type": "boolean"
    },
    "systemdesign": true
  },
  "discussion_posts": [
    {
      "name": "heqingy",
      "year": 2015,
      "content": "I was asked in the internship interview of a company two years ago.\\n\\nThe application for this implementation is to separate read & write of a queue in multi-processing. One of the stack is for read, and another is for write. They only interfere each other when the former one is full or latter is empty.\\n\\nThis is not only a trick. :)",
      "voteCount": 434
    },
    {
      "name": "alaemenai",
      "year": 2023,
      "content": "1. `push` should be `enqueue`.\\n2. `pop` should be `dequeue`",
      "voteCount": 89
    },
    {
      "name": "arjun_50",
      "year": 2023,
      "content": "why methods are called here push and pop insted of enque and dequeue",
      "voteCount": 67
    },
    {
      "name": "sethles",
      "year": 2024,
      "content": "Congrats everyone. We weathered the storm.",
      "voteCount": 63
    },
    {
      "name": "hatemeeveryday",
      "year": 2022,
      "content": "a terrible problem...",
      "voteCount": 56
    },
    {
      "name": "mstuebs",
      "year": 2024,
      "content": "I hope these TCs help validate your solution:\\n```\\n[\"MyQueue\",\"empty\",\"push\",\"push\",\"empty\",\"peek\",\"push\",\"push\",\"peek\",\"pop\",\"empty\",\"peek\",\"pop\",\"empty\"]\\n[[],[],[1],[1],[],[],[5],[5],[],[],[],[],[],[]]\\n[\"MyQueue\",\"push\",\"pop\",\"push\",\"empty\",\"push\",\"pop\",\"peek\",\"push\",\"empty\",\"pop\",\"pop\",\"push\",\"push\",\"peek\",\"empty\",\"empty\",\"empty\",\"pop\",\"pop\",\"push\",\"push\",\"pop\",\"empty\",\"empty\",\"pop\",\"push\",\"empty\",\"push\",\"pop\",\"push\",\"peek\",\"empty\",\"pop\",\"peek\",\"push\",\"empty\",\"push\",\"empty\",\"push\",\"peek\",\"pop\",\"empty\",\"empty\",\"pop\",\"push\",\"pop\",\"pop\",\"empty\",\"push\",\"pop\",\"push\",\"push\",\"empty\",\"empty\",\"empty\",\"peek\",\"peek\",\"peek\",\"empty\",\"pop\",\"empty\",\"pop\",\"push\",\"empty\",\"pop\",\"pop\",\"push\",\"empty\",\"push\",\"pop\",\"empty\",\"pop\",\"push\",\"peek\",\"pop\",\"push\",\"push\",\"push\",\"push\",\"empty\",\"pop\",\"peek\",\"pop\",\"pop\",\"push\",\"peek\",\"pop\",\"pop\",\"push\",\"pop\",\"push\",\"peek\",\"push\",\"empty\",\"push\",\"empty\",\"push\",\"peek\",\"pop\",\"pop\"]\\n[[],[7],[],[8],[],[4],[],[],[4],[],[],[],[5],[7],[],[],[],[],[],[],[9],[8],[],[],[],[],[9],[],[4],[],[5],[],[],[],[],[6],[],[7],[],[5],[],[],[],[],[],[5],[],[],[],[2],[],[7],[5],[],[],[],[],[],[],[],[],[],[],[2],[],[],[],[8],[],[2],[],[],[],[2],[],[],[1],[7],[9],[5],[],[],[],[],[],[8],[],[],[],[7],[],[6],[],[7],[],[4],[],[2],[],[],[]]\\n[\"MyQueue\",\"push\",\"push\",\"push\",\"push\",\"push\",\"peek\",\"push\",\"push\",\"push\",\"push\",\"peek\",\"pop\",\"pop\",\"pop\",\"pop\",\"peek\",\"pop\",\"pop\",\"peek\",\"pop\"]\\n[[],[1],[4],[9],[2],[2],[],[1],[2],[7],[1],[],[],[],[],[],[],[],[],[],[]]\\n[\"MyQueue\",\"push\",\"push\",\"push\",\"push\",\"push\",\"push\",\"push\",\"push\",\"push\",\"push\",\"peek\",\"pop\",\"pop\",\"pop\",\"pop\",\"pop\",\"pop\",\"pop\",\"peek\",\"pop\"]\\n[[],[5],[6],[7],[6],[1],[8],[2],[5],[4],[7],[],[],[],[],[],[],[],[],[],[]]\\n[\"MyQueue\",\"push\",\"push\",\"push\",\"push\",\"push\",\"push\",\"push\",\"push\",\"push\",\"push\",\"peek\",\"pop\",\"pop\",\"pop\",\"pop\",\"pop\",\"pop\",\"empty\",\"peek\",\"pop\"]\\n[[],[4],[5],[6],[7],[8],[1],[1],[2],[3],[4],[],[],[],[],[],[],[],[],[],[]]\\n[\"MyQueue\",\"empty\",\"push\",\"push\",\"push\",\"push\",\"push\",\"empty\",\"push\",\"push\",\"push\",\"peek\",\"empty\",\"peek\",\"pop\",\"pop\",\"empty\",\"pop\",\"pop\",\"peek\",\"pop\"]\\n[[],[],[1],[1],[1],[1],[1],[],[3],[4],[5],[],[],[],[],[],[],[],[],[],[]]\\n[\"MyQueue\",\"push\",\"pop\",\"empty\",\"push\",\"pop\",\"push\",\"pop\",\"push\",\"peek\",\"empty\",\"pop\",\"push\",\"pop\",\"push\",\"peek\",\"pop\",\"empty\",\"push\",\"pop\",\"push\"]\\n[[],[1],[],[],[2],[],[3],[],[4],[],[],[],[5],[],[6],[],[],[],[7],[],[8]]\\n[\"MyQueue\",\"push\",\"push\",\"peek\",\"pop\",\"push\",\"empty\",\"pop\",\"pop\",\"push\",\"push\",\"empty\",\"push\",\"empty\",\"pop\",\"pop\",\"peek\",\"peek\",\"peek\",\"empty\",\"empty\",\"push\",\"pop\",\"pop\",\"push\",\"peek\",\"pop\",\"push\",\"empty\",\"pop\",\"push\",\"empty\",\"empty\",\"pop\",\"push\",\"empty\",\"pop\",\"push\",\"empty\",\"pop\",\"push\",\"peek\",\"push\",\"empty\",\"pop\",\"empty\",\"pop\",\"push\",\"pop\",\"push\",\"empty\",\"pop\",\"push\",\"empty\",\"pop\",\"push\",\"pop\",\"push\",\"peek\",\"pop\",\"push\",\"empty\",\"pop\",\"push\",\"pop\",\"push\",\"push\",\"empty\",\"push\",\"push\",\"pop\",\"empty\",\"pop\",\"push\",\"pop\",\"peek\",\"pop\",\"pop\",\"push\",\"peek\",\"peek\",\"push\",\"empty\",\"push\",\"push\",\"empty\",\"empty\",\"peek\",\"empty\",\"push\",\"pop\",\"pop\",\"pop\",\"peek\",\"empty\",\"pop\",\"push\",\"peek\",\"empty\",\"empty\",\"peek\"]\\n[[],[9],[3],[],[],[5],[],[],[],[3],[8],[],[8],[],[],[],[],[],[],[],[],[4],[],[],[4],[],[],[8],[],[],[3],[],[],[],[4],[],[],[8],[],[],[2],[],[6],[],[],[],[],[1],[],[7],[],[],[8],[],[],[5],[],[6],[],[],[3],[],[],[9],[],[2],[6],[],[3],[5],[],[],[],[6],[],[],[],[],[9],[],[],[2],[],[3],[4],[],[],[],[],[3],[],[],[],[],[],[],[1],[],[],[],[]]\\n```\\nAlso check out my the repo: https://github.com/mquintus/l33tcode-testcase-generator/",
      "voteCount": 32
    },
    {
      "name": "Ebad1001",
      "year": 2023,
      "content": "##### This can be done in two ways :\\n- one where `push()` takes O(1) time & `pop()` takes O(N) time\\n- one where `push()` takes O(N) time & `pop()` takes O(1) time",
      "voteCount": 29
    },
    {
      "name": "etanila",
      "year": 2024,
      "content": "Easy is just what we need after wasting a weekend on two hards.",
      "voteCount": 19
    },
    {
      "name": "anwendeng",
      "year": 2024,
      "content": "Have a good day!\nExercise for data structure.\nqueues->stack\nstacks->queue\nBut no deque! There are at least  2 ways. 1 is, push() takes O(1) time & pop() takes O(n) time. other is, push() takes O(n) time & pop() takes O(1) time. The first method is better!",
      "voteCount": 18
    },
    {
      "name": "mkprajapati1614",
      "year": 2022,
      "content": "Requires:\\n`1 STACK `: if you are comfortable with RECURSION\\n`2 STACKS` : if you are NOT comfortable with RECURSION.\\n\\nFor 2 stacks, we will be moving all the elements of 1st stack to the 2nd one before pushing a new element(x), and then moving all the elements back again.\\n\\nWe will be doing the same using recursion in case we use 1 stack approach.",
      "voteCount": 17
    }
  ]
}
