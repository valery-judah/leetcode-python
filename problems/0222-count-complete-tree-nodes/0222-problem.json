{
  "category": "",
  "id": "222",
  "name": "Count Complete Tree Nodes",
  "difficulty": "Easy",
  "leetcode_url": "https://leetcode.com/problems/count-complete-tree-nodes/",
  "slug": "count-complete-tree-nodes",
  "isPaidOnly": false,
  "tags": [
    "Binary Search",
    "Bit Manipulation",
    "Tree",
    "Binary Tree"
  ],
  "similar_questions": [
    {
      "title": "Closest Binary Search Tree Value",
      "difficulty": "Easy",
      "slug": "closest-binary-search-tree-value"
    }
  ],
  "questionId": "222",
  "questionFrontendId": "222",
  "title": "Count Complete Tree Nodes",
  "titleSlug": "count-complete-tree-nodes",
  "content": "<p>Given the <code>root</code> of a <strong>complete</strong> binary tree, return the number of the nodes in the tree.</p>\n\n<p>According to <strong><a href=\"http://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees\" target=\"_blank\">Wikipedia</a></strong>, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between <code>1</code> and <code>2<sup>h</sup></code> nodes inclusive at the last level <code>h</code>.</p>\n\n<p>Design an algorithm that runs in less than&nbsp;<code data-stringify-type=\"code\">O(n)</code>&nbsp;time complexity.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/14/complete.jpg\" style=\"width: 372px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3,4,5,6]\n<strong>Output:</strong> 6\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> 0\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1]\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 5 * 10<sup>4</sup>]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li>The tree is guaranteed to be <strong>complete</strong>.</li>\n</ul>\n",
  "likes": 9252,
  "dislikes": 595,
  "stats": {
    "totalAccepted": "1M",
    "totalSubmission": "1.5M",
    "totalAcceptedRaw": 1033831,
    "totalSubmissionRaw": 1459340,
    "acRate": "70.8%"
  },
  "topicTags": [
    {
      "name": "Binary Search",
      "slug": "binary-search"
    },
    {
      "name": "Bit Manipulation",
      "slug": "bit-manipulation"
    },
    {
      "name": "Tree",
      "slug": "tree"
    },
    {
      "name": "Binary Tree",
      "slug": "binary-tree"
    }
  ],
  "metaData": {
    "name": "countNodes",
    "params": [
      {
        "name": "root",
        "type": "TreeNode"
      }
    ],
    "return": {
      "type": "integer"
    }
  },
  "discussion_posts": [
    {
      "name": "Goblin_Cyanide",
      "year": 2023,
      "content": "Everyone saying this is easy should work on their reading comprehension. The question specifically states that we have to do it in less than O(N) time complexity and tree traversals take O(N) time. We have to do this in O(logn^2) time complexity and that is definitely not easy. LOL",
      "voteCount": 319
    },
    {
      "name": "ugonna100",
      "year": 2023,
      "content": "Why was this questions difficulty changed from Medium to Easy? This is not an easy problem.\\n\\nIt clearly asks for the most optimal solution which requires nested binary search. No interview is going to be satisfied by the default O(n) answer",
      "voteCount": 178
    },
    {
      "name": "adorabledev",
      "year": 2019,
      "content": "How is this even a medium?",
      "voteCount": 128
    },
    {
      "name": "LesterX",
      "year": 2023,
      "content": "How is this a easy?",
      "voteCount": 103
    },
    {
      "name": "priyankkoul1411",
      "year": 2021,
      "content": "If we know the height of the tree, the only other information needed to determine the number of nodes is the number of nodes in the last level. The rest of the levels are completely filled and it can be calculated just by knowing the value of the height of the tree.\\nDetermine the height of the tree by traversing the leftmost path, i.e, root to root->left to root->left->left and so on. This takes O(logn) time.\\nThen, we will binary search to determine which node is the last node in the last level. More precisely, we need to find the number of nodes in the last level.\\nWe initialize left = 0 and right = n/2-1 (this is the maximum number of nodes that the last level can have). Then, we use binary search to find whether the mid-th node exists in the tree (i.e. if it is non-null). Each of this operation takes O(logn) time.\\nIn this way find the right-most non-null node in the last level. There will be O(logn) such operations and hence, the total complexity amounts to O((logn)^2).",
      "voteCount": 94
    },
    {
      "name": "godshiva",
      "year": 2022,
      "content": "Something I found helpful.  If you put a 1 at the top of a complete binary tree and all left legs are a 0 and all right legs are a 1 and then you follow a path it will build a number (in binary).  That number will correspond to the count of the nodes in the tree if that path is the last node of a complete binary tree :)  Using this it was trivial to construct a \\'seek\\' function that took a node count number.",
      "voteCount": 41
    },
    {
      "name": "glugglug",
      "year": 2021,
      "content": "My O(log(n)^2) solution ends up faster than about 40% because faster solutions are submitted which are O(n), although n crosses log base 2(n) ^2 for n > ~30.  Although really there is a larger constant multiplier here too so more like n > ~100.\\n\\nTest cases with a larger tree would fix this.",
      "voteCount": 41
    },
    {
      "name": "rattlesnakesnladders",
      "year": 2024,
      "content": "This is not just not Easy, but also borderline Hard.",
      "voteCount": 31
    },
    {
      "name": "SlayerSv",
      "year": 2023,
      "content": "This is not an easy problem if you use algorithm that takes less than O(n)",
      "voteCount": 31
    },
    {
      "name": "SteveGan",
      "year": 2023,
      "content": "The problem should\\'ve clarified that nodes\\' value are in order, that the result of a level traversal would give the sequence [1, 2, 3, ..., n - 1, n]. Otherwise binary search will not work here.",
      "voteCount": 25
    }
  ]
}
