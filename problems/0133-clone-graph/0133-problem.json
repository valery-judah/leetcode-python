{
  "category": "",
  "id": "133",
  "name": "Clone Graph",
  "difficulty": "Medium",
  "leetcode_url": "https://leetcode.com/problems/clone-graph/",
  "slug": "clone-graph",
  "isPaidOnly": false,
  "tags": [
    "Hash Table",
    "Depth-First Search",
    "Breadth-First Search",
    "Graph"
  ],
  "similar_questions": [
    {
      "title": "Copy List with Random Pointer",
      "difficulty": "Medium",
      "slug": "copy-list-with-random-pointer"
    },
    {
      "title": "Clone Binary Tree With Random Pointer",
      "difficulty": "Medium",
      "slug": "clone-binary-tree-with-random-pointer"
    },
    {
      "title": "Clone N-ary Tree",
      "difficulty": "Medium",
      "slug": "clone-n-ary-tree"
    }
  ],
  "questionId": "133",
  "questionFrontendId": "133",
  "title": "Clone Graph",
  "titleSlug": "clone-graph",
  "content": "<p>Given a reference of a node in a <strong><a href=\"https://en.wikipedia.org/wiki/Connectivity_(graph_theory)#Connected_graph\" target=\"_blank\">connected</a></strong> undirected graph.</p>\n\n<p>Return a <a href=\"https://en.wikipedia.org/wiki/Object_copying#Deep_copy\" target=\"_blank\"><strong>deep copy</strong></a> (clone) of the graph.</p>\n\n<p>Each node in the graph contains a value (<code>int</code>) and a list (<code>List[Node]</code>) of its neighbors.</p>\n\n<pre>\nclass Node {\n    public int val;\n    public List&lt;Node&gt; neighbors;\n}\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>Test case format:</strong></p>\n\n<p>For simplicity, each node&#39;s value is the same as the node&#39;s index (1-indexed). For example, the first node with <code>val == 1</code>, the second node with <code>val == 2</code>, and so on. The graph is represented in the test case using an adjacency list.</p>\n\n<p><b>An adjacency list</b> is a collection of unordered <b>lists</b> used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.</p>\n\n<p>The given node will always be the first node with <code>val = 1</code>. You must return the <strong>copy of the given node</strong> as a reference to the cloned graph.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/11/04/133_clone_graph_question.png\" style=\"width: 454px; height: 500px;\" />\n<pre>\n<strong>Input:</strong> adjList = [[2,4],[1,3],[2,4],[1,3]]\n<strong>Output:</strong> [[2,4],[1,3],[2,4],[1,3]]\n<strong>Explanation:</strong> There are 4 nodes in the graph.\n1st node (val = 1)&#39;s neighbors are 2nd node (val = 2) and 4th node (val = 4).\n2nd node (val = 2)&#39;s neighbors are 1st node (val = 1) and 3rd node (val = 3).\n3rd node (val = 3)&#39;s neighbors are 2nd node (val = 2) and 4th node (val = 4).\n4th node (val = 4)&#39;s neighbors are 1st node (val = 1) and 3rd node (val = 3).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/01/07/graph.png\" style=\"width: 163px; height: 148px;\" />\n<pre>\n<strong>Input:</strong> adjList = [[]]\n<strong>Output:</strong> [[]]\n<strong>Explanation:</strong> Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> adjList = []\n<strong>Output:</strong> []\n<strong>Explanation:</strong> This an empty graph, it does not have any nodes.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the graph is in the range <code>[0, 100]</code>.</li>\n\t<li><code>1 &lt;= Node.val &lt;= 100</code></li>\n\t<li><code>Node.val</code> is unique for each node.</li>\n\t<li>There are no repeated edges and no self-loops in the graph.</li>\n\t<li>The Graph is connected and all nodes can be visited starting from the given node.</li>\n</ul>\n",
  "likes": 10263,
  "dislikes": 4106,
  "stats": {
    "totalAccepted": "1.7M",
    "totalSubmission": "2.7M",
    "totalAcceptedRaw": 1690090,
    "totalSubmissionRaw": 2671372,
    "acRate": "63.3%"
  },
  "topicTags": [
    {
      "name": "Hash Table",
      "slug": "hash-table"
    },
    {
      "name": "Depth-First Search",
      "slug": "depth-first-search"
    },
    {
      "name": "Breadth-First Search",
      "slug": "breadth-first-search"
    },
    {
      "name": "Graph",
      "slug": "graph"
    }
  ],
  "metaData": {
    "name": "cloneGraph",
    "params": [
      {
        "name": "edges",
        "type": "integer[][]"
      }
    ],
    "return": {
      "type": "boolean"
    },
    "languages": [
      "cpp",
      "java",
      "python",
      "csharp",
      "javascript",
      "python3",
      "golang",
      "swift",
      "kotlin",
      "ruby",
      "c",
      "scala",
      "php",
      "typescript"
    ],
    "manual": true,
    "typescriptCustomType": "class _Node {\n    val: number\n    neighbors: _Node[]\n\n    constructor(val?: number, neighbors?: _Node[]) {\n        this.val = (val===undefined ? 0 : val)\n        this.neighbors = (neighbors===undefined ? [] : neighbors)\n    }\n}\n"
  },
  "company_tag_stats": {
    "1": [
      {
        "taggedByAdmin": true,
        "name": "Meta",
        "slug": "facebook",
        "timesEncountered": 51
      }
    ]
  },
  "discussion_posts": [
    {
      "name": "karan_cpp_py",
      "year": 2023,
      "content": "Am I the only one who can\\'t understand the question even after going through it several times??",
      "voteCount": 436
    },
    {
      "name": "Zhu_xy",
      "year": 2018,
      "content": "??????????????\\nWhat does this question mean???",
      "voteCount": 179
    },
    {
      "name": "beginner_7",
      "year": 2020,
      "content": "It would be good also if the output would show your incorrect output, instead of just sentences \"Your clonned graph must contain all the nodes\". I have to copy the problem to IDE to see what is missing",
      "voteCount": 163
    },
    {
      "name": "qddpx",
      "year": 2014,
      "content": "What does undirected graph mean? It's a graph in which a node is a neighbor of its neighbors.\\nMany people would think the terrible {#} format is just for OJ's input/output. I was stuck for this reason for half an hour.\\n\\nWhy the question stress that the graph is undirected when it's actually directed?",
      "voteCount": 118
    },
    {
      "name": "maverick4242",
      "year": 2018,
      "content": "The description is poorly specified.  I was very confused why the example OJ serialization was being given, but figured it was an example of how to do.  I did _not_ expect that the expected clone output was to have the actual neighbor connections sorted in the label order.\\n\\nThat is to say, in a typical undirected graph, one expects that if 0 and 1 are connected, they both show up in each other\\'s neighbors list.  Whereas OJ is explicitly checking that 1 only shows up as a neighbor in 0\\'s neighbor list.\\n\\nAlso, the expected order of processing the clone is explicitly to be done in order of label.  So if it\\'s possible to process 2 or 5, then 2 must always be processed first, rather than 5 (even in the following scenario, if one were doing BFS, and had a graph like say\\n`{0,1,5#1,2#2,5#5} `, in BFS, 5 would be processed before 2, and even though that would produce an EQUAL VALID tree description, the OJ rejects this.\\n\\nThere is absolutely zero way anyone could have determined this from the very sparse description.  Either OJ needs to be made to accept topographically similar trees, or the description needs to make it clear what the expected output is, because there is no way anyone can figure that out, unless I am mistaken. \\n\\nYes, one part of interviews are to be able to deal with ambiguity and \"ask\" more questions.  That would be a perfect place for \"hints\" to provide clarification of assumptions, but an upsetting part of LeetCode is nobody seems interested in helping find the thought process and just wants a solution.  ",
      "voteCount": 80
    },
    {
      "name": "_Abhinav_",
      "year": 2023,
      "content": "Stupid Question. ",
      "voteCount": 74
    },
    {
      "name": "sudianskyi",
      "year": 2023,
      "content": "When people will stop posting solutions here? ",
      "voteCount": 73
    },
    {
      "name": "Rapethor",
      "year": 2023,
      "content": "WE\\'VE GOT YOU SURRENDERED ! SOLVE ANOTHER GRAPH PROBLEM\\n\\nI HATE GRAPHS\\nI HATE GRAPHS\\nI HATE GRAPHS",
      "voteCount": 69
    },
    {
      "name": "MeloWang0308",
      "year": 2023,
      "content": "lol, return copy.deepcopy(node), done. ",
      "voteCount": 37
    },
    {
      "name": "CHazyhabiT",
      "year": 2014,
      "content": "Well, I have some doubt about the graph representation in this problem, though it might not affect the solution to this problem. In this problem, we are asked to clone a undirected graph, which means for the pair of connected nodes, each one should be presented in the other's neighbors list. \\n\\n - For example: if there are two nodes 0 and 1 in a graph, and they are\\n   connected to each other, then the graph representation should be\\n   {0,1#1,0} \\n - So the test case in this problem, the graph\\n   {0,1,2#1,2#2,2} should be regarded as a directed graph.\\n\\nAs said before, the solution might not be affected no matter what the representation is, but I don't want to be confused by the understanding of graph representation. So tell me if my understanding is wrong. Thanks!",
      "voteCount": 21
    }
  ]
}
