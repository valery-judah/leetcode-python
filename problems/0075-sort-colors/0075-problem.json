{
  "category": "",
  "id": "75",
  "name": "Sort Colors",
  "difficulty": "Medium",
  "leetcode_url": "https://leetcode.com/problems/sort-colors/",
  "slug": "sort-colors",
  "isPaidOnly": false,
  "tags": [
    "Array",
    "Two Pointers",
    "Sorting"
  ],
  "similar_questions": [
    {
      "title": "Sort List",
      "difficulty": "Medium",
      "slug": "sort-list"
    },
    {
      "title": "Wiggle Sort",
      "difficulty": "Medium",
      "slug": "wiggle-sort"
    },
    {
      "title": "Wiggle Sort II",
      "difficulty": "Medium",
      "slug": "wiggle-sort-ii"
    }
  ],
  "questionId": "75",
  "questionFrontendId": "75",
  "title": "Sort Colors",
  "titleSlug": "sort-colors",
  "content": "<p>Given an array <code>nums</code> with <code>n</code> objects colored red, white, or blue, sort them <strong><a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\">in-place</a> </strong>so that objects of the same color are adjacent, with the colors in the order red, white, and blue.</p>\n\n<p>We will use the integers <code>0</code>, <code>1</code>, and <code>2</code> to represent the color red, white, and blue, respectively.</p>\n\n<p>You must solve this problem without using the library&#39;s sort function.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,0,2,1,1,0]\n<strong>Output:</strong> [0,0,1,1,2,2]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,0,1]\n<strong>Output:</strong> [0,1,2]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 300</code></li>\n\t<li><code>nums[i]</code> is either <code>0</code>, <code>1</code>, or <code>2</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong>&nbsp;Could you come up with a one-pass algorithm using only&nbsp;constant extra space?</p>\n",
  "likes": 20634,
  "dislikes": 734,
  "stats": {
    "totalAccepted": "3.2M",
    "totalSubmission": "4.7M",
    "totalAcceptedRaw": 3200893,
    "totalSubmissionRaw": 4692554,
    "acRate": "68.2%"
  },
  "topicTags": [
    {
      "name": "Array",
      "slug": "array"
    },
    {
      "name": "Two Pointers",
      "slug": "two-pointers"
    },
    {
      "name": "Sorting",
      "slug": "sorting"
    }
  ],
  "metaData": {
    "name": "sortColors",
    "params": [
      {
        "name": "nums",
        "type": "integer[]"
      }
    ],
    "return": {
      "type": "void"
    },
    "output": {
      "paramindex": 0
    },
    "manual": false
  },
  "company_tag_stats": {
    "1": [
      {
        "taggedByAdmin": false,
        "name": "Google",
        "slug": "google",
        "timesEncountered": 20
      },
      {
        "taggedByAdmin": true,
        "name": "Meta",
        "slug": "facebook",
        "timesEncountered": 15
      },
      {
        "taggedByAdmin": false,
        "name": "Amazon",
        "slug": "amazon",
        "timesEncountered": 13
      }
    ]
  },
  "discussion_posts": [
    {
      "name": "UNDeF1ND1",
      "year": 2023,
      "content": "I acually solved it using the library sort().\\n\\nnow i feel bad.  I am going to try to solve it without now.",
      "voteCount": 494
    },
    {
      "name": "ROHANMANNA",
      "year": 2024,
      "content": "LEETCODE TEST CASES BEFORE SUBMITTING \\uD83E\\uDD21\\uD83E\\uDD21\\uD83E\\uDD21,\\nLEETCODE TEST CASES AFTER SUBMITTING \\uD83D\\uDDFF\\uD83D\\uDDFF\\uD83D\\uDDFF.",
      "voteCount": 313
    },
    {
      "name": "ShashankChaturvedi",
      "year": 2023,
      "content": "the task is to bring all zeros to left and all twos to right. that\\'s it\\n\\ndetailed hint below\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n1)- use three pointers one for left end , one for right end and one for iteration.\\n2)-if you see 0 swap it with left pointer and increase the left pointer by one.\\n3)-if you see 2 swap it with right pointer and decrease right pointer by one.\\n4)-else increase the iterating pointer.\\n5)-run this loop while the iterating pointer<=right pointer.\\nright pointer=n-1\\nleft pointer=0\\niterating pointer =0 runs while it is<=right pointer.",
      "voteCount": 231
    },
    {
      "name": "xAdvitya",
      "year": 2023,
      "content": "Study about DNF algorithm ",
      "voteCount": 195
    },
    {
      "name": "timkillis",
      "year": 2019,
      "content": "I had a hard time grasping this one so I thought I\\'d write it down, maybe it will help you too.\\n\\nIterate over the array, maintaining two pointers, one at the \"low\" index, 0, and one at the \"high\", nums.length - 1.\\n\\nEverything to the left of low in the array and everything to the right of high in the array will be assumed sorted. As we iterate through the array, we update our pointers, taking account for two cases\\n\\nIf the index in the array is equal to 0, we swap that with our current low index and then increment the low index, since we know that everything to the left of that index is properly sorted.\\n\\nElse if the index in the array is equal to 2, we swap that with our current high index and decrement the high index, since everything to right of the high index is sorted. Also take care in this case to decrement i since we will want to reconsider the inserted element.\\n\\nWe\\'ve accounted for if the indexes are 0 or 2, the only other option is if the index is a 1, in which case we will just leave it in place.\\n\\nOur loop ends when we meet the high index, since we know everything to the right of high is properly sorted.\\n",
      "voteCount": 171
    },
    {
      "name": "SalvadorDali",
      "year": 2019,
      "content": "Example of overcomplication for a sake of overcomplication.\\n\\nNo matter how the one pass solution is implemented, it will be 2-3 times slower than the intuitive 2 pass solution. It provides zero benefits: being one pass it is not a streaming algorithm as it needs to access elements from some other positions.\\n\\nOn the other hand the drawbacks are clear: complex to understand, non-intuitive, 2-3 times slower. \\n\\nBoth counting and this take O(1) memory.",
      "voteCount": 131
    },
    {
      "name": "Hiding_as",
      "year": 2023,
      "content": "Just count the number of 0s 1s and 2s passing once. Rewrite the original array using the count as reference? ",
      "voteCount": 75
    },
    {
      "name": "kalebalti",
      "year": 2023,
      "content": "Isn\\'t it just fancy type of asking \"do any kind of sorting in increasing order\"?",
      "voteCount": 71
    },
    {
      "name": "chenon",
      "year": 2024,
      "content": "Today, I felt this medium was easier than yesterday\\'s easy.",
      "voteCount": 40
    },
    {
      "name": "niteshprimedev",
      "year": 2025,
      "content": "### Guys, helpful test cases ---------------->\\n\\n```\\n[0]\\n[2,0]\\n[0,0,0,1,1,1,2,2,2]\\n[2,2,2,0,0,0,1,1,1]\\n[2,2,1,1,0,0,0]\\n[2,1,2,2,2,2,0,0,0]\\n[2,2,2,2,2,1,0,0,1,1,0]\\n[2,2,2,1,1,0,0,1,0,1,0,2,1,0,2,1,0,2,1,1]\\n```\\n\\n**These test cases cover all scenarios**\\n- When only one color is there to sort\\n- When only two colors are there to sort\\n- When all three colors are sorted\\n- When both red and blue colors are sorted\\n- When all colors are sorted but rotated\\n- When only red color is sorted \\n- When only blue color is sorted\\n- When we have no color sorted\\n\\nI think I\\'ve covered all the scenarios, but do you still think I missed any test cases here?\\n\\nKindly please upvote only if you find it helpful so that others can see it as well and make use of it. :)",
      "voteCount": 35
    }
  ]
}
