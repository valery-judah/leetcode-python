{
  "category": "",
  "id": "416",
  "name": "Partition Equal Subset Sum",
  "difficulty": "Medium",
  "leetcode_url": "https://leetcode.com/problems/partition-equal-subset-sum/",
  "slug": "partition-equal-subset-sum",
  "isPaidOnly": false,
  "tags": [
    "Array",
    "Dynamic Programming"
  ],
  "similar_questions": [
    {
      "title": "Partition to K Equal Sum Subsets",
      "difficulty": "Medium",
      "slug": "partition-to-k-equal-sum-subsets"
    },
    {
      "title": "Minimize the Difference Between Target and Chosen Elements",
      "difficulty": "Medium",
      "slug": "minimize-the-difference-between-target-and-chosen-elements"
    },
    {
      "title": "Maximum Number of Ways to Partition an Array",
      "difficulty": "Hard",
      "slug": "maximum-number-of-ways-to-partition-an-array"
    },
    {
      "title": "Partition Array Into Two Arrays to Minimize Sum Difference",
      "difficulty": "Hard",
      "slug": "partition-array-into-two-arrays-to-minimize-sum-difference"
    },
    {
      "title": "Find Subarrays With Equal Sum",
      "difficulty": "Easy",
      "slug": "find-subarrays-with-equal-sum"
    },
    {
      "title": "Number of Great Partitions",
      "difficulty": "Hard",
      "slug": "number-of-great-partitions"
    },
    {
      "title": "Split With Minimum Sum",
      "difficulty": "Easy",
      "slug": "split-with-minimum-sum"
    }
  ],
  "questionId": "416",
  "questionFrontendId": "416",
  "title": "Partition Equal Subset Sum",
  "titleSlug": "partition-equal-subset-sum",
  "content": "<p>Given an integer array <code>nums</code>, return <code>true</code> <em>if you can partition the array into two subsets such that the sum of the elements in both subsets is equal or </em><code>false</code><em> otherwise</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,5,11,5]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> The array can be partitioned as [1, 5, 5] and [11].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,5]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> The array cannot be partitioned into equal sum subsets.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 200</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
  "likes": 13462,
  "dislikes": 290,
  "stats": {
    "totalAccepted": "1.3M",
    "totalSubmission": "2.7M",
    "totalAcceptedRaw": 1323044,
    "totalSubmissionRaw": 2711867,
    "acRate": "48.8%"
  },
  "topicTags": [
    {
      "name": "Array",
      "slug": "array"
    },
    {
      "name": "Dynamic Programming",
      "slug": "dynamic-programming"
    }
  ],
  "metaData": {
    "name": "canPartition",
    "params": [
      {
        "name": "nums",
        "type": "integer[]"
      }
    ],
    "return": {
      "type": "boolean"
    }
  },
  "company_tag_stats": {
    "1": [
      {
        "taggedByAdmin": false,
        "name": "Google",
        "slug": "google",
        "timesEncountered": 13
      }
    ]
  },
  "discussion_posts": [
    {
      "name": "HimanshuKhanchandani",
      "year": 2023,
      "content": "Just a funny observation: you can pass 122/141 test cases just by noting that if the sum is odd, it has to be false. ",
      "voteCount": 409
    },
    {
      "name": "Stomach_ache",
      "year": 2016,
      "content": "Hi guys,\\nI am so sorry for your inconvenience during working on this problem due to my carelessness. I will pay more attention and be more careful  when preparing test cases and solutions in the future. By the way, bugs have been fixed and more test cases have been added.\\n\\nBest Regards,\\nTong Wei",
      "voteCount": 262
    },
    {
      "name": "s3stan",
      "year": 2023,
      "content": "Little hint. The subset sum can only be the total sum divided by two.",
      "voteCount": 118
    },
    {
      "name": "DayDreamerr",
      "year": 2022,
      "content": "HINT: Try subset sum equal K then this problem is cakewalk level.",
      "voteCount": 97
    },
    {
      "name": "dhruvbala03",
      "year": 2024,
      "content": "This should be marked as hard.",
      "voteCount": 74
    },
    {
      "name": "Mohamad-Ilham-Ramadhan",
      "year": 2023,
      "content": "Some test cases:\\n[23,13,11,7,6,5,5] True\\n[1,1] True\\n[6,14,19,10,17,10,8,15,16,1,12,4,9,2,15] True\\n[4,10,7,9,7,1,11,9,13,15] True\\n[9,10,15,3,9,2,9,10,13,1] False\\n[100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,99,97] False",
      "voteCount": 56
    },
    {
      "name": "LeadingTheAbyss",
      "year": 2025,
      "content": "# \\uD83D\\uDE07 Actually Good Hints  \\n<details>  \\n  <summary><span style=\"font-size:20px;\"><strong>Hint 1: Base Case Check</strong></span></summary>  \\n  <span style=\"font-size:18px;\">\\n    If the total <code>sum</code> of the array is <strong>odd</strong>, then dividing it into two equal subsets is impossible. Return <code>false</code> immediately in such cases.\\n  </span>\\n</details>  \\n<br>\\n\\n<details>  \\n  <summary><span style=\"font-size:20px;\"><strong>Hint 2: Subset Sum Target</strong></span></summary>  \\n  <span style=\"font-size:18px;\">\\n    Set your goal as <code>targetSum = sum / 2</code>. Now the task becomes: \"Can I form a subset of <code>nums</code> that sums to <code>targetSum</code>?\"<br>\\nBecause if you find a subset with the sum upto <code>targetSum</code> then the remaining elements of the array with accumulate the other half of <code>targetSum</code>.  </span>\\n</details>  \\n<br>\\n\\n<details>  \\n  <summary><span style=\"font-size:20px;\"><strong>Hint 3: 0/1 Knapsack DP</strong></span></summary>  \\n  <span style=\"font-size:18px;\">\\n    <strong>Use a 1D DP array:</strong> The size of this array should be <code>targetSum + 1</code> and <code>dp[i]</code> is true if there\\'s a subset that sums to <code>i</code>. <br>Initialize <code>dp[0] = true</code>.<br><br>\\n    For each <code>element</code> in <code>nums</code>, update the DP array <strong>backwards</strong> : <br>  <strong>Pseudo Code</strong> \\u27F6\\n    <code>for i = target to num: dp[i] |= dp[i - num]</code>\\n  </span>\\n</details>  \\n<br>\\n\\n<details>  \\n  <summary><span style=\"font-size:20px;\"><strong>Hint 4: Why Backward Iteration?</strong></span></summary>  \\n  <span style=\"font-size:18px;\">\\n    If you go forward, you risk using the same element multiple times in one iteration. Going backward ensures each number is only considered only once per update round.\\n  </span>\\n</details>\\n",
      "voteCount": 54
    },
    {
      "name": "181vKiyGic",
      "year": 2025,
      "content": "In depth hints that will help you solve the entire problem. Use as many as needed. Please upvote this took a while \\u261D\\uFE0F\\uD83E\\uDD13\\n<details>\\n<summary>Hint 1</summary>\\nHow can we find the target number that the subsets should add to?\\n</details>\\n<details>\\n<summary>Hint 2</summary>\\nHow does the sum of the nums help us find our target number?\\n</details>\\n<details>\\n<summary>Hint 3</summary>\\nIf the sum of the nums are odd what does that mean?\\n</details>\\n<details>\\n<summary>Hint 4</summary>\\nIf the sum of the nums are odd we can return false\\n</details>\\n<details>\\n<summary>Hint 5</summary>\\nOur target number is the sum /  2\\n</details>\\n<details>\\n<summary>Hint 6</summary>\\nIf one subset is equal to the target number what does that mean about the rest of the numbers?\\n</details>\\n<details>\\n<summary>Hint 7</summary>\\nIf one subset is equal to the target the rest of the numbers will also be equal to the target.\\n</details>\\n<details>\\n<summary>Hint 8</summary>\\nThe new question is can we find a subset in nums that has a sum of our target number.\\n</details>\\n<details>\\n<summary>Hint 9</summary>\\nHow can we use dynamic programming to solve this problem?\\n</details>\\n<details>\\n<summary>Hint 10</summary>\\nMake a bool[ ] with length of target + 1 which will store all the sums that are possible so far. \\n</details>\\n<details>\\n<summary>Hint 11</summary>\\nWhich number will always be possible?\\n</details>\\n<details>\\n<summary>Hint 12</summary>\\nSet possible[0] to true\\n</details>\\n<details>\\n<summary>Hint 13</summary>\\nIf given a number in nums how will that effect which numbers are possible\\n</details>\\n<details>\\n<summary>Hint 14</summary>\\nif possible[i] is true then possible[i + num] should also be true\\n</details>\\n<details>\\n<summary>Hint 15</summary>\\nHow can we update our possible array when given a num?\\n</details>\\n<details>\\n<summary>Hint 16</summary>\\nIterate through the possible array back to front and if possible[i] == true then make possible[i + num] also true if it is in range.\\n</details>\\n<details>\\n<summary>Hint 17</summary>\\nDo the same for all numbers in nums\\n</details>\\n<details>\\n<summary>Hint 18</summary>\\nHow can we check if we CanPartition?\\n</details>\\n<details>\\n<summary>Hint 19</summary>\\nreturn possible[target]\\n</details>\\n<details>\\n<summary>Hint 20 - Entire Code in c#</summary>\\n<pre> \\npublic class Solution \\n{\\n    public bool CanPartition(int[] nums) \\n    {\\n        int target = nums.Sum();\\n\\n        if(target % 2 != 0)\\n        {\\n            return false;\\n        }\\n        target /= 2;\\n\\n        \\n        int n = target + 1;\\n        bool[] possible = new bool[n];\\n        possible[0] = true;\\n\\n        foreach(int num in nums)\\n        {\\n            for(int i=n-1; i >= 0; i--)\\n            {\\n                if(possible[i] && i + num < n)\\n                {\\n                    possible[i + num] = true;\\n                }\\n            }\\n        }\\n\\n        return possible[target];\\n    }\\n}\\n</pre>\\n</details>",
      "voteCount": 47
    },
    {
      "name": "isti",
      "year": 2025,
      "content": "Week of paid editorials.",
      "voteCount": 38
    },
    {
      "name": "ramchoudharyiitg",
      "year": 2025,
      "content": "[@LeetCode](/u/LeetCode) Dont be to freaking greedy. Open the editorials for POTD again please.",
      "voteCount": 26
    }
  ]
}
