{
  "category": "",
  "id": "1993",
  "name": "Operations on Tree",
  "difficulty": "Medium",
  "leetcode_url": "https://leetcode.com/problems/operations-on-tree/",
  "slug": "operations-on-tree",
  "isPaidOnly": false,
  "tags": [
    "Array",
    "Hash Table",
    "Tree",
    "Depth-First Search",
    "Breadth-First Search",
    "Design"
  ],
  "similar_questions": [
    {
      "title": "Throne Inheritance",
      "difficulty": "Medium",
      "slug": "throne-inheritance"
    }
  ],
  "questionId": "2104",
  "questionFrontendId": "1993",
  "title": "Operations on Tree",
  "titleSlug": "operations-on-tree",
  "content": "<p>You are given a tree with <code>n</code> nodes numbered from <code>0</code> to <code>n - 1</code> in the form of a parent array <code>parent</code> where <code>parent[i]</code> is the parent of the <code>i<sup>th</sup></code> node. The root of the tree is node <code>0</code>, so <code>parent[0] = -1</code> since it has no parent. You want to design a data structure that allows users to lock, unlock, and upgrade nodes in the tree.</p>\n\n<p>The data structure should support the following functions:</p>\n\n<ul>\n\t<li><strong>Lock:</strong> <strong>Locks</strong> the given node for the given user and prevents other users from locking the same node. You may only lock a node using this function if the node is unlocked.</li>\n\t<li><strong>Unlock: Unlocks</strong> the given node for the given user. You may only unlock a node using this function if it is currently locked by the same user.</li>\n\t<li><b>Upgrade</b><strong>: Locks</strong> the given node for the given user and <strong>unlocks</strong> all of its descendants <strong>regardless</strong> of who locked it. You may only upgrade a node if <strong>all</strong> 3 conditions are true:\n\t<ul>\n\t\t<li>The node is unlocked,</li>\n\t\t<li>It has at least one locked descendant (by <strong>any</strong> user), and</li>\n\t\t<li>It does not have any locked ancestors.</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>Implement the <code>LockingTree</code> class:</p>\n\n<ul>\n\t<li><code>LockingTree(int[] parent)</code> initializes the data structure with the parent array.</li>\n\t<li><code>lock(int num, int user)</code> returns <code>true</code> if it is possible for the user with id <code>user</code> to lock the node <code>num</code>, or <code>false</code> otherwise. If it is possible, the node <code>num</code> will become<strong> locked</strong> by the user with id <code>user</code>.</li>\n\t<li><code>unlock(int num, int user)</code> returns <code>true</code> if it is possible for the user with id <code>user</code> to unlock the node <code>num</code>, or <code>false</code> otherwise. If it is possible, the node <code>num</code> will become <strong>unlocked</strong>.</li>\n\t<li><code>upgrade(int num, int user)</code> returns <code>true</code> if it is possible for the user with id <code>user</code> to upgrade the node <code>num</code>, or <code>false</code> otherwise. If it is possible, the node <code>num</code> will be <strong>upgraded</strong>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/29/untitled.png\" style=\"width: 375px; height: 246px;\" />\n<pre>\n<strong>Input</strong>\n[&quot;LockingTree&quot;, &quot;lock&quot;, &quot;unlock&quot;, &quot;unlock&quot;, &quot;lock&quot;, &quot;upgrade&quot;, &quot;lock&quot;]\n[[[-1, 0, 0, 1, 1, 2, 2]], [2, 2], [2, 3], [2, 2], [4, 5], [0, 1], [0, 1]]\n<strong>Output</strong>\n[null, true, false, true, true, true, false]\n\n<strong>Explanation</strong>\nLockingTree lockingTree = new LockingTree([-1, 0, 0, 1, 1, 2, 2]);\nlockingTree.lock(2, 2);    // return true because node 2 is unlocked.\n                           // Node 2 will now be locked by user 2.\nlockingTree.unlock(2, 3);  // return false because user 3 cannot unlock a node locked by user 2.\nlockingTree.unlock(2, 2);  // return true because node 2 was previously locked by user 2.\n                           // Node 2 will now be unlocked.\nlockingTree.lock(4, 5);    // return true because node 4 is unlocked.\n                           // Node 4 will now be locked by user 5.\nlockingTree.upgrade(0, 1); // return true because node 0 is unlocked and has at least one locked descendant (node 4).\n                           // Node 0 will now be locked by user 1 and node 4 will now be unlocked.\nlockingTree.lock(0, 1);    // return false because node 0 is already locked.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == parent.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 2000</code></li>\n\t<li><code>0 &lt;= parent[i] &lt;= n - 1</code> for <code>i != 0</code></li>\n\t<li><code>parent[0] == -1</code></li>\n\t<li><code>0 &lt;= num &lt;= n - 1</code></li>\n\t<li><code>1 &lt;= user &lt;= 10<sup>4</sup></code></li>\n\t<li><code>parent</code> represents a valid tree.</li>\n\t<li>At most <code>2000</code> calls <strong>in total</strong> will be made to <code>lock</code>, <code>unlock</code>, and <code>upgrade</code>.</li>\n</ul>\n",
  "likes": 500,
  "dislikes": 83,
  "stats": {
    "totalAccepted": "22.2K",
    "totalSubmission": "50.3K",
    "totalAcceptedRaw": 22234,
    "totalSubmissionRaw": 50324,
    "acRate": "44.2%"
  },
  "topicTags": [
    {
      "name": "Array",
      "slug": "array"
    },
    {
      "name": "Hash Table",
      "slug": "hash-table"
    },
    {
      "name": "Tree",
      "slug": "tree"
    },
    {
      "name": "Depth-First Search",
      "slug": "depth-first-search"
    },
    {
      "name": "Breadth-First Search",
      "slug": "breadth-first-search"
    },
    {
      "name": "Design",
      "slug": "design"
    }
  ],
  "metaData": {
    "classname": "LockingTree",
    "constructor": {
      "params": [
        {
          "type": "integer[]",
          "name": "parent"
        }
      ]
    },
    "methods": [
      {
        "params": [
          {
            "type": "integer",
            "name": "num"
          },
          {
            "type": "integer",
            "name": "user"
          }
        ],
        "name": "lock",
        "return": {
          "type": "boolean"
        }
      },
      {
        "params": [
          {
            "type": "integer",
            "name": "num"
          },
          {
            "type": "integer",
            "name": "user"
          }
        ],
        "name": "unlock",
        "return": {
          "type": "boolean"
        }
      },
      {
        "params": [
          {
            "type": "integer",
            "name": "num"
          },
          {
            "type": "integer",
            "name": "user"
          }
        ],
        "name": "upgrade",
        "return": {
          "type": "boolean"
        }
      }
    ],
    "return": {
      "type": "boolean"
    },
    "systemdesign": true
  },
  "company_tag_stats": {
    "1": [
      {
        "taggedByAdmin": false,
        "name": "Juspay",
        "slug": "juspay",
        "timesEncountered": 11
      }
    ]
  },
  "discussion_posts": [
    {
      "name": "c4tdog",
      "year": 2023,
      "content": "pls note tree is not necessary binary as in example",
      "voteCount": 14
    },
    {
      "name": "dsapelnikov",
      "year": 2024,
      "content": "IMO the problem is pretty boring and lame.",
      "voteCount": 8
    },
    {
      "name": "webguru77777",
      "year": 2023,
      "content": "Here are some test cases if you need:\\n\\n```\\n[\"LockingTree\", \"lock\", \"unlock\", \"lock\", \"unlock\", \"lock\", \"upgrade\", \"lock\", \"unlock\", \"upgrade\", \"upgrade\", \"lock\", \"unlock\", \"unlock\", \"lock\", \"lock\", \"upgrade\", \"lock\", \"upgrade\", \"lock\"]\\n[[[-1, 0, 0, 2, 2, 3, 5, 0, 2, 0, 1, 7, 3, 8, 8, 0, 9, 4, 5, 5]], [4, 8], [3, 2], [0, 4], [9, 9], [0, 3], [0, 7], [5, 9], [4, 9], [0, 4], [5, 6], [4, 5], [4, 1], [5, 4], [2, 7], [9, 9], [2, 7], [2, 2], [1, 1], [8, 6]]\\n\\n[\"LockingTree\", \"unlock\", \"unlock\", \"lock\", \"upgrade\", \"lock\", \"lock\", \"upgrade\", \"lock\", \"unlock\", \"unlock\", \"upgrade\", \"lock\", \"upgrade\", \"unlock\", \"unlock\", \"upgrade\", \"upgrade\", \"unlock\", \"lock\"]\\n[[[-1, 0, 0, 0, 3, 4, 5, 5, 3, 5, 6, 10, 2, 0, 0, 10, 14, 6, 2, 18]], [2, 3], [1, 3], [2, 3], [2, 3], [1, 3], [1, 3], [1, 3], [2, 3], [0, 1], [3, 3], [1, 1], [2, 2], [0, 1], [0, 3], [1, 2], [2, 2], [2, 3], [3, 1], [1, 3]] \\n```\\n\\nPython code to generate test cases\\n\\n```\\nparentLength = 2000\\noperationLength = 2000\\nparents = [-1]\\nfor i in range(1, parentLength):\\n    parents.append(random.randint(0, i-1))\\n\\noperations = [\"LockingTree\"]\\nfor i in range(1, operationLength):\\n    operations.append(random.choice([\"lock\", \"unlock\", \"upgrade\"]))\\n\\nargs = [[parents]]\\nfor i in range(1, operationLength):\\n    args.append([random.randint(0, 5), random.randint(1, 5)])\\n\\nprint(json.dumps(operations))\\nprint(json.dumps(args))\\n```\\n\\n",
      "voteCount": 8
    },
    {
      "name": "lokiwayne",
      "year": 2024,
      "content": "came here because of Juspay",
      "voteCount": 7
    },
    {
      "name": "Piraisudan_02",
      "year": 2024,
      "content": "This is juspay round 2 question. NOTE",
      "voteCount": 6
    },
    {
      "name": "psionl0",
      "year": 2024,
      "content": "Not hard but quite involved and a little complicated with lots of conditions to deal with - especially when it comes to updating a node. \n\nNote that this is NOT a binary tree.",
      "voteCount": 3
    },
    {
      "name": "Shuvadeep_saha",
      "year": 2023,
      "content": "As per my understanding, the problem considers a node to be descendant of itself (at least this is when all the test cases pass). So when a node (that the user is trying to upgrade to) is locked this would also imply that at least one of its descendants are locked. Then how are all the three conditions in the `upgrade()` function satisfied? The fist condition `the node is unlocked` becomes void. Any suggestions anyone?",
      "voteCount": 3
    },
    {
      "name": "nikolatesla20",
      "year": 2024,
      "content": "Geez why we get a problem that we have to read a book-size description?",
      "voteCount": 2
    },
    {
      "name": "sulerhy",
      "year": 2024,
      "content": "Too frustrated to cover all cases and too boring to debug.\\nHow can I draw a google maps to check each node.\\nTest case 37",
      "voteCount": 2
    },
    {
      "name": "KarthikVarma19",
      "year": 2025,
      "content": "i have spent more than 2hrs but not able to implement upgrade() function \\n\\nMay be mark this question a hard:->",
      "voteCount": 1
    }
  ]
}
