{
  "category": "",
  "id": "201",
  "name": "Bitwise AND of Numbers Range",
  "difficulty": "Medium",
  "leetcode_url": "https://leetcode.com/problems/bitwise-and-of-numbers-range/",
  "slug": "bitwise-and-of-numbers-range",
  "isPaidOnly": false,
  "tags": [
    "Bit Manipulation"
  ],
  "similar_questions": [
    {
      "title": "Longest Nice Subarray",
      "difficulty": "Medium",
      "slug": "longest-nice-subarray"
    }
  ],
  "questionId": "201",
  "questionFrontendId": "201",
  "title": "Bitwise AND of Numbers Range",
  "titleSlug": "bitwise-and-of-numbers-range",
  "content": "<p>Given two integers <code>left</code> and <code>right</code> that represent the range <code>[left, right]</code>, return <em>the bitwise AND of all numbers in this range, inclusive</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> left = 5, right = 7\n<strong>Output:</strong> 4\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> left = 0, right = 0\n<strong>Output:</strong> 0\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> left = 1, right = 2147483647\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= left &lt;= right &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
  "likes": 4202,
  "dislikes": 315,
  "stats": {
    "totalAccepted": "474.7K",
    "totalSubmission": "987.2K",
    "totalAcceptedRaw": 474716,
    "totalSubmissionRaw": 987177,
    "acRate": "48.1%"
  },
  "topicTags": [
    {
      "name": "Bit Manipulation",
      "slug": "bit-manipulation"
    }
  ],
  "metaData": {
    "name": "rangeBitwiseAnd",
    "params": [
      {
        "name": "left",
        "type": "integer"
      },
      {
        "name": "right",
        "type": "integer"
      }
    ],
    "return": {
      "type": "integer"
    }
  },
  "discussion_posts": [
    {
      "name": "SSHshadow2222",
      "year": 2023,
      "content": "To get the result, you need to find the common prefix of left and right in their binary representation. `Hint`\\n\\n#### Example 1:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 01**01 (5)\\n> **0000 0000 0000 0000 0000 0000 0000 01**11 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0100 (4)\\n\\n\\n#### Example 2:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 011**0 (6)\\n> **0000 0000 0000 0000 0000 0000 0000 011**1 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 01100 (6)\\n\\n#### Example 3:\\n\\n> **0**000 0000 0000 0000 0000 0000 0000 0001 (1)\\n> **0**111 1111 1111 1111 1111 1111 1111 1111 (2147483647)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0000 (0)\\n\\n<br>\\n\\n*Don\\'t get overwhelmed by the examples. They are simply for visualization, and **everyone** understands things differently.*",
      "voteCount": 226
    },
    {
      "name": "ujjawal_OP",
      "year": 2023,
      "content": "bit manipulation is tough man\\ncan\\'t seem to optimize my brute force solution :)",
      "voteCount": 67
    },
    {
      "name": "hwc0919",
      "year": 2020,
      "content": "At first, it is easy to think of the brute force solution, BIT_AND all the way from `m` to `n`.\\n\\nBut we doesn\\'t need to calculate all of them.\\n\\nNotice: whenever we reach `t = 2^k`, the last `k` binary digits of `t` are all `0`!\\n\\nWhen we meet the first `2^k` above `m`, the result will be `0`. No matter what is following.\\n\\nLet `t` be the first `2^k` above `m`, that is,   `2^(k - 1) <= m < 2^k = t`\\n\\nIf `n >= t`, the result will be `0`.\\n\\nWe only need to calculate between [m, n], when `n < t`.\\n\\nAlso there are other better solutions, but this one is very easy to understand.",
      "voteCount": 64
    },
    {
      "name": "zendemion",
      "year": 2023,
      "content": "Excuse me?\n```\nTime Limit Exceeded 8268 / 8268 testcases passed\nLast Executed Input\n\nleft =\n```\nWhat happened there?",
      "voteCount": 40
    },
    {
      "name": "anwendeng",
      "year": 2024,
      "content": "Have a nice day!\nDon't try to use each element in [left, right] to do bitwise AND.\nIt is known that `x&(x-1)` = removing the rightmost signifcant bit in `x`",
      "voteCount": 38
    },
    {
      "name": "ayuranjan",
      "year": 2024,
      "content": "Before doing this question I would recommend learning about Brian Kernighan\\'s Algorithm which states that when we do bit wise and between n and n-1 , all the bits after the rightmost set bit (including the rightmost set bit) flip. Now solve[ this ]( https://leetcode.com/problems/hamming-distance/description/ )question first. Coming to the current question. We have to do bit wise and for a given range. Since we know this algo we can just start at the right and go on doing bitwise with n-1 element and make it new right until its lower than right. and then return the right. Now why does normal brute force doesn\\'t work but this turns out to be [100% Faster](https://leetcode.com/problems/bitwise-and-of-numbers-range/solutions/4759934/beats-100/)? This is because Brian Kernighan\\'s Algorithm clears the rightmost set bit in each iteration, which typically requires fewer iterations compared to iterating through the entire range. In fact the time complexity is dependent on number of bits. An integer n has log(n) bits, hence the worst case is O(log(n)). ",
      "voteCount": 31
    },
    {
      "name": "aitachii",
      "year": 2024,
      "content": "Approach 1: Iterate through the range `[left, right]`. Will give TLE\nTime Complexity: $O(right - left)$, Space Complexity: $O(1)$\n\nApproach 2: Shift both `left` and `right` to the right until `left == right`, while counting how many times you `shift`ed.\nTC: $O(log2(left) + log2(right))$, SC: $O(1)$\n\nApproach 3: Set the rightmost `1` bit of `right` to `0` until `right` and `left` share a common binary prefix (e.g. for `23` and `21`, their binaries are `10111` and `10101` and their common prefix is `101__`).\nTC: $O(popcount(right))$, SC: $O(1)$",
      "voteCount": 28
    },
    {
      "name": "wangzhangwu",
      "year": 2023,
      "content": "0. The bitwise operation `AND` results in a binary digit of `1` only when all the numbers involved have a binary digit of `1` in that specific position.\\n\\n1. Let us consider two numbers, denoted as `left` and `right.` If the condition `left != right` is true, it indicates that they differ by at least one unit. This implies the existence of a number between them, whose binary representation ends with a digit of `0.`\\n\\n2. Consequently, whenever we encounter the condition `left != right,` we proceed to right-shift both numbers by one position. This action aligns with the aforementioned observation, ensuring that the last digit is consistently `0.` Simultaneously, we keep track of the count of `0s` towards the right. Upon reaching a position where `left == right,` we terminate the process. At this point, all the digits up to that position remain unchanged. We then append `count` number of `0s` to obtain the desired number.",
      "voteCount": 24
    },
    {
      "name": "mstuebs",
      "year": 2024,
      "content": "These testcases saved me from submitting TLE. Hope they help you as well:\n```\n2\n25\n14\n28\n43\n60\n25\n35\n4194304\n134217709\n536870913\n1073741804\n2097152\n8388583\n268435456\n1073741822\n```\nAs always the code for generating these can be found at https://github.com/mquintus/l33tcode-testcase-generator",
      "voteCount": 13
    },
    {
      "name": "RazPatel",
      "year": 2024,
      "content": "The loop while right > left: continues as long as right is greater than left.\\n\\nInside the loop, right = right & (right - 1) turns off the rightmost 1-bit in right. This operation works because subtracting 1 from a number flips all the bits after the rightmost 1-bit (including the rightmost 1-bit itself), \\nand ANDing it with the original number turns off just this rightmost 1-bit.\\n\\nThe loop stops when right is no longer greater than left, meaning we\\'ve effectively reduced right to its largest value that is still within the range and shares the common prefix with left.\\n\\nIt returns right, which, at this point, represents the bitwise AND of all numbers in the range.",
      "voteCount": 13
    }
  ]
}
