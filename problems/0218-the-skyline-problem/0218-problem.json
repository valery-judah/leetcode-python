{
  "category": "",
  "id": "218",
  "name": "The Skyline Problem",
  "difficulty": "Hard",
  "leetcode_url": "https://leetcode.com/problems/the-skyline-problem/",
  "slug": "the-skyline-problem",
  "isPaidOnly": false,
  "tags": [
    "Array",
    "Divide and Conquer",
    "Binary Indexed Tree",
    "Segment Tree",
    "Line Sweep",
    "Heap (Priority Queue)",
    "Ordered Set"
  ],
  "similar_questions": [
    {
      "title": "Falling Squares",
      "difficulty": "Hard",
      "slug": "falling-squares"
    },
    {
      "title": "Shifting Letters II",
      "difficulty": "Medium",
      "slug": "shifting-letters-ii"
    }
  ],
  "questionId": "218",
  "questionFrontendId": "218",
  "title": "The Skyline Problem",
  "titleSlug": "the-skyline-problem",
  "content": "<p>A city&#39;s <strong>skyline</strong> is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Given the locations and heights of all the buildings, return <em>the <strong>skyline</strong> formed by these buildings collectively</em>.</p>\n\n<p>The geometric information of each building is given in the array <code>buildings</code> where <code>buildings[i] = [left<sub>i</sub>, right<sub>i</sub>, height<sub>i</sub>]</code>:</p>\n\n<ul>\n\t<li><code>left<sub>i</sub></code> is the x coordinate of the left edge of the <code>i<sup>th</sup></code> building.</li>\n\t<li><code>right<sub>i</sub></code> is the x coordinate of the right edge of the <code>i<sup>th</sup></code> building.</li>\n\t<li><code>height<sub>i</sub></code> is the height of the <code>i<sup>th</sup></code> building.</li>\n</ul>\n\n<p>You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height <code>0</code>.</p>\n\n<p>The <strong>skyline</strong> should be represented as a list of &quot;key points&quot; <strong>sorted by their x-coordinate</strong> in the form <code>[[x<sub>1</sub>,y<sub>1</sub>],[x<sub>2</sub>,y<sub>2</sub>],...]</code>. Each key point is the left endpoint of some horizontal segment in the skyline except the last point in the list, which always has a y-coordinate <code>0</code> and is used to mark the skyline&#39;s termination where the rightmost building ends. Any ground between the leftmost and rightmost buildings should be part of the skyline&#39;s contour.</p>\n\n<p><b>Note:</b> There must be no consecutive horizontal lines of equal height in the output skyline. For instance, <code>[...,[2 3],[4 5],[7 5],[11 5],[12 7],...]</code> is not acceptable; the three lines of height 5 should be merged into one in the final output as such: <code>[...,[2 3],[4 5],[12 7],...]</code></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/01/merged.jpg\" style=\"width: 800px; height: 331px;\" />\n<pre>\n<strong>Input:</strong> buildings = [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]\n<strong>Output:</strong> [[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]\n<strong>Explanation:</strong>\nFigure A shows the buildings of the input.\nFigure B shows the skyline formed by those buildings. The red points in figure B represent the key points in the output list.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> buildings = [[0,2,3],[2,5,3]]\n<strong>Output:</strong> [[0,3],[5,0]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= buildings.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= left<sub>i</sub> &lt; right<sub>i</sub> &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>1 &lt;= height<sub>i</sub> &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>buildings</code> is sorted by <code>left<sub>i</sub></code> in&nbsp;non-decreasing order.</li>\n</ul>\n",
  "likes": 6110,
  "dislikes": 280,
  "stats": {
    "totalAccepted": "329K",
    "totalSubmission": "743.2K",
    "totalAcceptedRaw": 328985,
    "totalSubmissionRaw": 743238,
    "acRate": "44.3%"
  },
  "topicTags": [
    {
      "name": "Array",
      "slug": "array"
    },
    {
      "name": "Divide and Conquer",
      "slug": "divide-and-conquer"
    },
    {
      "name": "Binary Indexed Tree",
      "slug": "binary-indexed-tree"
    },
    {
      "name": "Segment Tree",
      "slug": "segment-tree"
    },
    {
      "name": "Line Sweep",
      "slug": "line-sweep"
    },
    {
      "name": "Heap (Priority Queue)",
      "slug": "heap-priority-queue"
    },
    {
      "name": "Ordered Set",
      "slug": "ordered-set"
    }
  ],
  "metaData": {
    "name": "getSkyline",
    "params": [
      {
        "name": "buildings",
        "type": "integer[][]"
      }
    ],
    "return": {
      "type": "list<list<integer>>",
      "colsize": 2,
      "dealloc": true
    }
  },
  "discussion_posts": [
    {
      "name": "asim35",
      "year": 2023,
      "content": "Where on earth have I come!",
      "voteCount": 50
    },
    {
      "name": "yfcheng",
      "year": 2016,
      "content": "Sweepline is used in solving the problem.  `List<int[]> height` is used to save each of the line segments including both start and end point.  The trick here is to set the start segment as negative height.  This has a few good uses:  \\n\\nfirst, make sure the start segment comes before the end one after sorting.\\n\\nsecond, when pushing into the queue, it is very each to distinguish either to add or remove a segment.\\n\\nlastly, when the two adjacent building share same start and end x value, the next start segment always come before due to the negative height, this makes sure that when we peek the queue, we always get the value we are supposed to get.  When the first building is lower, when we peek the queue, we get the height of the second building, and the first building will be removed in the next round of iteration.  When the second building is lower, the first peek returns the first building and since it equals to `prev`, the height will not be added.",
      "voteCount": 42
    },
    {
      "name": "MohamedHossam",
      "year": 2022,
      "content": "As the title says I feel like If this problem comes in an interview & I have never seen it before , I would never be able to solve, how do you come up with the logic to solve the problem & is there are any problems that is similar to this one ?",
      "voteCount": 41
    },
    {
      "name": "shshaggarwal7",
      "year": 2023,
      "content": "There should be 2 category in hard, one is hard, another one could be super hard and this problem should fall into super hard category.",
      "voteCount": 38
    },
    {
      "name": "StefanPochmann",
      "year": 2015,
      "content": "The two by far fastest reported times so far are for Python solutions. As much as I'd like to think Python is faster for once, I gotta admit I now doubt it. I just tested my Python solution and two posted C++ solutions on my own PC on a large test case, and the C++ solutions were far faster. Like factor 20. At the OJ, it's the reverse - my Python solution is far faster. Like a factor of 5. Together, that's a mysterious factor 100 (!) between my PC/test and the OJ that I can't explain.\\n\\nWhat's going on? Are the C++/Java solutions given harder test cases here? The number is the same, 32 test cases. Or is the compilation time included? Or is it something else?",
      "voteCount": 22
    },
    {
      "name": "ashutosh21",
      "year": 2019,
      "content": "Could someone explain a situation where stack will not work?\\nHere is the algorithm\\n\\n(1) Sort the input vector based on first coordinate.\\n(2) Start with the first interval say current.\\n(3) If the start of the next interval overlaps with the current interval and also has a higher height, then push the current interval in the stack and set the current to the next interval. Or if the height of the next interval is lesser but end point is after the current interval, then push the next interval to the stack.\\n(4) When a current interval ends, then pop the interval from the stack and make it the current.\\n(5) Repeat the steps 1-4 until all the intervals in the input vector are processed.",
      "voteCount": 10
    },
    {
      "name": "hf_fl_09",
      "year": 2022,
      "content": "My solution is faulty and fails in the test case: buildings = [[0,7,3],[2,5,5],[5,10,5]]. But it gets accepted by Leetcode. \\n\\nThis test case has been submitted to Leetcode.\\n\\n![image](https://assets.leetcode.com/users/images/fd1ee36c-150b-40a8-ab11-5e306094b534_1655412051.8013215.png)\\n",
      "voteCount": 6
    },
    {
      "name": "harshal_yallewar",
      "year": 2022,
      "content": "// we are seperating starting coordinate with height and ending coordinate with height for each buildings so that we would be getting to know that which builder has ended and which not by our algorithm. and to know which is starting and which is ending we are making starting coordinates height to negative so that we can detect it.\\n\\n// we also have to sort the seperated arrays of coordinates with heights to make sure we are making outline in ongo means in going from left to right.\\n\\n// we also know that we are only changing our height on starting or ending coordinate of any building.\\n\\n// now run loop on that list and if it is starting coordinate then add it to priorityqueue(max) else remove starting from prorityqueue as it got ended.\\n\\n// now if previous is not equal to current max from PQ then add to our ans . beacause prev value is max of PQ before adding current height so if they get equal means previous value before adding it to pq is same as after adding means either building is same as prev or it is smaller to make outline so we will not add this answer.\\n\\n// CAse : when suppose ending points are on same coordinate.so if in that if bigger heights ends comes first then it get removed and we jump on to second max for ans but that is wrong that second max is our smaller building so thats why we have kept on increasing basis of heights when end points are same so this case is solved using that.\\n\\n// Intuition: we are just maintaing the heights and if any new heights comes then we are adding it to ans and making sure that same heights change should not get added to ans.\\n\\n// we know the fact that all the heights of buildings present in priorityqueue are not ended yet so they are there.",
      "voteCount": 4
    },
    {
      "name": "tpatty",
      "year": 2017,
      "content": "When I first read this problem, I think this is very similar to the problem of finding the convex hull of a set of points. The optimal solution to do this is O(nlogn). I haven't code it up yet, but from reading what's on the discussion, it seems that O(nlogn) is the best run time. It might be an overkill to think this way.",
      "voteCount": 3
    },
    {
      "name": "yunduleet",
      "year": 2017,
      "content": "Given the Notes below:\\n\\nThe number of buildings in any input list is guaranteed to be in the range [0, 10000].\\n**The input list is already sorted in ascending order by the left x position Li.**\\nThe output list must be sorted by the x position.\\nThere must be no consecutive horizontal lines of equal height in the output skyline. For instance, [...[2 3], [4 5], [7 5], [11 5], [12 7]...] is not acceptable; the three lines of height 5 should be merged into one in the final output as such: [...[2 3], [4 5], [12 7], ...]",
      "voteCount": 3
    }
  ]
}
