{
  "category": "",
  "id": "332",
  "name": "Reconstruct Itinerary",
  "difficulty": "Hard",
  "leetcode_url": "https://leetcode.com/problems/reconstruct-itinerary/",
  "slug": "reconstruct-itinerary",
  "isPaidOnly": false,
  "tags": [
    "Depth-First Search",
    "Graph",
    "Eulerian Circuit"
  ],
  "similar_questions": [
    {
      "title": "Longest Common Subpath",
      "difficulty": "Hard",
      "slug": "longest-common-subpath"
    },
    {
      "title": "Valid Arrangement of Pairs",
      "difficulty": "Hard",
      "slug": "valid-arrangement-of-pairs"
    }
  ],
  "questionId": "332",
  "questionFrontendId": "332",
  "title": "Reconstruct Itinerary",
  "titleSlug": "reconstruct-itinerary",
  "content": "<p>You are given a list of airline <code>tickets</code> where <code>tickets[i] = [from<sub>i</sub>, to<sub>i</sub>]</code> represent the departure and the arrival airports of one flight. Reconstruct the itinerary in order and return it.</p>\n\n<p>All of the tickets belong to a man who departs from <code>&quot;JFK&quot;</code>, thus, the itinerary must begin with <code>&quot;JFK&quot;</code>. If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.</p>\n\n<ul>\n\t<li>For example, the itinerary <code>[&quot;JFK&quot;, &quot;LGA&quot;]</code> has a smaller lexical order than <code>[&quot;JFK&quot;, &quot;LGB&quot;]</code>.</li>\n</ul>\n\n<p>You may assume all tickets form at least one valid itinerary. You must use all the tickets once and only once.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/14/itinerary1-graph.jpg\" style=\"width: 382px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> tickets = [[&quot;MUC&quot;,&quot;LHR&quot;],[&quot;JFK&quot;,&quot;MUC&quot;],[&quot;SFO&quot;,&quot;SJC&quot;],[&quot;LHR&quot;,&quot;SFO&quot;]]\n<strong>Output:</strong> [&quot;JFK&quot;,&quot;MUC&quot;,&quot;LHR&quot;,&quot;SFO&quot;,&quot;SJC&quot;]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/14/itinerary2-graph.jpg\" style=\"width: 222px; height: 230px;\" />\n<pre>\n<strong>Input:</strong> tickets = [[&quot;JFK&quot;,&quot;SFO&quot;],[&quot;JFK&quot;,&quot;ATL&quot;],[&quot;SFO&quot;,&quot;ATL&quot;],[&quot;ATL&quot;,&quot;JFK&quot;],[&quot;ATL&quot;,&quot;SFO&quot;]]\n<strong>Output:</strong> [&quot;JFK&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;SFO&quot;]\n<strong>Explanation:</strong> Another possible reconstruction is [&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;ATL&quot;,&quot;SFO&quot;] but it is larger in lexical order.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= tickets.length &lt;= 300</code></li>\n\t<li><code>tickets[i].length == 2</code></li>\n\t<li><code>from<sub>i</sub>.length == 3</code></li>\n\t<li><code>to<sub>i</sub>.length == 3</code></li>\n\t<li><code>from<sub>i</sub></code> and <code>to<sub>i</sub></code> consist of uppercase English letters.</li>\n\t<li><code>from<sub>i</sub> != to<sub>i</sub></code></li>\n</ul>\n",
  "likes": 6204,
  "dislikes": 1915,
  "stats": {
    "totalAccepted": "510.9K",
    "totalSubmission": "1.2M",
    "totalAcceptedRaw": 510936,
    "totalSubmissionRaw": 1166054,
    "acRate": "43.8%"
  },
  "topicTags": [
    {
      "name": "Depth-First Search",
      "slug": "depth-first-search"
    },
    {
      "name": "Graph",
      "slug": "graph"
    },
    {
      "name": "Eulerian Circuit",
      "slug": "eulerian-circuit"
    }
  ],
  "metaData": {
    "name": "findItinerary",
    "params": [
      {
        "name": "tickets",
        "type": "list<list<string>>"
      }
    ],
    "return": {
      "type": "list<string>"
    }
  },
  "company_tag_stats": {
    "1": [
      {
        "taggedByAdmin": false,
        "name": "Pinterest",
        "slug": "pinterest",
        "timesEncountered": 14
      }
    ]
  },
  "discussion_posts": [
    {
      "name": "TangoBee",
      "year": 2023,
      "content": "ME:\\n![LeetCode Hardcore](https://i.imgflip.com/7z2hed.jpg)",
      "voteCount": 616
    },
    {
      "name": "salilrr",
      "year": 2016,
      "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nHow could \"NRT\" have a higher lexical ordering than \"KUL\"?",
      "voteCount": 171
    },
    {
      "name": "jwseph",
      "year": 2023,
      "content": "It\\'s not the weekend yet...",
      "voteCount": 63
    },
    {
      "name": "soham6",
      "year": 2016,
      "content": "When input is [ [\"JFK\",\"LHR\"] ,[\"JFK\",\"MUC\"] ]\\n\\nthe output expected is [\"JFK\", \"LHR\",\"MUC\" ]\\n\\nthis is wrong because the person does not have a ticket from LHR to MUC at all! where did the concept of \"from\" and \"to\" go ??",
      "voteCount": 48
    },
    {
      "name": "anwendeng",
      "year": 2023,
      "content": "That's Euler's path problem, probably for finding path.\nThe initial v   must have indeg(v)+1=outdeg(v) or indeg(v)=outdeg(v) (if an Euler cycle) the terminal vertex w has indeg(w)=outdeg(w)+1 or indeg(w)=outdeg(w) (if an Euler cycle v=w)\nFor other vertex vi has indeg(vi)=outdeg(vi).\nHopefully, it's useful for solving question\nProvide a solution using priority_queue different from others.\nSolve Leetcode 2097. Valid Arrangement of Pairs!!!\n# KÃ¶nigsberg  7 bridges problem\n![images.jfif](https://assets.leetcode.com/users/images/44b9b15a-6e6b-4ee1-bdff-95c952ff421d_1694703689.5281713.jpeg)",
      "voteCount": 33
    },
    {
      "name": "yashm277",
      "year": 2024,
      "content": "The reason a topo sort doesnt work here is primarily due to the presence of cycles.",
      "voteCount": 29
    },
    {
      "name": "gogoalexy",
      "year": 2024,
      "content": "For whom getting 80/81 TLE with backtracking, try to avoid searching already failed paths. If DFS shows edge **AAA->BBB** is not for the current step, then we shoud skip all the following **AAA->BBB** edges in the current loop.",
      "voteCount": 27
    },
    {
      "name": "lolok123",
      "year": 2020,
      "content": "If the cities/airports are considered the nodes of a graph and the tickets from one city to another the directed edges of this graph, this problem reduces to that of finding an Eulerian path in a directed graph.\\nFirst consider the related problem of finding an Eulerian circuit in the graph. There are multiple algorithms proposed for this, one of them follows:\\n**Algorithm 1**\\n1. Choose any starting vertex.\\n2. Find any cycle starting and ending at this vertex.\\n3. Find the Eulerian circuit starting at this vertex, after removing all the edges in the cycle chosen in the previous step.\\n4. Prepend all the edges in this cycle to the path found in the previous step.\\n5. The path so obtained is an Eulerian circuit in this graph.\\n\\nAssume a fixed starting vertex. Of all the circuits possible starting and ending at this vertex, one of them must be the lexicographical smallest (the set of all Eulerian circuits is finite as all the edges can be traversed exactly once, and thus this set is a subset of all permutations of the edges, which is finite; and the lexicographical order is a total order). This can be found greedily.\\nThe algorithm is as follows:\\n**Algorithm 2**\\n1. Choose the lexicographically smallest cycle passing through the starting vertex.\\n2. Remove all edges in this cycle from the graph. Find the lexicographically smallest Eulerian circuit in the remaining graph.\\n3. Prepend the edges in the cycle in step 2 to the circuit in step 3.\\n4. The circuit so obtained is the Eulerian circuit of the graph.\\n\\nThis greedy algorithm is correct as it satisfies the two properties of a greedy algorithm.\\n1. Greedy choice: \\n\\tConsider the first cycle in the lexicographically smallest circuit. It is either the same cycle chosen by Algorithm 2, or it is a lexicographically larger cycle. If it is a lexicographically larger cycle, then it is a part of a lexicographically larger circuit than the circuit produced by this algorithm; a contradiction. Thus it must be the same cycle. Hence, a solution with the greedy choice exists.\\n2. Optimal substructure:\\n\\tConsider an optimal circuit for the subproblem. It must consist entirely of cycles not sharing any edges with the cycle chosen by Algorithm 2. Prepending this cycle to the circuit gives a circuit lexicographically lesser than or equal to that proposed in the greedy choice section. Since that circuit was the lexicographically smallest, so must this.\\n\\t\\nThus this algorithm is correct.\\n\\nNow to the original problem. An Eulerian path is clearly made up of one path connecting two vertices, on each of whose vertices there are Eulerian circuits, possibly empty. Thus the final algorithm:\\n\\n**Algorithm 3**\\n1. Let the starting node be the one corresponding to JFK.\\n2. Perform a DFS from this node choosing the lexicographically smallest target city at each stage, removing each edge from the graph as it is traversed and storing it separately. Some cycles may be found in this process. It is of no concern.\\n3. At some point, an edge will be reached from where there are no outgoing edges. There may have been edges coming into and going out of this node earlier, which were removed and stored earlier. Also there must have been exactly one more incoming edge than there were outgoing edges. This node exists because the question guarantees the existence of an Eulerian path, and it is a property of Eulerian paths that such a node must exist. In fact, there should also be a node with one extra outgoing edge, which in this question is the node corresponding to JFK.\\n4. Having found the path connecting the starting and ending vertices of the Eulerian path, the rest of the edges must form Eulerian sub-circuits, the lexicographically smallest of which can be found by Algorithm 2. Also, these sub-circuits must be \"attached\" at the last occurrence of the vertex in the path found in step 3, as the edges chosen in step 2 were the lexicographically smallest, and must come before the edges in this sub-circuit.\\n5. This way, the lexicographically smallest Eulerian circuit is formed.\\n\\nThis algorithm can be easily implemented using a stack.",
      "voteCount": 24
    },
    {
      "name": "maxtang",
      "year": 2016,
      "content": "Input:\\n[[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput:\\n[\"ATL\",\"JFK\",\"ATL\"]\\nExpected:\\n[\"JFK\",\"ATL\",\"JFK\"]\\n\\nCould some one explain the output of this test case for me?",
      "voteCount": 17
    },
    {
      "name": "JerryLife",
      "year": 2023,
      "content": "Why does the problem description never mention that there are *duplicate* edges?\\n\\n`[[\"EZE\",\"AXA\"],[\"TIA\",\"ANU\"],[\"ANU\",\"JFK\"],[\"JFK\",\"ANU\"],[\"ANU\",\"EZE\"],[\"TIA\",\"ANU\"],[\"AXA\",\"TIA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"TIA\"],[\"JFK\",\"TIA\"]]`",
      "voteCount": 12
    }
  ]
}
