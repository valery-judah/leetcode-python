{
  "category": "",
  "id": "154",
  "name": "Find Minimum in Rotated Sorted Array II",
  "difficulty": "Hard",
  "leetcode_url": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/",
  "slug": "find-minimum-in-rotated-sorted-array-ii",
  "isPaidOnly": false,
  "tags": [
    "Array",
    "Binary Search"
  ],
  "similar_questions": [
    {
      "title": "Find Minimum in Rotated Sorted Array",
      "difficulty": "Medium",
      "slug": "find-minimum-in-rotated-sorted-array"
    }
  ],
  "questionId": "154",
  "questionFrontendId": "154",
  "title": "Find Minimum in Rotated Sorted Array II",
  "titleSlug": "find-minimum-in-rotated-sorted-array-ii",
  "content": "<p>Suppose an array of length <code>n</code> sorted in ascending order is <strong>rotated</strong> between <code>1</code> and <code>n</code> times. For example, the array <code>nums = [0,1,4,4,5,6,7]</code> might become:</p>\n\n<ul>\n\t<li><code>[4,5,6,7,0,1,4]</code> if it was rotated <code>4</code> times.</li>\n\t<li><code>[0,1,4,4,5,6,7]</code> if it was rotated <code>7</code> times.</li>\n</ul>\n\n<p>Notice that <strong>rotating</strong> an array <code>[a[0], a[1], a[2], ..., a[n-1]]</code> 1 time results in the array <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code>.</p>\n\n<p>Given the sorted rotated array <code>nums</code> that may contain <strong>duplicates</strong>, return <em>the minimum element of this array</em>.</p>\n\n<p>You must decrease the overall operation steps as much as possible.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [1,3,5]\n<strong>Output:</strong> 1\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [2,2,2,0,1]\n<strong>Output:</strong> 0\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 5000</code></li>\n\t<li><code>-5000 &lt;= nums[i] &lt;= 5000</code></li>\n\t<li><code>nums</code> is sorted and rotated between <code>1</code> and <code>n</code> times.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> This problem is similar to&nbsp;<a href=\"https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/\" target=\"_blank\">Find Minimum in Rotated Sorted Array</a>, but&nbsp;<code>nums</code> may contain <strong>duplicates</strong>. Would this affect the runtime complexity? How and why?</p>\n\n<p>&nbsp;</p>\n",
  "likes": 4960,
  "dislikes": 510,
  "stats": {
    "totalAccepted": "555.6K",
    "totalSubmission": "1.3M",
    "totalAcceptedRaw": 555611,
    "totalSubmissionRaw": 1256835,
    "acRate": "44.2%"
  },
  "topicTags": [
    {
      "name": "Array",
      "slug": "array"
    },
    {
      "name": "Binary Search",
      "slug": "binary-search"
    }
  ],
  "metaData": {
    "name": "findMin",
    "params": [
      {
        "name": "nums",
        "type": "integer[]"
      }
    ],
    "return": {
      "type": "integer"
    }
  },
  "discussion_posts": [
    {
      "name": "Msey",
      "year": 2023,
      "content": "I\\'m not sure that FAANG will make you an offer after one-liner min() solution :)",
      "voteCount": 89
    },
    {
      "name": "llaki",
      "year": 2018,
      "content": "Let\\'s say the input has N elements, (N-1) of which is 2 and the remaining one is equal to 1. (something like this: [2, 2,  ...  2, 1, 2, 2, ... 2] ). Note that 1 could be sitting on any index and it would still be a valid input. It\\'s clear that we can\\'t find on which index exactly does 1 sit without possibly having to look at all indices, which is O(n). It means that any correct code for this problem will be worst case linear. On the other hand, it\\'s trivial to write linear solution.",
      "voteCount": 44
    },
    {
      "name": "Cong2017",
      "year": 2019,
      "content": "I saw many of you guys had got an good intuition of why an worst-case O(log N) algorithm  is unlikely to be true, but lacks of a formal proof. So in this post, I\\'ll try to provide  an simple but rigorous proof to show why any algorithm with a better worst-case running time than O(N) doesn\\'t exist.\\n\\nNow suppose someone, say, Alice, claims that she has found an algorithm that can beat O(N) and always return the right answer.  To convince her that she\\'s wrong, I invited her to play a little game, during which I\\'ll show you how to construct inputs that would foil her algorithm, by using a simple lower bound proof technique called **Adversary Argument**.\\n\\n\\nAt the begining of this game, I secretly pick an input, *V*,  which is an vector of integers with length *N*. In the begining Alice knows nothing about the *V*, except it consists of *N* integers. The game works in stages, in each stage, Alice tells me a entry number of the vector and I tells her the corresponding content in that entry. Note that at any stage, the information(knowledge) about the input that Alice knows and only knows, is the contents of all entries that she has checked in previous stage and the vector length *N*. More formally, in each stage,\\n1. Based her so-far information, Alice either tells me the of entry number *i* that she wants to check in this stage, or she yields her answer.\\n2. If Alice gives the entry number *i*, I tell her the corresponding *V[i]*. Otherwise I\\'ll check whether her answer is indeed the minimum of *V*.\\n\\nAlice wins if she get the right answer within less than *N* stages, otherwise I win. Note that if Alice\\'s algorithm does exists, then she always wins. \\n \\n \\nMy worst-case input has a simple form, it\\'s an vector of *N* entries, with *(N-1)* 1\\'s and a unique 0. But at the beginning the input is not complete, since I\\'m not sure where to put the unique 0 in my *V*.  Luckily that doesn\\'t matter, since Alice doesn\\'t know that I don\\'t know :). I can still win the game and my strategy is extremely simple: **Whatever entry she asks about, I simply tell her the content is *1*, and then she\\'s doomed to lose**. \\n\\nWhy? This is because Alice can ask at most *N-1* times while I get *N-1* 1\\'s, therefore enough for me to reply. And after that I also get my winner reward, a worst-case input, simply by putting the *0* in any one of the entries that she didn\\'t ask about! \\n\\nNote that we assume nothing about what does Alice\\'s algorithm look like, therefore our strategy works for any algorithm whose claimed worst-case time complexity is *o(N)*. Therefore we have proved that there does not exists such algorithms, and hence the *O(N)* algorithm is worst-case optimal.",
      "voteCount": 41
    },
    {
      "name": "ddcamiu",
      "year": 2015,
      "content": "Just `return min(num)` is accepted with 63ms, which ranks 30% percentile of all python codes.",
      "voteCount": 26
    },
    {
      "name": "ygoyal48",
      "year": 2019,
      "content": "It turned out that duplicates can\\u2019t be handled in O(Logn) time in all cases. The special cases that cause problems are like {2, 2, 2, 2, 2, 2, 2, 2, 0, 1, 1, 2} and {2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2}. It doesn\\u2019t look possible to go to left half or right half by doing constant number of comparisons at the middle. So the problem with repetition can be solved in O(n) worst case.",
      "voteCount": 25
    },
    {
      "name": "adarsh0nayak",
      "year": 2024,
      "content": "What do these guys smoke before assigning the difficulty level.",
      "voteCount": 22
    },
    {
      "name": "kyuyeon",
      "year": 2021,
      "content": "Since it allows duplicated values, the worst case time complexity is inevitably O(N) since you have to search the entire list.\\nThe performance may be sped up by implementing binary search but since it cannot have O(logN) complexity because of the duplicated values, the performance difference is marginal.\\nRuntime of solutions is pointless since it may differ even when re-submitting the same code",
      "voteCount": 13
    },
    {
      "name": "1337beef",
      "year": 2014,
      "content": "Refer to this image:  ![array config][1]\\n\\nBig version here: http://postimg.org/image/asbbeo2c9/\\n\\nThere are generally 3 types of array config, assuming sorted from smallest to biggest. x-axis is the array index, y-axis is the element value.\\n\\nFor non-duplicate case, you may use `num[mid] > num[end]` to distinguish (1)&(2) from (3), and thus safely eliminate half of the array, at each iteration.\\n\\n\\nFor dup case, it is not as straightforward (impossible?)  to distinguish between (1), (2) and (3), and hence eliminate half of the array by doing O(1) comparison, at each iteration.\\n\\n\\n  [1]: http://s28.postimg.org/asbbeo2c9/Photo_16_11_14_2_38_34_pm.jpg",
      "voteCount": 10
    },
    {
      "name": "jason1128",
      "year": 2019,
      "content": "I found that if we compare nums[mid] with nums[left]. A sorted array will not be handled correctcly, but i do not know the exact reason for this. Could anyone help to explain?",
      "voteCount": 8
    },
    {
      "name": "foin",
      "year": 2019,
      "content": "just use for loop in python3 is 100% beat\\n\\nwhy make simple complicated?",
      "voteCount": 7
    }
  ]
}
