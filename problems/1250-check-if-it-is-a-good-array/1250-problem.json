{
  "category": "",
  "id": "1250",
  "name": "Check If It Is a Good Array",
  "difficulty": "Hard",
  "leetcode_url": "https://leetcode.com/problems/check-if-it-is-a-good-array/",
  "slug": "check-if-it-is-a-good-array",
  "isPaidOnly": false,
  "tags": [
    "Array",
    "Math",
    "Number Theory"
  ],
  "similar_questions": [],
  "questionId": "1372",
  "questionFrontendId": "1250",
  "title": "Check If It Is a Good Array",
  "titleSlug": "check-if-it-is-a-good-array",
  "content": "<p>Given an array <code>nums</code> of&nbsp;positive integers. Your task is to select some subset of <code>nums</code>, multiply each element by an integer and add all these numbers.&nbsp;The array is said to be&nbsp;<strong>good&nbsp;</strong>if you can obtain a sum of&nbsp;<code>1</code>&nbsp;from the array by any possible subset and multiplicand.</p>\n\n<p>Return&nbsp;<code>True</code>&nbsp;if the array is <strong>good&nbsp;</strong>otherwise&nbsp;return&nbsp;<code>False</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [12,5,7,23]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> Pick numbers 5 and 7.\n5*3 + 7*(-2) = 1\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [29,6,10]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> Pick numbers 29, 6 and 10.\n29*1 + 6*(-3) + 10*(-1) = 1\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,6]\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10^9</code></li>\n</ul>\n",
  "likes": 549,
  "dislikes": 383,
  "stats": {
    "totalAccepted": "32.1K",
    "totalSubmission": "51.9K",
    "totalAcceptedRaw": 32087,
    "totalSubmissionRaw": 51948,
    "acRate": "61.8%"
  },
  "topicTags": [
    {
      "name": "Array",
      "slug": "array"
    },
    {
      "name": "Math",
      "slug": "math"
    },
    {
      "name": "Number Theory",
      "slug": "number-theory"
    }
  ],
  "metaData": {
    "name": "isGoodArray",
    "params": [
      {
        "name": "nums",
        "type": "integer[]"
      }
    ],
    "return": {
      "type": "boolean"
    }
  },
  "discussion_posts": [
    {
      "name": "kkkkcom",
      "year": 2019,
      "content": "It is not that hard to figure out if GCD is not 1, you won\\'t be able to get a sum of 1. Becuase:\\n\\na = GCD * n\\nb = GCD * m\\n\\nsum = p * a + q * b = p * GCD * n + q * GCD * m = GCD * (pn+qm)\\n\\nSo sum will either be 0 or multiple of GCD.\\n\\nWhat was not clear to me was why the smallest sum can be 1 * GCD but not other multiple of k * GCD. I was not able to figure this out during contest, but my intuition was that this can be achieved, so I just submitted without clear formal proof in my head, and just luckily got accepted.\\n\\nBezout\\'s Identity is the answer to the above question. And my explanation below is more or less similar to what was stated on wiki page, but with some expasion for dumb people like me to better understand.\\n\\nLet\\'s assume d is the smallest sum of p * a + q * b, written as d = pp * a + qq * b\\na can be expressed as a = k * d + r\\nWhere k = a//d, r = a%d, so 0<=r<d\\n\\nRewrite r as\\nr = a - k * d\\nr = a - k * (pp * a + qq * b) = (1 - k * pp) * a + qq * b\\n\\nSo r is also one of the sums in the form of p * a + q * b\\nNow, since 0<=r<d, and we assume d is the smallest sum, so r has to be 0; otherwise, r will be a smaller sum than d, which contradicts our assumption.\\n\\nSo r=0 gives us a = k * d + r = k * d, and this gives us that d is a divisor of a. Similarly d is also a divisor of b. So d is a common divisor of both a and b.\\n\\nSo far up to here, it is already good enough for this problem, since in this problem, when we found GCD = 1, it will be the only common divisor, so we know d = 1 is the only option.\\n\\n*** Further more, if say GCD = 18, then above only shows d can be common divisor for a and b. So d can still be 2 or 3 or 6 or 9. Now assume c is another common divisor than d, we will see:\\na = c * aa\\nb = c * bb\\nd = pp * a + qq * b = pp * c * aa + qq * c * bb = c * (pp * aa + qq * bb)\\n\\nSo c must be a divisor of d. Since we can pick any common divisor for c, that means d has to be GCD, otherwise we can find a c = GCD which is not a divisor of d.\\n\\nI know my explanation may still seem hard to follow, but I\\'ve tried my best ...\\n\\n\\n",
      "voteCount": 35
    },
    {
      "name": "harttle",
      "year": 2019,
      "content": "Here\\'s proofs for Bezout\\'s theorem for n = 2:\\n\\n![image](https://assets.leetcode.com/users/harttle/image_1572758497.png)\\n\\nkaiwensun gives a more detailed text version, see: https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419529/Why-GCD-Look-proof-here!Python2-1-line.",
      "voteCount": 10
    },
    {
      "name": "liketheflower",
      "year": 2019,
      "content": "Lots of posts mentioned that GCD caculation is O(1). Why?\\nI\\'d like to share a detail analysis from a lecture note.  Also this lecture note is a good one if you want to understand more about number thoery required for a CS student.\\nFirst, GCD caculation is related to The Euclidean algorithm  \\n\"gcd(a0,a1) = gcd(a1,a2) = ... = gcd(ak\\u22121,ak) \"   (check the lecture notes 2. The Euclidean algorithm to get details)   \\nSecond, GCD caculation:\\n \"a_i is always an upper bound on some Fibonacci number  \"  \\n \"This shows that the number of steps in the Euclidean algorithm is logarithmic in a0, which means linear in the number of bits required to represent a0. \"  \\n  (check the lecture notes 3 Why not brute force?  to get details)   \\n  \\n Third, we have the constraints that 1 <= nums[i] <= 10^9, as math.log(10^9, 2)=29.897352853986263, we will have time complexity of GCD as O(30) in the worst case.  This explains why the time complexity of GCD is O(1)\\n \\n As far as I know, the following post gave a similar analysis, please also give credits to this post if you feel it is helpful.\\n https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419329/O(n)-solution/378434\\n \\n Lecture notes:\\n  http://www.cs.hunter.cuny.edu/~saad/courses/dm/notes/note7.pdf\\n",
      "voteCount": 10
    },
    {
      "name": "flyingpenguin",
      "year": 2019,
      "content": "I experimented during the contest that any two co prime number can make up 1 somehow but I can\\'t prove it mathematically....\\n\\nWould appreciate any proof...",
      "voteCount": 8
    },
    {
      "name": "only_anagha",
      "year": 2023,
      "content": "why is it expecting the result to be true for nums = [6, 10, 15], when it\\'s clearly visible to be false?",
      "voteCount": 2
    },
    {
      "name": "Aditya_Kumdale",
      "year": 2023,
      "content": "Learn eucledian algorithm of gcd first rest of the part is easy",
      "voteCount": 2
    },
    {
      "name": "hCaulfield",
      "year": 2019,
      "content": "(sufficient)\\nIf two number are coprime, then there exist their linear combination which has value 1 (by [Euler\\'s Theorem](https://en.wikipedia.org/wiki/Euler%27s_theorem)). So two number has a linear combination whose value is their gcd. (Coprime b and c has linear combination 1 then ab and ac can make a*1=a). It\\'s obviously to extend to finitely many numbers.\\n\\n(necessary)\\nThe numbers\\' linear combination must be a multipler of their gcd.\\n",
      "voteCount": 2
    },
    {
      "name": "kathylin",
      "year": 2019,
      "content": "gcd(a, b) = minimum positive linear combination of a and b\\n\\nproof: https://math.stackexchange.com/questions/219941/is-greatest-common-divisor-of-two-numbers-really-their-smallest-linear-combinati",
      "voteCount": 2
    },
    {
      "name": "Prabuddha_Pal_2006",
      "year": 2025,
      "content": "I mean by creating a GCD function and using the recursive  approach we can solve this problem",
      "voteCount": 1
    },
    {
      "name": "emcc2302",
      "year": 2025,
      "content": "This question is not hard at all; it should be easy\\u2014it\\u2019s just a math trick, that\\u2019s it.",
      "voteCount": 0
    }
  ]
}
