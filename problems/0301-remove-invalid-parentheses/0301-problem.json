{
  "category": "",
  "id": "301",
  "name": "Remove Invalid Parentheses",
  "difficulty": "Hard",
  "leetcode_url": "https://leetcode.com/problems/remove-invalid-parentheses/",
  "slug": "remove-invalid-parentheses",
  "isPaidOnly": false,
  "tags": [
    "String",
    "Backtracking",
    "Breadth-First Search"
  ],
  "similar_questions": [
    {
      "title": "Valid Parentheses",
      "difficulty": "Easy",
      "slug": "valid-parentheses"
    },
    {
      "title": "Minimum Number of Swaps to Make the String Balanced",
      "difficulty": "Medium",
      "slug": "minimum-number-of-swaps-to-make-the-string-balanced"
    }
  ],
  "questionId": "301",
  "questionFrontendId": "301",
  "title": "Remove Invalid Parentheses",
  "titleSlug": "remove-invalid-parentheses",
  "content": "<p>Given a string <code>s</code> that contains parentheses and letters, remove the minimum number of invalid parentheses to make the input string valid.</p>\n\n<p>Return <em>a list of <strong>unique strings</strong> that are valid with the minimum number of removals</em>. You may return the answer in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;()())()&quot;\n<strong>Output:</strong> [&quot;(())()&quot;,&quot;()()()&quot;]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;(a)())()&quot;\n<strong>Output:</strong> [&quot;(a())()&quot;,&quot;(a)()()&quot;]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;)(&quot;\n<strong>Output:</strong> [&quot;&quot;]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 25</code></li>\n\t<li><code>s</code> consists of lowercase English letters and parentheses <code>&#39;(&#39;</code> and <code>&#39;)&#39;</code>.</li>\n\t<li>There will be at most <code>20</code> parentheses in <code>s</code>.</li>\n</ul>\n",
  "likes": 6016,
  "dislikes": 300,
  "stats": {
    "totalAccepted": "485.6K",
    "totalSubmission": "982.8K",
    "totalAcceptedRaw": 485638,
    "totalSubmissionRaw": 982787,
    "acRate": "49.4%"
  },
  "topicTags": [
    {
      "name": "String",
      "slug": "string"
    },
    {
      "name": "Backtracking",
      "slug": "backtracking"
    },
    {
      "name": "Breadth-First Search",
      "slug": "breadth-first-search"
    }
  ],
  "metaData": {
    "name": "removeInvalidParentheses",
    "params": [
      {
        "name": "s",
        "type": "string"
      }
    ],
    "return": {
      "type": "list<string>"
    }
  },
  "company_tag_stats": {
    "1": [
      {
        "taggedByAdmin": true,
        "name": "Meta",
        "slug": "facebook",
        "timesEncountered": 15
      }
    ]
  },
  "discussion_posts": [
    {
      "name": "meow_power",
      "year": 2023,
      "content": "\\nREAD THIS TO FUCK ANY PROBLEM WITH YOUR EYES!!!!!!!\\n\\nHow would you get the intuition that this problem is a graph problem specifically of BFS problem and not a DFS problem? \\n\\nThe important thing to note here is that any graph problem that is given to you it will not be written in a very clear manner that it is a graph problem the thing is you have to deduce this fact.\\n\\nA graph is a collection of nodes and edges, where each node represents a state or an object and each edge represents a relationship or a transition between nodes. In this case, each string is represented as a node and each possible removal of a parenthesis is represented as an edge between nodes.\\n\\nFor example, consider the input string \"(a)b)c)\". The initial state, or the starting node, is the input string itself. By removing one invalid parenthesis at a time, we can generate new strings, or new nodes in the graph, such as \"(a)bc)\", \"(ab)c)\", and \"(abc)\". Each of these strings is a child node of the initial node and is connected to it via an edge, representing the removal of one parenthesis.\\n\\nWe can continue this process for each of the generated strings, creating new nodes and edges until we reach a valid string, which is a string that has no invalid parentheses. Each valid string is an end node in the graph.\\n\\nThe goal of the problem is to find the shortest path from the starting node to one or more end nodes, where the shortest path is defined as the path that requires the minimum number of removals (or the minimum number of edges).\\n\\nBFS is a suitable algorithm for this problem because it guarantees that the first valid string it finds is the one that requires the minimum number of removals. This is because it explores all the nodes at the same depth before moving on to the next depth, so it will explore all the strings that can be generated by removing one parenthesis before it explores strings that can be generated by removing two or more parentheses. This guarantees that the first valid string it finds is the one that requires the minimum number of removals.\\n\\n\"Depth\" in this context refers to the number of removals required to reach a certain string from the initial string. Each string that can be generated by removing one parenthesis from the initial string is at a depth of 1, each string that can be generated by removing two parenthesis from the initial string is at a depth of 2, and so on.\\n\\nWhen BFS explores the graph, it starts with the initial string and generates new strings by removing one parenthesis at a time. It explores all the strings that can be generated by removing one parenthesis before moving on to the next depth, which is strings that can be generated by removing two parenthesis. This is why BFS guarantees that the first valid string it finds is the one that requires the minimum number of removals, because it explores all the nodes at the same depth before moving on to the next depth.\\n\\nAlso, it is important to note that, the depth of a node in a graph is the number of edges between the node and the root node. In this case, the root node is the initial string, and each edge represents a removal of one parenthesis.",
      "voteCount": 154
    },
    {
      "name": "code-junkie",
      "year": 2018,
      "content": "There are many posts discussion solution to the problem, but I didn\\'t find any good post discussing the time complexity. Only found @jeantimex post and thanks to him for providing answer. \\n\\nSo here is it goes:\\n\\nLet `n` be the number of parentheses in the string. While doing `BFS` we remove one one parantheses character from the given string and keep on doing it till we get a result (even an empty string is also an answer). So, in the worst case we traverse till the end. Therefore,\\n\\n`T(n) = n * C(n, n) + (n - 1) * C(n, n -1) + .... + C(n, 1)`\\n\\nLets break up the terms for better understanding one first level we have `n` characters to remove from `C(n,n)` total number of string, at second level length of strings is `n-1` and there are `C(n,n-1)` such strings, and so on.\\n\\nNow, summation of `T(n) = n*2^(n-1)`. Here, is how it is achieved:\\n\\nWe know binomial theorm,\\n\\n`(1+x)^n = C(n,0) + C(n,1)*x + C(n,2)*x^2 + ... + C(n,n)*x^n`\\n\\nTaking derivative w.r.t `x`\\n\\n`n*(1 + x)^(n-1) = C(n,1) + 2*C(n,2)*x + ... + n*C(n,n)*x^(n-1)`\\n\\nSubstituting `x = 1`,\\n\\n`n*2^(n-1) = C(n,1) + 2*C(n,2) + ... + (n-1)*C(n, n-1) + n*C(n,n)`\\n\\nI hope this helps",
      "voteCount": 19
    },
    {
      "name": "_king_",
      "year": 2020,
      "content": "Thanks for sharing the awesome solutions however, we are preparing from interview perspective and I would like to say at the end, we would like to know the time and space complexity to know if we have foud the better solution and run time in ms is pretty much not a useful info for our preparation.",
      "voteCount": 14
    },
    {
      "name": "Nandini_317",
      "year": 2024,
      "content": "why is no one talking about backtracking ?",
      "voteCount": 8
    },
    {
      "name": "GladysWang",
      "year": 2018,
      "content": "I see a lot of answers solving this question by DFS, but by my first impression, it\\'s much eaiser to do it by BFS.\\n\\nSo it there any advantages/dsiadvantages between DFS and BFS?\\n\\nThank you guys for any comments.\\n",
      "voteCount": 8
    },
    {
      "name": "Cocamo1337",
      "year": 2023,
      "content": "A HashSet that checks your current permutation against all other previously calculated and added permutations, is very useful here. I went from TLE to beat 94% with 4-5 lines of extra code.",
      "voteCount": 4
    },
    {
      "name": "TanmayWani",
      "year": 2024,
      "content": "The Backtracking approach is not accepted. It is giving TLE. If you want to accept only BFS approach, then why add it under Backtracking section\\n",
      "voteCount": 3
    },
    {
      "name": "jianminchen",
      "year": 2020,
      "content": "June 22, 2020\\n**301. Remove Invalid Parentheses**\\nRemove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.\\n\\n**Introduction**\\n\\nIt is hard level algorithm and most famous one used for algorithm interview. I spent a lot of hours starting from 2017 to work on a few solutions. I think that it is better to work on easy level algorithm first, and then master tree algorithm first, and then work on this hard level algorithm. \\n\\nI am preparing one month for Facebook July 2020 phone screen, so I have to take a few hours to warmup this algorithm. \\n\\n[C# study code and apply TED principle practice back in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360141/C-study-code-and-apply-TED-principle-practice-back-in-2017)\\n[C# BFS algorithm practice in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360163/C-BFS-algorithm-practice-in-2017)\\n[C# BFS practice back in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360197/C-BFS-practice-back-in-2017)\\n[C# DFS practice in 2018](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360140/C-DFS-practice-in-2018)\\n[Story first, code follows - practice in 2018](https://leetcode.com/problems/remove-invalid-parentheses/discuss/158584/Story-first-code-follows-practice-in-2018)\\n\\n2020\\nJune 22, 2020\\n[C# BFS warmup practice in 2020](https://leetcode.com/problems/remove-invalid-parentheses/discuss/701047/C-BFS-warmup-practice-in-2020)\\nJune 23, 2020\\nBFS algorithm - keep minimum steps to make it work first\\n[C# BFS approach without pruning practice in June 2020](https://leetcode.com/problems/remove-invalid-parentheses/discuss/702517/C-BFS-approach-without-pruning-practice-in-June-2020)",
      "voteCount": 3
    },
    {
      "name": "vihanagarwal",
      "year": 2024,
      "content": "today i was asked this question and in my wildest dream i couldn\\'t imagine to solve a leetcode hard but i actually did \\n",
      "voteCount": 1
    },
    {
      "name": "rukt",
      "year": 2023,
      "content": "test case 127 is broken, when i click copy testcase it literally says s = Enter Testcase. its a blank testcase. please help. \\n\\nclass Solution:\\n    def removeInvalidParentheses(self, s: str) -> List[str]:\\n        def helper(s):\\n            res = 0\\n            for i in s:\\n                if i == \\'(\\': res += 1\\n                elif i == \\')\\': res -= 1\\n                if res < 0: return False\\n            return res == 0\\n\\n        q, newq = [s], []\\n        done = False\\n        if not s: return [s]\\n        if helper(s): return [s]\\n        while not done:\\n            newq = []\\n            for curr in q:\\n                for i in range(len(curr)):\\n                    news = curr[:i] + curr[i+1:]\\n                    if news not in newq:\\n                        newq.append(news)\\n                    if helper(news):\\n                        done = True\\n            # print(newq)\\n            q = newq.copy()\\n        return [i for i in newq if helper(i)]",
      "voteCount": 1
    }
  ]
}
