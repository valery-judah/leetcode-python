{
  "category": "",
  "id": "255",
  "name": "Verify Preorder Sequence in Binary Search Tree",
  "difficulty": "Medium",
  "leetcode_url": "https://leetcode.com/problems/verify-preorder-sequence-in-binary-search-tree/",
  "slug": "verify-preorder-sequence-in-binary-search-tree",
  "isPaidOnly": true,
  "tags": [
    "Array",
    "Stack",
    "Tree",
    "Binary Search Tree",
    "Recursion",
    "Monotonic Stack",
    "Binary Tree"
  ],
  "similar_questions": [
    {
      "title": "Binary Tree Preorder Traversal",
      "difficulty": "Easy",
      "slug": "binary-tree-preorder-traversal"
    }
  ],
  "questionId": "255",
  "questionFrontendId": "255",
  "title": "Verify Preorder Sequence in Binary Search Tree",
  "titleSlug": "verify-preorder-sequence-in-binary-search-tree",
  "content": "<p>Given an array of <strong>unique</strong> integers <code>preorder</code>, return <code>true</code> <em>if it is the correct preorder traversal sequence of a binary search tree</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/12/preorder-tree.jpg\" style=\"width: 292px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> preorder = [5,2,1,3,6]\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> preorder = [5,2,6,1,3]\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= preorder.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= preorder[i] &lt;= 10<sup>4</sup></code></li>\n\t<li>All the elements of <code>preorder</code> are <strong>unique</strong>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you do it using only constant space complexity?</p>\n",
  "likes": 1256,
  "dislikes": 90,
  "stats": {
    "totalAccepted": "91.4K",
    "totalSubmission": "177.7K",
    "totalAcceptedRaw": 91390,
    "totalSubmissionRaw": 177688,
    "acRate": "51.4%"
  },
  "topicTags": [
    {
      "name": "Array",
      "slug": "array"
    },
    {
      "name": "Stack",
      "slug": "stack"
    },
    {
      "name": "Tree",
      "slug": "tree"
    },
    {
      "name": "Binary Search Tree",
      "slug": "binary-search-tree"
    },
    {
      "name": "Recursion",
      "slug": "recursion"
    },
    {
      "name": "Monotonic Stack",
      "slug": "monotonic-stack"
    },
    {
      "name": "Binary Tree",
      "slug": "binary-tree"
    }
  ],
  "metaData": {
    "name": "verifyPreorder",
    "params": [
      {
        "name": "preorder",
        "type": "integer[]"
      }
    ],
    "return": {
      "type": "boolean"
    }
  },
  "discussion_posts": [
    {
      "name": "seredenko99",
      "year": 2024,
      "content": "that\\'s hard",
      "voteCount": 15
    },
    {
      "name": "davide_paolillo",
      "year": 2024,
      "content": "I\\'ll leave here 3 hints that may help others to solve the problem:\\n\\n- Hint 1: In a preorder traversal of a binary search tree (BST), the root is always visited first, followed by the left subtree, and then the right subtree.\\n\\nThink about how you would track the boundaries for a valid BST as you traverse the nodes in preorder.\\nFor any node, the values in its left subtree must be smaller, and the values in its right subtree must be larger than the root.\\n\\n- Hint 2: When you traverse the preorder array, you\\u2019re essentially simulating the construction of a BST. Use a monotonic stack to keep track of the ancestors of each node.\\n\\nEvery time you move to the right subtree, the value of the current node must be larger than the last \"ancestor\" (previous smaller element). How can you ensure that when you pop an element off the stack, the next element is valid?\\n\\n- Hint 3: As you process the preorder array, think about how you know when you\\'re moving from the left subtree to the right subtree.\\n\\nOnce you pop an element off the stack, you are moving to its right subtree. The popped element becomes a lower bound, and any future node must be greater than this value.\\nKeep updating this lower bound as you progress. How can you maintain this information efficiently using a stack?",
      "voteCount": 7
    },
    {
      "name": "LijieTu",
      "year": 2018,
      "content": "It seems [5,2,1,10,6] can also pass the test, but this is not a binary search tree. Do we assume the underlying is always a BST?\\n\\n",
      "voteCount": 3
    },
    {
      "name": "mckamike",
      "year": 2024,
      "content": "Good challenge. Didn't find the solution but learned something =) ",
      "voteCount": 2
    },
    {
      "name": "matthewjinmp",
      "year": 2025,
      "content": "monotonic stack is a necessity here ",
      "voteCount": 1
    },
    {
      "name": "deadpool_18",
      "year": 2025,
      "content": "The question would be easier to understand if it said \"Can you arrange the nodes in such a way that you get a BST and its preorder traversal looks like so ?\"",
      "voteCount": 1
    },
    {
      "name": "flowac",
      "year": 2025,
      "content": "I knew a stack had to be used and it\\'s monotonic, but I had to look at the solution to sort out the edge cases.\\nFeels bad :(",
      "voteCount": 1
    },
    {
      "name": "wannaleave",
      "year": 2024,
      "content": "Great challenge!!!",
      "voteCount": 1
    },
    {
      "name": "antyy",
      "year": 2024,
      "content": "Input [21, 10, 5, 1, 22, 33, 25, 44, 40, 50] also passes the test. Is the solution proposed in Editorial section correct?",
      "voteCount": 1
    },
    {
      "name": "gangasinghofficial",
      "year": 2025,
      "content": "Not sure if I am the only one who didn\\'t understand the input. Is this only for one correct output for [5,2,1,3,6] and rest any combination with this number is gonna be rejected?\\n",
      "voteCount": 0
    }
  ]
}
