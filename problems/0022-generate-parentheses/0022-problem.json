{
  "category": "",
  "id": "22",
  "name": "Generate Parentheses",
  "difficulty": "Medium",
  "leetcode_url": "https://leetcode.com/problems/generate-parentheses/",
  "slug": "generate-parentheses",
  "isPaidOnly": false,
  "tags": [
    "String",
    "Dynamic Programming",
    "Backtracking"
  ],
  "similar_questions": [
    {
      "title": "Letter Combinations of a Phone Number",
      "difficulty": "Medium",
      "slug": "letter-combinations-of-a-phone-number"
    },
    {
      "title": "Valid Parentheses",
      "difficulty": "Easy",
      "slug": "valid-parentheses"
    },
    {
      "title": "Check if a Parentheses String Can Be Valid",
      "difficulty": "Medium",
      "slug": "check-if-a-parentheses-string-can-be-valid"
    }
  ],
  "questionId": "22",
  "questionFrontendId": "22",
  "title": "Generate Parentheses",
  "titleSlug": "generate-parentheses",
  "content": "<p>Given <code>n</code> pairs of parentheses, write a function to <em>generate all combinations of well-formed parentheses</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> n = 3\n<strong>Output:</strong> [\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> n = 1\n<strong>Output:</strong> [\"()\"]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 8</code></li>\n</ul>\n",
  "likes": 22592,
  "dislikes": 1056,
  "stats": {
    "totalAccepted": "2.5M",
    "totalSubmission": "3.3M",
    "totalAcceptedRaw": 2527214,
    "totalSubmissionRaw": 3256776,
    "acRate": "77.6%"
  },
  "topicTags": [
    {
      "name": "String",
      "slug": "string"
    },
    {
      "name": "Dynamic Programming",
      "slug": "dynamic-programming"
    },
    {
      "name": "Backtracking",
      "slug": "backtracking"
    }
  ],
  "metaData": {
    "name": "generateParenthesis",
    "params": [
      {
        "name": "n",
        "type": "integer"
      }
    ],
    "return": {
      "type": "list<string>"
    }
  },
  "company_tag_stats": {
    "1": [
      {
        "taggedByAdmin": false,
        "name": "Amazon",
        "slug": "amazon",
        "timesEncountered": 27
      },
      {
        "taggedByAdmin": true,
        "name": "Google",
        "slug": "google",
        "timesEncountered": 25
      }
    ]
  },
  "discussion_posts": [
    {
      "name": "KalRadikov",
      "year": 2020,
      "content": "![image](https://assets.leetcode.com/users/images/40f0296a-7b58-49fb-a72e-e5d8eacf94a4_1604461937.5052783.png)\\n\\nProof:\\n\\n![image](https://assets.leetcode.com/users/images/4bcd2dba-e170-4799-91ae-3e4a1de32731_1605116132.2703443.png)\\n\\n",
      "voteCount": 985
    },
    {
      "name": "tejavenkatlanka",
      "year": 2020,
      "content": "![image](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)\\nclick for view \\n[https://embed.creately.com/cclS6u7Upy3?type=svg] \\n\\nleft path represent possible one parentheses and right represent possible of right parentheses.\\n\\nleaf node contains answer.\\n\\nhope it will help.\\n\\n",
      "voteCount": 806
    },
    {
      "name": "bonson",
      "year": 2018,
      "content": "Using different implmentation,the elements will be in different orders. e.g. n = 3.\\nIt can be\\n[\"((()))\",\"(())()\",\"()(())\",\"(()())\",\"()()()\"]\\nwhile the expected answer is\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n\\nBoth are correct answers. However, the difference of ordering is reckoned as \"wrong answer\". ",
      "voteCount": 357
    },
    {
      "name": "M1dn1ght",
      "year": 2024,
      "content": "I still remember the first time I encountered this LeetCode problem. It felt like an insurmountable challenge, an impossible puzzle that I couldn\\'t even begin to solve. I spent hours staring at the screen, feeling defeated and frustrated as I struggled to find a solution...\\n\\nBut I didn\\'t give up. I kept pushing myself, determined to crack the code and overcome this seemingly unbeatable problem. And slowly, piece by piece, I began to unravel it, delving deep into the intricacies and complexities of the algorithm needed for this..\\n\\nAnd today, it happened. I finally solved it after last time i\\'ve seen this problem (5 months ago) . The feeling of accomplishment and triumph was overwhelming, a rush of emotions that I never thought I would experience. I had conquered the Leetcode problem that had once seemed so daunting, so unattainable.\\n\\nLooking back on that moment now, I realize how far I\\'ve come. I never dreamed that I would be able to solve such a challenging problem (at least for me) , to push myself beyond my limits and achieve something that I once thought was impossible.\\n\\nIt\\'s a reminder that with determination, persistence, and hard work, we can achieve anything we set our minds to. And while there may be more difficult challenges ahead, I know that I have the strength and the skills to face them head-on ! Thank you Leet Code for making me a better thinker, a better problem solver , and finally a better programmer ! ",
      "voteCount": 176
    },
    {
      "name": "khanuja05",
      "year": 2017,
      "content": "My solution generates the same set of outputs but the ordering is different. The question should be edited and they should mention that the order matters.",
      "voteCount": 154
    },
    {
      "name": "chiragrajput245",
      "year": 2023,
      "content": "Draw the recursive tree and think about the conditions when an opening/closing bracket can be appended\n\n         (\n        / \\\n       ((  ()\n      / \\   |\n    ((( (() ()(\n     .   .   .\n     .   .   .\n\n... and so on",
      "voteCount": 125
    },
    {
      "name": "panwu5588",
      "year": 2018,
      "content": "BAD test cases. The order should not matter.\\nFor example, the following should be the same:\\n[\"(())\",\"()()\"]\\n[\"()()\",\"(())\"]",
      "voteCount": 93
    },
    {
      "name": "noisrucer",
      "year": 2020,
      "content": "I solved this problem with 60m/s by generating permutations with duplicates and for each permutation result I used stack to check if it\\'s valid parenthesis and now I came here and ppl post simple/mind-blowing solutions that I never expected and A LOT OF people be like \"yeah~nice solution~i thought kinda the same way~\". WTH!!!!!\\n\\nI started algorithm roughly 3 months ago and I\\'ve been studying 12-14 hrs a day til now and solved probably 200 questions so far. I\\'m kinda confident in BFS DFS DP and some general algorithm but totally new to combinatorics. What should I focus more on? I haven\\'t studied Greedy yet. Can you guys recommend me how I study Greedy? cuz its so vague I\\'ve looked up so much\\n\\nBless to y\\'all\\n\\n- Non-smart Asian sophomore kid-",
      "voteCount": 78
    },
    {
      "name": "AnthonyR21",
      "year": 2023,
      "content": "To solve this problem, you can use a recursive approach. Here\\'s how you can approach the task and put your mind in the right direction:\\n\\n1. Base Case: Start by identifying the base case. When n is 0, there\\'s only one possible combination: an empty string.\\n\\n2. Recursive Case: For each pair of parentheses, you have two options: open a new parenthesis or close an existing open parenthesis. So, you\\'ll recursively generate combinations by trying both options for each parenthesis.\\n\\n3. Recursion with Backtracking: Use recursion to explore all possibilities. When adding an open parenthesis, decrement n by 1 to indicate that one opening parenthesis has been used. When adding a closing parenthesis, make sure there\\'s a matching open parenthesis available (meaning n hasn\\'t reached 0 yet).\\n\\n4. Build and Return the Combinations: As you explore the possibilities, build and store the combinations in a list. Once you\\'ve exhausted all possibilities for a given state, return the list of combinations.\\n\\n5. Edge Cases: Handle edge cases like if n is negative or zero, and set up the initial call to the recursive function.\\n\\nIn terms of algorithm, the key idea is to generate all possible combinations while ensuring that they\\'re well-formed parentheses. The recursive approach allows you to explore these combinations in a structured manner. Remember to think about the base case, the recursive cases, and how to build and return the combinations as you traverse the recursion tree.\\n\\nIn terms of implementation, you can create a recursive function that takes parameters such as the current combination being built, the remaining open and close parentheses, and the list to store combinations. Each recursive call will decide whether to add an open or close parenthesis, and the parameters will be updated accordingly.\\n\\nRemember that recursive problems often involve thinking about how to break down the problem into smaller, more manageable subproblems, and how to combine the results of those subproblems to get the final solution.\\n\\n ",
      "voteCount": 62
    },
    {
      "name": "andy_r_s",
      "year": 2018,
      "content": "For n = 4 is following one of the valid combinations?\\n(())(())\\n\\nMy code has this but the leetcode says it\\'s not valid. I don\\'t understand why is it invalid?",
      "voteCount": 55
    }
  ]
}
