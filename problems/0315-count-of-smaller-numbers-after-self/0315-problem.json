{
  "category": "",
  "id": "315",
  "name": "Count of Smaller Numbers After Self",
  "difficulty": "Hard",
  "leetcode_url": "https://leetcode.com/problems/count-of-smaller-numbers-after-self/",
  "slug": "count-of-smaller-numbers-after-self",
  "isPaidOnly": false,
  "tags": [
    "Array",
    "Binary Search",
    "Divide and Conquer",
    "Binary Indexed Tree",
    "Segment Tree",
    "Merge Sort",
    "Ordered Set"
  ],
  "similar_questions": [
    {
      "title": "Count of Range Sum",
      "difficulty": "Hard",
      "slug": "count-of-range-sum"
    },
    {
      "title": "Queue Reconstruction by Height",
      "difficulty": "Medium",
      "slug": "queue-reconstruction-by-height"
    },
    {
      "title": "Reverse Pairs",
      "difficulty": "Hard",
      "slug": "reverse-pairs"
    },
    {
      "title": "How Many Numbers Are Smaller Than the Current Number",
      "difficulty": "Easy",
      "slug": "how-many-numbers-are-smaller-than-the-current-number"
    },
    {
      "title": "Count Good Triplets in an Array",
      "difficulty": "Hard",
      "slug": "count-good-triplets-in-an-array"
    },
    {
      "title": "Count the Number of K-Big Indices",
      "difficulty": "Hard",
      "slug": "count-the-number-of-k-big-indices"
    }
  ],
  "questionId": "315",
  "questionFrontendId": "315",
  "title": "Count of Smaller Numbers After Self",
  "titleSlug": "count-of-smaller-numbers-after-self",
  "content": "<p>Given an integer array <code>nums</code>, return<em> an integer array </em><code>counts</code><em> where </em><code>counts[i]</code><em> is the number of smaller elements to the right of </em><code>nums[i]</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [5,2,6,1]\n<strong>Output:</strong> [2,1,1,0]\n<strong>Explanation:</strong>\nTo the right of 5 there are <b>2</b> smaller elements (2 and 1).\nTo the right of 2 there is only <b>1</b> smaller element (1).\nTo the right of 6 there is <b>1</b> smaller element (1).\nTo the right of 1 there is <b>0</b> smaller element.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-1]\n<strong>Output:</strong> [0]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-1,-1]\n<strong>Output:</strong> [0,0]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
  "likes": 9108,
  "dislikes": 249,
  "stats": {
    "totalAccepted": "365.1K",
    "totalSubmission": "849.2K",
    "totalAcceptedRaw": 365054,
    "totalSubmissionRaw": 849189,
    "acRate": "43.0%"
  },
  "topicTags": [
    {
      "name": "Array",
      "slug": "array"
    },
    {
      "name": "Binary Search",
      "slug": "binary-search"
    },
    {
      "name": "Divide and Conquer",
      "slug": "divide-and-conquer"
    },
    {
      "name": "Binary Indexed Tree",
      "slug": "binary-indexed-tree"
    },
    {
      "name": "Segment Tree",
      "slug": "segment-tree"
    },
    {
      "name": "Merge Sort",
      "slug": "merge-sort"
    },
    {
      "name": "Ordered Set",
      "slug": "ordered-set"
    }
  ],
  "metaData": {
    "name": "countSmaller",
    "params": [
      {
        "name": "nums",
        "type": "integer[]"
      }
    ],
    "return": {
      "type": "list<integer>",
      "dealloc": true
    }
  },
  "discussion_posts": [
    {
      "name": "bakaiti002",
      "year": 2020,
      "content": "This is what I followed to solve this problem so that I can avoid looking in discuss section.\\n\\nstep 1: write merge sort code on your own.\\n\\nStep 2: extend merge sort to solve inversion count problem. \\nhere is problem link: https://www.geeksfor[**]geeks.org/counting-inversions/\\nonce you solved it, you can test your solution by submitting https://www.interviewbit.com/problems/inversions/\\nto make sure, you have covered all cases.\\nHint: there is only one line change in merge sort and inversion count problem\\n\\nStep 3: coming to this problem.Even after solving those problem it might not be very easy to tackle this one.but now you know which method change, once you have figured out change, then you will be left with two challenges (at least in my case)\\nhandling for duplicates.\\nsince this question requires to return list, to return output as desired might take some extra time.\\n\\nLet me know if this helps.\\n( I have intenionally left all the details, consider this post as detailed hint post)\\n\\n",
      "voteCount": 87
    },
    {
      "name": "votrubac",
      "year": 2017,
      "content": "1-3 Brute force, set, BST with counters: \\nhttp://www.programmercoach.com/2017/02/programming-interview-pearls-count.html\\n\\n4-6 Self-balancing BST with counters, binary indexed tree, merge sort: \\nhttp://www.programmercoach.com/2017/03/programming-interview-pearls-count.html\\n\\n7-9: Segment tree, lazy propagation segment tree, height-balanced BST with counters:\\nhttp://www.programmercoach.com/2017/03/programming-interview-pearls-count_10.html",
      "voteCount": 34
    },
    {
      "name": "RBBAH",
      "year": 2022,
      "content": "![image](https://user-images.githubusercontent.com/113479224/207906481-b9e830c3-0684-4bdf-9b2d-747606218206.png)\\nCome on! Man! What was this suppose to mean??",
      "voteCount": 27
    },
    {
      "name": "dd2233",
      "year": 2018,
      "content": "Was able to pass with an O(n^2) solution.  The O(n^2) solution is much too easy for a Hard problem.",
      "voteCount": 19
    },
    {
      "name": "Chouhan_Gourav",
      "year": 2023,
      "content": "At first I was clueless, then in the realated topics I found merge sort although I was expecting stack, the moment I saw merge sort, I solved the question easily, just pair each number with its index and sort.\n\nI wonder how can this be as effeicent as O(Nlog(N)) solution, but its just a merge sort algorithm. \nThats why it's <b> Divide and Conquer for a reason </b>\n",
      "voteCount": 18
    },
    {
      "name": "TommyQu",
      "year": 2021,
      "content": "What is the idea behind the merge sort? And how does someone come up with such solution when seeing this problem? I\\'m curious about the thinking process behind it.",
      "voteCount": 16
    },
    {
      "name": "gauravkabra",
      "year": 2024,
      "content": "\"Inversion Count\"",
      "voteCount": 9
    },
    {
      "name": "WHJ425",
      "year": 2015,
      "content": "The test case [2147483647,-2147483648] should be added for the solution using segment tree. The tree size could be really large if not optimized properly.\\n\\nIf this test case is not expected to pass, then we need to update the description to limit the input numbers in a given range.",
      "voteCount": 7
    },
    {
      "name": "U-A-V",
      "year": 2025,
      "content": "i was asked this question today in an interview",
      "voteCount": 5
    },
    {
      "name": "SanketDaphal",
      "year": 2023,
      "content": "why multiset solution gives TLE?",
      "voteCount": 5
    }
  ]
}
