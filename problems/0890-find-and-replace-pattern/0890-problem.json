{
  "category": "",
  "id": "890",
  "name": "Find and Replace Pattern",
  "difficulty": "Medium",
  "leetcode_url": "https://leetcode.com/problems/find-and-replace-pattern/",
  "slug": "find-and-replace-pattern",
  "isPaidOnly": false,
  "tags": [
    "Array",
    "Hash Table",
    "String"
  ],
  "similar_questions": [
    {
      "title": "Isomorphic Strings",
      "difficulty": "Easy",
      "slug": "isomorphic-strings"
    },
    {
      "title": "Word Pattern",
      "difficulty": "Easy",
      "slug": "word-pattern"
    }
  ],
  "questionId": "926",
  "questionFrontendId": "890",
  "title": "Find and Replace Pattern",
  "titleSlug": "find-and-replace-pattern",
  "content": "<p>Given a list of strings <code>words</code> and a string <code>pattern</code>, return <em>a list of</em> <code>words[i]</code> <em>that match</em> <code>pattern</code>. You may return the answer in <strong>any order</strong>.</p>\n\n<p>A word matches the pattern if there exists a permutation of letters <code>p</code> so that after replacing every letter <code>x</code> in the pattern with <code>p(x)</code>, we get the desired word.</p>\n\n<p>Recall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;abc&quot;,&quot;deq&quot;,&quot;mee&quot;,&quot;aqq&quot;,&quot;dkd&quot;,&quot;ccc&quot;], pattern = &quot;abb&quot;\n<strong>Output:</strong> [&quot;mee&quot;,&quot;aqq&quot;]\n<strong>Explanation:</strong> &quot;mee&quot; matches the pattern because there is a permutation {a -&gt; m, b -&gt; e, ...}. \n&quot;ccc&quot; does not match the pattern because {a -&gt; c, b -&gt; c, ...} is not a permutation, since a and b map to the same letter.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;], pattern = &quot;a&quot;\n<strong>Output:</strong> [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= pattern.length &lt;= 20</code></li>\n\t<li><code>1 &lt;= words.length &lt;= 50</code></li>\n\t<li><code>words[i].length == pattern.length</code></li>\n\t<li><code>pattern</code> and <code>words[i]</code> are lowercase English letters.</li>\n</ul>\n",
  "likes": 4001,
  "dislikes": 175,
  "stats": {
    "totalAccepted": "206.4K",
    "totalSubmission": "268.5K",
    "totalAcceptedRaw": 206391,
    "totalSubmissionRaw": 268468,
    "acRate": "76.9%"
  },
  "topicTags": [
    {
      "name": "Array",
      "slug": "array"
    },
    {
      "name": "Hash Table",
      "slug": "hash-table"
    },
    {
      "name": "String",
      "slug": "string"
    }
  ],
  "metaData": {
    "name": "findAndReplacePattern",
    "params": [
      {
        "name": "words",
        "type": "string[]"
      },
      {
        "name": "pattern",
        "type": "string"
      }
    ],
    "return": {
      "type": "list<string>"
    }
  },
  "discussion_posts": [
    {
      "name": "ay1820098",
      "year": 2024,
      "content": "if there are newbie like me than I would recommend solving 205 Isomorphic String problem first, as this is exact copy of that except one thing which is make list of all isomorphic string",
      "voteCount": 20
    },
    {
      "name": "nextsde",
      "year": 2020,
      "content": "**Based on this intuition, try solving on our own before looking at the code.**\\n\\nWe are given [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"] these words and a pattern = \"abb\" .\\nOur desired output should be: [\"mee\",\"aqq\"]\\n\\nso,\\n\\na -> m\\nb -> e\\nb -> e\\n\\nor\\n\\na -> a\\nb -> q\\nb -> q\\n\\nCan you see the pattern?\\n\\nWhat if we flatten all the character.\\n\\n1 -> 1\\n2 -> 2\\n2 -> 2\\n\\nThis is the idea behind this intuition. \\n\\nSo, we can create a subroutine getFlattenedPattern, which will give us flattened string of the given string.\\n\\nIn the getFlattenedPattern we start mapping first character to 1 and so on. Also we need to keep to track of preveiously mapped character with a hashtable.\\n\\nSo, our algo for this one will look something like this:\\n\\nMap first character to 1 (Put it in a hashtable)\\nCheck hashtable whether subsequent character exist or not in the hashtable.\\nIf it is: append the previously mapped value to resulting stringbuilder. Otherwise increment our map counter and append.\\n\\nOnce that is done getFlattenedPattern should return \"122\" for \"abb\" or \"mee\". Based on the new pattern you can easily tell whether they should or shouldn\\'t be on our list.\\n\\n**Need help with solution?**\\nhttps://nextswe.com/leetcode-890-find-and-replace-pattern/\\n(Solution is at the bottom of the page)",
      "voteCount": 14
    },
    {
      "name": "Luchunpen",
      "year": 2024,
      "content": "Interesting and useful problem ). I solved it with two dictionaries. ",
      "voteCount": 5
    },
    {
      "name": "Satansoft",
      "year": 2024,
      "content": "This problem has the same principal as in **205. Isomorphic Strings**, so highly recommend to solve it first.\\n\\nExist at least 2 approaches to solve it: 1) `indexOf` and 2) `Hash Table`, the first one is shorter but second one is most obvious, but don\\'t be greedy in case of second approach, use separated `Hash Tables`, one for word and one for pattern.\\n\\n",
      "voteCount": 4
    },
    {
      "name": "la_castille",
      "year": 2025,
      "content": "``` js\\nfor (const word of words) {\\n    if (isIsomorphic(word, pattern)) { //solve this first\\n        res.push(word);\\n    }\\n}\\n\\nreturn res;\\n```",
      "voteCount": 3
    },
    {
      "name": "Meet1733",
      "year": 2024,
      "content": "Similar to Q-205 Isomorphic String (https://leetcode.com/problems/isomorphic-strings/description/) ",
      "voteCount": 2
    },
    {
      "name": "west2788",
      "year": 2024,
      "content": "\"Medium\"",
      "voteCount": 2
    },
    {
      "name": "pepjaggu2022",
      "year": 2023,
      "content": "words =\\n[\"badc\",\"abab\",\"dddd\",\"dede\",\"yyxx\"]\\npattern =\\n\"baba\"\\nOutput\\n[\"abab\",\"dede\",\"yyxx\"]\\nExpected\\n[\"abab\",\"dede\"]\\n\\n\\nWhat is the correct output is yyxx same as baba",
      "voteCount": 2
    },
    {
      "name": "singhpratapvarang",
      "year": 2025,
      "content": "See How Far You\\'ve Come BRAHS",
      "voteCount": 1
    },
    {
      "name": "Ashok_Theja_B",
      "year": 2023,
      "content": "Use lastIndexOf();",
      "voteCount": 1
    }
  ]
}
