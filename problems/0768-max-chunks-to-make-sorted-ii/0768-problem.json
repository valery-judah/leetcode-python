{
  "category": "",
  "id": "768",
  "name": "Max Chunks To Make Sorted II",
  "difficulty": "Hard",
  "leetcode_url": "https://leetcode.com/problems/max-chunks-to-make-sorted-ii/",
  "slug": "max-chunks-to-make-sorted-ii",
  "isPaidOnly": false,
  "tags": [
    "Array",
    "Stack",
    "Greedy",
    "Sorting",
    "Monotonic Stack"
  ],
  "similar_questions": [
    {
      "title": "Max Chunks To Make Sorted",
      "difficulty": "Medium",
      "slug": "max-chunks-to-make-sorted"
    }
  ],
  "questionId": "779",
  "questionFrontendId": "768",
  "title": "Max Chunks To Make Sorted II",
  "titleSlug": "max-chunks-to-make-sorted-ii",
  "content": "<p>You are given an integer array <code>arr</code>.</p>\n\n<p>We split <code>arr</code> into some number of <strong>chunks</strong> (i.e., partitions), and individually sort each chunk. After concatenating them, the result should equal the sorted array.</p>\n\n<p>Return <em>the largest number of chunks we can make to sort the array</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [5,4,3,2,1]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong>\nSplitting into two or more chunks will not return the required result.\nFor example, splitting into [5, 4], [3, 2, 1] will result in [4, 5, 1, 2, 3], which isn&#39;t sorted.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [2,1,3,4,4]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong>\nWe can split into two chunks, such as [2, 1], [3, 4, 4].\nHowever, splitting into [2, 1], [3], [4], [4] is the highest number of chunks possible.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 2000</code></li>\n\t<li><code>0 &lt;= arr[i] &lt;= 10<sup>8</sup></code></li>\n</ul>\n",
  "likes": 1976,
  "dislikes": 62,
  "stats": {
    "totalAccepted": "81K",
    "totalSubmission": "148.9K",
    "totalAcceptedRaw": 81013,
    "totalSubmissionRaw": 148897,
    "acRate": "54.4%"
  },
  "topicTags": [
    {
      "name": "Array",
      "slug": "array"
    },
    {
      "name": "Stack",
      "slug": "stack"
    },
    {
      "name": "Greedy",
      "slug": "greedy"
    },
    {
      "name": "Sorting",
      "slug": "sorting"
    },
    {
      "name": "Monotonic Stack",
      "slug": "monotonic-stack"
    }
  ],
  "metaData": {
    "name": "maxChunksToSorted",
    "params": [
      {
        "name": "arr",
        "type": "integer[]"
      }
    ],
    "return": {
      "type": "integer"
    }
  },
  "discussion_posts": [
    {
      "name": "parr_ot",
      "year": 2024,
      "content": "Don\\'t just comment that it\\'s a easy question just to feel superior. Many beginners gets demotivated by such comments. If you are really expert provide a detailed solution in solutions tab instead of commenting these type of things.",
      "voteCount": 25
    },
    {
      "name": "vietnha1999",
      "year": 2024,
      "content": "easier than many medium questions.",
      "voteCount": 17
    },
    {
      "name": "aniket141193",
      "year": 2023,
      "content": "To identify when to use prefix and suffix, you can look at how the current index outcome depends on the previous index and how the current index determines the outcome for the next index. If this pattern suggests that prefix and suffix could be used to solve the problem, then you can try using them.\\n\\nTo identify what to do with these prefix and suffix, you can analyze the elements in the given sequence. For example, in the sequence \"2 1 5 4 3\", you can create two partitions. The number 2 has an influence until the number 1, and the number 1 has no influence on the number 5. However, the number 5 has an influence until the number 3. From this observation, you can deduce that you need the maximum element from the left side.\\n\\nNow, if the number 2 has an influence on the number 1, and if there is a 0 on the right side of the number 1, then the number 2 has an influence until the 0. Like: 2 1 1 0, then 2 2 2 2. So you can say that the minimum number from the right has an influence on the max of the left.\\n\\nFrom this observation, you can take the minimum number from the right. We can observe that if the current index is less than the next index, that point will be eligible for partition.\\n\\nSo you can iterate over the elements and check if leftMin[i] <= rightMin[i+1], increment the count.\\n\\nThe reason you add less than equals sign because even if the elements are the same, you will create a partition to get the maximum partition.\\n\\nIn summary, the technique to identify whether to use prefix and suffix is to look at how the current index outcome depends on the previous index and how the current index determines the outcome for the next index. To identify what to do with these prefix and suffix, you can analyze the elements in the given sequence, look for the maximum element from the left side and minimum number from the right side and check if leftMin[i] <= rightMin[i+1] then increment the count and return count+1.",
      "voteCount": 11
    },
    {
      "name": "code__HARD",
      "year": 2024,
      "content": "Think using a stack data structure!\\nThink what u need to maintain in the stack either the min element of chunk or max element of chunk?\\nDon\\'t get satisfied until u get a O(n) solution.\\n",
      "voteCount": 9
    },
    {
      "name": "bahailu",
      "year": 2024,
      "content": "With the given constraint, this question should not have been tagged as a hard problem. At the very least, it should be constrained to require an O(N) solution.",
      "voteCount": 8
    },
    {
      "name": "youtility",
      "year": 2021,
      "content": "According to the problem description, as long as it is sorted it does not matter if it is ascending or descending.\\nSo for the input [5,4,3,2,1], if 1 is accepted, meaning there is one chunk (no splitting).\\nThen splitting it into 5 chunks [5],[4],[3],[2],[1] should also be correct, or do I miss something?",
      "voteCount": 8
    },
    {
      "name": "nswarna2024",
      "year": 2024,
      "content": "My First Hard Sum!!!\\n\\nTip : Use PrefixMax , SuffixMin",
      "voteCount": 7
    },
    {
      "name": "isusel",
      "year": 2024,
      "content": "After solving https://leetcode.com/problems/max-chunks-to-make-sorted/ this problem became super easy.\\nYou just need to replace each element in the array with its position in the sorted array, for example, switch from [10, 5, 15, 16] to [1, 0, 2, 3] and then use the previous solution.",
      "voteCount": 4
    },
    {
      "name": "deepgodhani",
      "year": 2024,
      "content": "\\nThink:\\nIn a sorted array, at any index, there are no elements greater than the element at that index on the left side, and no elements smaller than it on the right side.\\n\\nTo solve this, check each index, and if we find that we can partition the array at that point, we count it as a valid chunk.\\n\\nTip:\\nUse prefix and suffix arrays to keep track of the previous maximum and the next minimum elements.",
      "voteCount": 3
    },
    {
      "name": "khurmi_03",
      "year": 2024,
      "content": "my god these edge cases come in waves ",
      "voteCount": 2
    }
  ]
}
