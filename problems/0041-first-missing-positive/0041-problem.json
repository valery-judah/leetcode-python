{
  "category": "",
  "id": "41",
  "name": "First Missing Positive",
  "difficulty": "Hard",
  "leetcode_url": "https://leetcode.com/problems/first-missing-positive/",
  "slug": "first-missing-positive",
  "isPaidOnly": false,
  "tags": [
    "Array",
    "Hash Table"
  ],
  "similar_questions": [
    {
      "title": "Missing Number",
      "difficulty": "Easy",
      "slug": "missing-number"
    },
    {
      "title": "Find the Duplicate Number",
      "difficulty": "Medium",
      "slug": "find-the-duplicate-number"
    },
    {
      "title": "Find All Numbers Disappeared in an Array",
      "difficulty": "Easy",
      "slug": "find-all-numbers-disappeared-in-an-array"
    },
    {
      "title": "Couples Holding Hands",
      "difficulty": "Hard",
      "slug": "couples-holding-hands"
    },
    {
      "title": "Smallest Number in Infinite Set",
      "difficulty": "Medium",
      "slug": "smallest-number-in-infinite-set"
    },
    {
      "title": "Maximum Number of Integers to Choose From a Range I",
      "difficulty": "Medium",
      "slug": "maximum-number-of-integers-to-choose-from-a-range-i"
    },
    {
      "title": "Smallest Missing Non-negative Integer After Operations",
      "difficulty": "Medium",
      "slug": "smallest-missing-non-negative-integer-after-operations"
    },
    {
      "title": "Maximum Number of Integers to Choose From a Range II",
      "difficulty": "Medium",
      "slug": "maximum-number-of-integers-to-choose-from-a-range-ii"
    },
    {
      "title": "Smallest Missing Integer Greater Than Sequential Prefix Sum",
      "difficulty": "Easy",
      "slug": "smallest-missing-integer-greater-than-sequential-prefix-sum"
    }
  ],
  "questionId": "41",
  "questionFrontendId": "41",
  "title": "First Missing Positive",
  "titleSlug": "first-missing-positive",
  "content": "<p>Given an unsorted integer array <code>nums</code>. Return the <em>smallest positive integer</em> that is <em>not present</em> in <code>nums</code>.</p>\n\n<p>You must implement an algorithm that runs in <code>O(n)</code> time and uses <code>O(1)</code> auxiliary space.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,0]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The numbers in the range [1,2] are all in the array.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,4,-1,1]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> 1 is in the array but 2 is missing.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [7,8,9,11,12]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The smallest positive integer 1 is missing.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
  "likes": 17836,
  "dislikes": 1946,
  "stats": {
    "totalAccepted": "1.6M",
    "totalSubmission": "3.7M",
    "totalAcceptedRaw": 1550843,
    "totalSubmissionRaw": 3736175,
    "acRate": "41.5%"
  },
  "topicTags": [
    {
      "name": "Array",
      "slug": "array"
    },
    {
      "name": "Hash Table",
      "slug": "hash-table"
    }
  ],
  "metaData": {
    "name": "firstMissingPositive",
    "params": [
      {
        "name": "nums",
        "type": "integer[]"
      }
    ],
    "return": {
      "type": "integer"
    }
  },
  "company_tag_stats": {
    "1": [
      {
        "taggedByAdmin": false,
        "name": "Amazon",
        "slug": "amazon",
        "timesEncountered": 14
      },
      {
        "taggedByAdmin": false,
        "name": "Google",
        "slug": "google",
        "timesEncountered": 12
      }
    ]
  },
  "discussion_posts": [
    {
      "name": "totsubo",
      "year": 2019,
      "content": "The basic idea is that we have an array with n cells (n is the length of the array). The problem description first missing ***positive integer***. If a positive integer is not in the given array it, the missing integer *must* be in the range `[1..n]`. This is the crucial observation we use to deduce the algorithm.\\n\\nSo, If an integer is missing it must be in the range `[1..n]`, if an integer is not missing then the answer is `n+1`.\\n\\nI\\'ll try my best to explain why.\\n\\nLet\\'s picture the only two possibilities:\\n\\n1. There is no missing integer in the array\\n2. There is a missing integer in the array.\\n\\nIf there is *no* missing integers, this means that the array has all number from 1 to n. This must mean that the array is full. Why, because in the range [1..n] there are exactly n numbers, and if you place n numbers in an array of length n, the array is by definition full. (in this case the solution is to return n+1 which is the first smallest integer).\\n\\nOnce you understand the first case above understanding the second is easy. If there *is* a missing integer (or more than one), the missing integer(s), let\\'s call it X, must be in the range 1..n. Why, because if the missing integer X is *not* in the range [1..n] that would imply that all integers [1..n] are in the array, which would mean that the array is full, leaving no space to place X (since X is not in the range [1..n]).\\n\\nThen the algorithm becomes:\\n\\n1. Ignore all numbers <=0 and >n since they are outside the range of possible answers (which we proved was [1..n]). We do this by replacing them with the value n+1.\\n1. For all other integers <n+1, mark their bucket (cell) to indicate the integer exists. (\\\\*see below)\\n1. Find the first cell not marked, that is the first missing integer. If you did not find an unmarked cell, there was no missing integer, so return n+1.\\n\\n\\\\*I recommend looking at this solution for a very smart way to mark the cells:\\n\\nhttps://leetcode.com/problems/first-missing-positive/discuss/17214/Java-simple-solution-with-documentation\\n\\n[**Note**: I find the use of the words *first missing integer* misleading. For example in the array [0,1,2] there is no *missing* integer. What the question really asks is to return the smallest positive integer that is not in the array]\\n",
      "voteCount": 571
    },
    {
      "name": "_ayush9",
      "year": 2023,
      "content": "My second hard which I solved on my own without looking at hints or solution ! <33",
      "voteCount": 230
    },
    {
      "name": "hgscoder",
      "year": 2019,
      "content": "I wish it were written like this:  you are given an unsorted integer array, from which you can infer the value range is [1, n] inclusively, where n is the length of the array, find the very first one not in that range. The current statement is very much misleading: when you are talking about missing, you\\'d better let problem takers know what is expected!",
      "voteCount": 137
    },
    {
      "name": "saikiran1s",
      "year": 2023,
      "content": "This is a hard question because of the space constraint. Otherwise, it is an easy.",
      "voteCount": 84
    },
    {
      "name": "Dirk41",
      "year": 2019,
      "content": "why in the test case:Input: [7,8,9,11,12] Output: is 1 not  10????",
      "voteCount": 65
    },
    {
      "name": "esrujan",
      "year": 2017,
      "content": "The name of the problem and the description is incomplete and very confusing. First missing positive number does not directly indicate that we are looking for smallest missing positive number. That should be made clear by the problem. It took me few minutes and a peep into the discussion forum to know what the problem is expecting me to do.",
      "voteCount": 44
    },
    {
      "name": "GXSC",
      "year": 2021,
      "content": "There are a few key observations:\\n\\n**1 The missing positive integer cannot be bigger than the \"length of the array\" + 1.**\\nSay your array has a length of 5, if the missing integer is 6, that is possible, since you could have 1,2,3,4,5. However, having the missing integer being 7 is impossible, since that would imply that we have from 1 to 6 all in an array of length 5.\\n\\nAs a side note, this condition is generalizable if you want to turn the problem into finding the minimum positive integer while having the positive numbers starting from an arbitrary min (instead of 1). In that case, the max cannot exceed the \"length of the array\" + min. I accidentally solved for that initially - which makes my code and comments pretty aweful.\\n\\n**2 We can ignore any number that is not a possible candidate.**\\nAny number that doesn\\'t fit into our range, we don\\'t care. It would not cause us to mistaken it as the missing number, since it is beyond the range of possible missing numbers. So 0s? negatives? numbers beyond \"length of the array\" + 1? All can be ignored, and their array slot set to some random non-positive number to indicate emptiness.\\n\\n**3 We now know exactly where to put each number.** \\nSince we ignore all numbers not in range, we know that we only have to consider exactly n numbers, where n is the length of the array. And, we know that these numbers range from 1 to n. So, if a number is 3, we put it the slot with index of 3-1 = 2. If the number is 12, we put it in slot 11, etc. Any number beyond range, we set its slot to -1.\\n\\nSo this is just a circular sort. For each number not in a their slot, just swap it with a number in their slot. Do this until the current slot is either having a number in the right place or empty. Look up cycle sort/circle sort/circular sort for more details on this part.\\n\\nThe only thing to watch out is duplicates: they tend to get you infinite loop since you will be keep trying to swap into the same position. Treatment for duplicates are simple: set current slot to empty, since the destination slot already have someone with the right index.\\n\\nOnce this is done, a simple loop to find the first slot with a -1 would give us the first missing positive. And if all slots are filled? Just return the length of the array.\\n\\n**Complexity**\\nFor Big O analysis, you will note that generalized circular sort takes O(N^2). This is due to the fact that in the general algorithm, each step to figure out the correct index takes O(N) by scanning the array. Here we know the right index instantly, so it is O(N). To derive it, think about how many steps did we perform to insert the right element into the right index: each element took exactly 1 step to be inserted to the right place or emptied.",
      "voteCount": 38
    },
    {
      "name": "stackpop",
      "year": 2013,
      "content": "I find that most solutions online assume that array A itself as a hashtable.\\n\\nMy question is how can you guarantee all element in A is not greater than n,which is the array's size.\\n\\n??????\\n\\nfor example\\n\\nA = { 7, 8 , 9,  11,12 }, n = 5\\n\\nall A[i] is greater than n",
      "voteCount": 32
    },
    {
      "name": "farter",
      "year": 2016,
      "content": "shouldn't we consider manipulating the input array as \"using\" that space?\\nsay \"extra space\" to be more strict.\\ni was just considering streamed algorithm without modifying the source array like reading 1TB numbers from backup tapes.\\n\\nalso, as implemented in some solutions, adding / multiplying by N can be considered extending the number's length in bits, as you are restricted only to use the source array's elements, it may cause overflow error when the number is close to the range of that data type. consider what if you get a char array?",
      "voteCount": 31
    },
    {
      "name": "uks4_",
      "year": 2024,
      "content": "Useful Testcases :\\n[1]\\n[-3,9,16,4,5,16,-4,9,26,2,1,19,-1,25,7,22,2,-7,14,2,5,-6,1,17,3,24,-4,17,15]\\n[1,3,5,0]\\n[1,2,2]\\n[2,2]\\n[1,1]",
      "voteCount": 30
    }
  ]
}
