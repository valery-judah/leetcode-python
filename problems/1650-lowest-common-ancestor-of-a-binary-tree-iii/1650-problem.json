{
  "category": "",
  "id": "1650",
  "name": "Lowest Common Ancestor of a Binary Tree III",
  "difficulty": "Medium",
  "leetcode_url": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iii/",
  "slug": "lowest-common-ancestor-of-a-binary-tree-iii",
  "isPaidOnly": true,
  "tags": [
    "Hash Table",
    "Two Pointers",
    "Tree",
    "Binary Tree"
  ],
  "similar_questions": [
    {
      "title": "Lowest Common Ancestor of a Binary Search Tree",
      "difficulty": "Medium",
      "slug": "lowest-common-ancestor-of-a-binary-search-tree"
    },
    {
      "title": "Lowest Common Ancestor of a Binary Tree",
      "difficulty": "Medium",
      "slug": "lowest-common-ancestor-of-a-binary-tree"
    },
    {
      "title": "Lowest Common Ancestor of a Binary Tree II",
      "difficulty": "Medium",
      "slug": "lowest-common-ancestor-of-a-binary-tree-ii"
    },
    {
      "title": "Lowest Common Ancestor of a Binary Tree IV",
      "difficulty": "Medium",
      "slug": "lowest-common-ancestor-of-a-binary-tree-iv"
    }
  ],
  "questionId": "1790",
  "questionFrontendId": "1650",
  "title": "Lowest Common Ancestor of a Binary Tree III",
  "titleSlug": "lowest-common-ancestor-of-a-binary-tree-iii",
  "content": "<p>Given two nodes of a&nbsp;binary tree <code>p</code> and <code>q</code>, return <em>their&nbsp;lowest common ancestor (LCA)</em>.</p>\n\n<p>Each node will have a reference to its parent node. The definition for <code>Node</code> is below:</p>\n\n<pre>\nclass Node {\n    public int val;\n    public Node left;\n    public Node right;\n    public Node parent;\n}\n</pre>\n\n<p>According to the <strong><a href=\"https://en.wikipedia.org/wiki/Lowest_common_ancestor\" target=\"_blank\">definition of LCA on Wikipedia</a></strong>: &quot;The lowest common ancestor of two nodes p and q in a tree T is the lowest node that has both p and q as descendants (where we allow <b>a node to be a descendant of itself</b>).&quot;</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/14/binarytree.png\" style=\"width: 200px; height: 190px;\" />\n<pre>\n<strong>Input:</strong> root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The LCA of nodes 5 and 1 is 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/14/binarytree.png\" style=\"width: 200px; height: 190px;\" />\n<pre>\n<strong>Input:</strong> root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> The LCA of nodes 5 and 4 is 5 since a node can be a descendant of itself according to the LCA definition.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1,2], p = 1, q = 2\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[2, 10<sup>5</sup>]</code>.</li>\n\t<li><code>-10<sup>9</sup> &lt;= Node.val &lt;= 10<sup>9</sup></code></li>\n\t<li>All <code>Node.val</code> are <strong>unique</strong>.</li>\n\t<li><code>p != q</code></li>\n\t<li><code>p</code> and <code>q</code> exist in the tree.</li>\n</ul>\n",
  "likes": 1515,
  "dislikes": 59,
  "stats": {
    "totalAccepted": "383K",
    "totalSubmission": "463.3K",
    "totalAcceptedRaw": 383040,
    "totalSubmissionRaw": 463270,
    "acRate": "82.7%"
  },
  "topicTags": [
    {
      "name": "Hash Table",
      "slug": "hash-table"
    },
    {
      "name": "Two Pointers",
      "slug": "two-pointers"
    },
    {
      "name": "Tree",
      "slug": "tree"
    },
    {
      "name": "Binary Tree",
      "slug": "binary-tree"
    }
  ],
  "metaData": {
    "name": "lowestCommonAncestor",
    "params": [
      {
        "name": "root",
        "type": "integer[]"
      },
      {
        "type": "integer",
        "name": "p"
      },
      {
        "type": "integer",
        "name": "q"
      }
    ],
    "return": {
      "type": "TreeNode"
    },
    "manual": true,
    "languages": [
      "cpp",
      "java",
      "python",
      "c",
      "csharp",
      "javascript",
      "ruby",
      "swift",
      "golang",
      "python3",
      "scala",
      "kotlin",
      "php",
      "typescript"
    ],
    "typescriptCustomType": "class _Node {\n    val: number\n    left: _Node | null\n    right: _Node | null\n    parent: _Node | null\n    \n    constructor(v: number) {\n        this.val = v;\n        this.left = null;\n        this.right = null;\n        this.parent = null;\n    }\n}"
  },
  "company_tag_stats": {
    "1": [
      {
        "taggedByAdmin": true,
        "name": "Meta",
        "slug": "facebook",
        "timesEncountered": 130
      }
    ]
  },
  "discussion_posts": [
    {
      "name": "Jorea",
      "year": 2024,
      "content": "Just got this question on my facebook onsite",
      "voteCount": 80
    },
    {
      "name": "addiwei",
      "year": 2022,
      "content": "The key detail to solve this that separates this problem from other binary tree problems is the \"parent\" attribute.   Once you see that piece of information it becomes clearer.   \\n\\nIf you don\\'t pay attention to that attribute or read it carefully, you are really scratching your head in regards to root traversal using DFS vs. BFS.\\n\\nOther aspects of this problem:\\n1) root of the tree is not passed into the function.    You are only passed \\'p\\' and \\'q\\'. \\n2) Return the ancestor node itself and not the \"val\" of the node.   \\n",
      "voteCount": 44
    },
    {
      "name": "vyshnavkr",
      "year": 2021,
      "content": "This is similar to Intersection of 2 Linked Lists. We can use any of Hashset / Height difference / Cycle approach.\\n[Great learnings on 3 different approaches.](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iii/discuss/950242/Multiple-solution-approaches-in-Java-(with-comments-and-explanation)",
      "voteCount": 18
    },
    {
      "name": "justinkangg",
      "year": 2023,
      "content": "For those who have seen this problem in an interview: were you asked any follow up questions?",
      "voteCount": 13
    },
    {
      "name": "Guru_Coder",
      "year": 2022,
      "content": "This is easiest medium I have seen.\\n\\nReally wish the inverviewers think the same :)",
      "voteCount": 12
    },
    {
      "name": "zihanxu",
      "year": 2024,
      "content": "Who else was thinking about recursion and traversal of trees? The function doesn\\'t even provide the root node. ><",
      "voteCount": 9
    },
    {
      "name": "wp313",
      "year": 2024,
      "content": "Same as a linked list easy question #160 Intersection of Two Linked Lists(https://leetcode.com/problems/intersection-of-two-linked-lists/description/)",
      "voteCount": 6
    },
    {
      "name": "056b683f",
      "year": 2023,
      "content": "Wow! The first medium I was able to solve!",
      "voteCount": 5
    },
    {
      "name": "theDev99",
      "year": 2024,
      "content": "Few ways I have solved this from less to most efficient/optimal:\\n\\u2022 using Map to store parent/child\\n\\u2022 using a Set to store path to root\\n\\u2022 two pointer using \"race track\" intuition",
      "voteCount": 4
    },
    {
      "name": "Alcas1",
      "year": 2023,
      "content": "An intuitive way to solve is to first traverse to the root node by recursing p or q\\'s parent(either works because there\\'s only one root). Then you can copy and paste the same method as https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/",
      "voteCount": 3
    }
  ]
}
