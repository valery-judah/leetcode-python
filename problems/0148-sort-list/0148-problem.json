{
  "category": "",
  "id": "148",
  "name": "Sort List",
  "difficulty": "Medium",
  "leetcode_url": "https://leetcode.com/problems/sort-list/",
  "slug": "sort-list",
  "isPaidOnly": false,
  "tags": [
    "Linked List",
    "Two Pointers",
    "Divide and Conquer",
    "Sorting",
    "Merge Sort"
  ],
  "similar_questions": [
    {
      "title": "Merge Two Sorted Lists",
      "difficulty": "Easy",
      "slug": "merge-two-sorted-lists"
    },
    {
      "title": "Sort Colors",
      "difficulty": "Medium",
      "slug": "sort-colors"
    },
    {
      "title": "Insertion Sort List",
      "difficulty": "Medium",
      "slug": "insertion-sort-list"
    },
    {
      "title": "Sort Linked List Already Sorted Using Absolute Values",
      "difficulty": "Medium",
      "slug": "sort-linked-list-already-sorted-using-absolute-values"
    }
  ],
  "questionId": "148",
  "questionFrontendId": "148",
  "title": "Sort List",
  "titleSlug": "sort-list",
  "content": "<p>Given the <code>head</code> of a linked list, return <em>the list after sorting it in <strong>ascending order</strong></em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg\" style=\"width: 450px; height: 194px;\" />\n<pre>\n<strong>Input:</strong> head = [4,2,1,3]\n<strong>Output:</strong> [1,2,3,4]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg\" style=\"width: 550px; height: 184px;\" />\n<pre>\n<strong>Input:</strong> head = [-1,5,3,4,0]\n<strong>Output:</strong> [-1,0,3,4,5]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> head = []\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is in the range <code>[0, 5 * 10<sup>4</sup>]</code>.</li>\n\t<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Can you sort the linked list in <code>O(n logn)</code> time and <code>O(1)</code> memory (i.e. constant space)?</p>\n",
  "likes": 12578,
  "dislikes": 400,
  "stats": {
    "totalAccepted": "1.1M",
    "totalSubmission": "1.8M",
    "totalAcceptedRaw": 1117750,
    "totalSubmissionRaw": 1783682,
    "acRate": "62.7%"
  },
  "topicTags": [
    {
      "name": "Linked List",
      "slug": "linked-list"
    },
    {
      "name": "Two Pointers",
      "slug": "two-pointers"
    },
    {
      "name": "Divide and Conquer",
      "slug": "divide-and-conquer"
    },
    {
      "name": "Sorting",
      "slug": "sorting"
    },
    {
      "name": "Merge Sort",
      "slug": "merge-sort"
    }
  ],
  "metaData": {
    "name": "sortList",
    "params": [
      {
        "name": "head",
        "type": "ListNode",
        "dealloc": false
      }
    ],
    "return": {
      "type": "ListNode",
      "dealloc": true
    }
  },
  "discussion_posts": [
    {
      "name": "aliensfm",
      "year": 2023,
      "content": " `Can you sort the linked list in O(n logn) time and O(1) memory?`\nNo, you can`t.",
      "voteCount": 309
    },
    {
      "name": "Kostya_Kostya",
      "year": 2020,
      "content": "I see all these recursive algorithms and their authors claim to have O(1) space complexity.\\nBut is that actually so?\\nWhy don\\'t you count stack frames for every recursive call (and storage for local variables for every call on top of that)?\\nShouldn\\'t that really equal to depth of recursion complexity spacewise?\\nAm I missing something?",
      "voteCount": 124
    },
    {
      "name": "ghost89413",
      "year": 2014,
      "content": "I know most people use quick sort to solve this problem. But in fact the space complexity of the quick sort should be *O(nlogn)* because of the stack allocation(such as the return address pushed in the stack, local variables you used in recursion function). \\nActually, any divide-and-conquer approaches (like merge sort *even for the in-place merge implementation*, quick sort) for this problem requires more than constant memory. Without divide-and-conquer approach, the only way I know for sorting in O(nlogn) time is heap sort. Unfortunately, this solution is even worse than divide-and-conquer approach.\\n\\nThere is some algorithm uses constant memory space like bubble sort, insertion sort ,etc. But the time complexity of none of them are O(nlogn). \\n\\nSo I feel so confused about this, Is there any sorting algorithm we can use here to get a real constant memory complexity? But it seems impossible to me, so does anyone have ideas about this?",
      "voteCount": 76
    },
    {
      "name": "Pranay_Dutta",
      "year": 2024,
      "content": "Using vector to store the values feels like I\\'m robbing a bank\\uD83E\\uDEE5",
      "voteCount": 69
    },
    {
      "name": "aesteve",
      "year": 2023,
      "content": "Honestly, this one is really hard for a medium. \nTake your time and breath with a step by step approach: \n* think of the sort algorithms you know, one must be accurate here\n* think of what's great about linked lists, and what kind of modifications we can do with them easily\n\nIf you used a search algorithm you know and get a TLE, is there an \"improved\" version of it? Or try a different one?\n\nFinally (and this may give you too much info so don't read to avoid spoilers), yes, linked lists can't be addressed by indices, but still, this doesn't mean we can't reach some specific indices relatively quickly. (this is what I missed, I disqualified this sort algorithm because I thought \"I can't do that efficiently with a linked list\")\n\nNow, if you have a proper (spoiler alert: recursive) sort in place, and therefore a recursive stack you want to eliminate for an O(1) space approach, remember what we can do with some recursive problems.\n\nReally, this one is way harder than it looks at 1st sight.\n",
      "voteCount": 59
    },
    {
      "name": "_Tanmay",
      "year": 2023,
      "content": "The website still accepts this solution due to a mistake in the review process, a bug in the testing system, or an oversight in the solution submission guidelines.\n\nf=open(\"user.out\",'w')\nwhile True:\n    try:\n        n=input()\n        if len(n)==2:\n            print('[]',file=f)\n            continue\n        arr=list(map(int,n[1:-1].split(',')))\n        arr=[str(i) for i in sorted(arr)]\n        print('['+','.join(arr)+']',file=f)\n    except:\n        f.close()\n        exit(0)\n\nPlease upvote this so that this can get notified.",
      "voteCount": 49
    },
    {
      "name": "bredtost",
      "year": 2024,
      "content": "I GOT TLE FOR 29/30 \\uD83D\\uDE2D",
      "voteCount": 42
    },
    {
      "name": "McGar",
      "year": 2013,
      "content": "What does it mean? No extra space or  O(1) extra space? \\nWhat if using recursion, does the stack count as constant space?",
      "voteCount": 29
    },
    {
      "name": "qwer111",
      "year": 2016,
      "content": "Hi, I am confused about the definition of \"constant space\". As far as I know, space complexity is the total space excluding result that has been used to solve the problem. So when we use recursion, shouldn't we take the stack memory space of the recursion path into consideration? If so, using mergesort for this problem should costs O(log n) + O(1) = O(log n) space, assuming n is the length of the list.\\n\\nIf I am in a interview, does the interviewer expect me to say O(log n) or O(1)?",
      "voteCount": 12
    },
    {
      "name": "GuaGua",
      "year": 2014,
      "content": "I solved this problem using a recursive method and got accepted. Then I noticed the requirement of constant space.  How come a recursive method needs constant space? A bug?",
      "voteCount": 10
    }
  ]
}
