---
description: Project rules and workflows for Cline in this LeetCode Python workspace. Optimized for test-first loops and strict Memory Bank hygiene.
version: 1.1
tags: ["cline", "rules", "leetcode", "python", "memory-bank", "tdd"]
globs:
  # Core knowledge to always load first
  - "memory-bank/**/*.md"
  - "docs/interview-framework.md"
  # Active task context and progress
  - "memory-bank/activeContext.md"
  - "memory-bank/progress.md"
  - "memory-bank/patterns.md"
  # Problem artifacts
  - "tasks/**/README.md"
  - "tasks/**/solution.py"
  - "tasks/**/test_solution.py"
  # Tooling
  - "pyproject.toml"
  - "requirements-dev.txt"
  - "Makefile"
  - ".pre-commit-config.yaml"
  - ".vscode/*.json"
---

# Cline Operating Rules

## Core Behavior
1. Always open and read **all Memory Bank files** before acting. Highest priority: `memory-bank/activeContext.md`, `memory-bank/progress.md`.
2. Keep `activeContext.md` accurate. Update it at the start of every session and after each significant step.
3. Prefer **tests first**. If tests are missing, write minimal failing tests in `tasks/<id-slug>/test_solution.py` using `pytest.mark.parametrize`.
4. Keep solutions simple, readable, and measured. Favor O(n) or O(n log n) unless constraints require otherwise.
5. Run `make fmt` after edits. Use `make test`, `make lint`, `make type` regularly.
6. Persist learnings in `memory-bank/patterns.md` and session notes in `progress.md` at wrap-up.

## File Conventions
- Tasks live in `tasks/NNNN-slug/` where NNNN is 4-digit problem number.
- Each task has `README.md`, `solution.py`, `test_solution.py`, `__init__.py`.
- Use Python ≥3.10. Style by ruff + black. Keep line length ≤100.

## Session Protocol
1. **Initialize**
   - Ensure venv is active. If not, activate project venv or use VS Code interpreter.
   - `pip install -r requirements-dev.txt` if tools are missing.
2. **Load Context**
   - Read `docs/interview-framework.md` and all Memory Bank files.
   - If `activeContext.md` is empty, create boilerplate with fields: date, task, constraints, approach, test plan, TODO.
3. **Execute**
   - Follow the relevant Workflow (below). Keep `activeContext.md` updated.
4. **Wrap Up**
   - Update `progress.md` with result, time, complexity, errors, insights.
   - Append reusable technique to `patterns.md` if applicable.
   - Run `make fmt` and `make test`. Commit.

---

# Workflows

## 1) Create New Problem
**When**: user says “new”, “create”, “bootstrap”, or provides slug/number.

**Steps**
1. Generate skeleton:
   ```bash
   python scripts/new_task.py <slug> <number> --difficulty <easy|medium|hard> --tags "<csv>" --url "https://leetcode.com/problems/<slug>/"
   ```
2. Open files:
   - `tasks/<NNNN-slug>/README.md`
   - `tasks/<NNNN-slug>/test_solution.py`
   - `tasks/<NNNN-slug>/solution.py`
3. Update `memory-bank/activeContext.md`:
   - Problem number, slug, URL, difficulty.
   - Extract constraints from LeetCode prompt and add to **Constraints** section.
   - Draft small **Test Plan** with 3–5 cases including edge cases.
4. Stage seed commit:
   ```bash
   git add -A && git commit -m "chore(task): scaffold <NNNN-slug>"
   ```

## 2) TDD Solve Loop
**When**: solution doesn’t exist or tests are failing.

**Loop**
1. Write or expand tests in `test_solution.py` using examples and edge cases.
2. Run tests:
   ```bash
   pytest -q
   ```
3. Implement minimal code in `solution.py` to pass the next failing test.
4. Repeat until all tests pass.
5. Run quality gates:
   ```bash
   make fmt && make lint && make type && make test
   ```
6. Update `activeContext.md` with Complexity (time/space) and Approach summary.
7. Commit:
   ```bash
   git add -A && git commit -m "feat(task): pass tests for <NNNN-slug> with <technique>"
   ```

## 3) Refactor & Document
1. Improve names, factor helpers, remove duplication.
2. Add docstring to `Solution` method with:
   - Problem link
   - Constraints
   - Algorithm summary
   - Complexity
3. Re-run quality gates (`make fmt`, `make lint`, `make type`, `make test`).
4. Commit:
   ```bash
   git add -A && git commit -m "refactor(task): simplify <NNNN-slug> implementation"
   ```

## 4) Session Wrap-Up
1. Update `memory-bank/progress.md` table with:
   - Date, Problem, Difficulty, Status (solved/partial/blocked), Time spent, Attempts, Complexity, Notes.
2. Append pattern summary to `memory-bank/patterns.md` (template below).
3. Push if repo is connected:
   ```bash
   git push --set-upstream origin HEAD
   ```

---

# Memory Bank Update Commands

> Use these snippets to quickly maintain state.

### Initialize activeContext.md
```md
# Active Context
- Date: <YYYY-MM-DD HH:MM>
- Task: <NNNN-slug>
- URL: <link>
- Difficulty: <easy|medium|hard>
- Constraints: <n, ranges, structure, special cases>
- Approach: <technique + justification>
- Test Plan: <bulleted cases>
- TODO:
  - [ ] Write tests
  - [ ] Implement
  - [ ] Optimize
  - [ ] Document
```

### Append to progress.md
```md
| Date | Task | Diff | Status | Time | Attempts | Time/Space | Notes |
|------|------|------|--------|------|----------|------------|-------|
| <date> | <NNNN-slug> | <d> | <solved|partial|blocked> | <Xm> | <n> | O(...) / O(...) | <insights> |
```

### Add pattern to patterns.md
```md
## <Pattern Name>
**Use when**: <conditions>  
**Idea**: <1–2 lines>  
**Template**:
```python
def solve(...):
    # canonical snippet
    pass
```
**Pitfalls**: <gotchas>
```

---

# Guardrails
- Never delete or overwrite Memory Bank files without an explicit request.
- Keep problem solutions deterministic and pure; avoid I/O in core logic.
- Prefer clarity over cleverness. Add comments only where logic isn’t obvious.
- If uncertain about constraints, add clarifying questions to task README and `activeContext.md`.

---

# Quick Commands

```bash
# Activate tools
pip install -r requirements-dev.txt

# Create a new problem
python scripts/new_task.py two-sum 1 --difficulty easy --tags array,hash-map --url https://leetcode.com/problems/two-sum/

# Quality gates
make fmt && make lint && make type && make test
```
